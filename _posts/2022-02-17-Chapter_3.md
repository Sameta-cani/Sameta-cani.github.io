---
layout: single
title:  "내장 자료구조, 함수, 파일"
categories: Python_for_Data_Analysis
tag: [python]
toc: true
author_profile: false
published: false
---

<head>
  <style>
    table.dataframe {
      white-space: normal;
      width: 100%;
      height: 240px;
      display: block;
      overflow: auto;
      font-family: Arial, sans-serif;
      font-size: 0.9rem;
      line-height: 20px;
      text-align: center;
      border: 0px !important;
    }

    table.dataframe th {
      text-align: center;
      font-weight: bold;
      padding: 8px;
    }

    table.dataframe td {
      text-align: center;
      padding: 8px;
    }

    table.dataframe tr:hover {
      background: #b8d1f3; 
    }

    .output_prompt {
      overflow: auto;
      font-size: 0.9rem;
      line-height: 1.45;
      border-radius: 0.3rem;
      -webkit-overflow-scrolling: touch;
      padding: 0.8rem;
      margin-top: 0;
      margin-bottom: 15px;
      font: 1rem Consolas, "Liberation Mono", Menlo, Courier, monospace;
      color: $code-text-color;
      border: solid 1px $border-color;
      border-radius: 0.3rem;
      word-break: normal;
      white-space: pre;
    }

  .dataframe tbody tr th:only-of-type {
      vertical-align: middle;
  }

  .dataframe tbody tr th {
      vertical-align: top;
  }

  .dataframe thead th {
      text-align: center !important;
      padding: 8px;
  }

  .page__content p {
      margin: 0 0 0px !important;
  }

  .page__content p > strong {
    font-size: 0.8rem !important;
  }

  </style>
</head>


## 자료구조와 순차 자료형


### 튜플

1차원의 고정된 크기를 가지는 변경 불가능한 순차 자료형





생성하는 방법은 쉼표로 구분된 값을 대입한다.



```python
tup = 3, 7, 5
tup
```

<pre>
(3, 7, 5)
</pre>
괄호를 사용해서 값을 묶어줌으로써 중첩된 튜플을 정의할 수 있다.



```python
nested_tup = (1, 5, 10, 15), (1, 7, 8)
nested_tup
```

<pre>
((1, 5, 10, 15), (1, 7, 8))
</pre>
모든 순차형 자료형이나 iterator 는 tuple 메서드를 호출해 튜플로 변환할 수 있다.



```python
tuple([4, 1, 5])
```

<pre>
(4, 1, 5)
</pre>

```python
tup = tuple('python')
print(tup)
```

<pre>
('p', 'y', 't', 'h', 'o', 'n')
</pre>
튜플의 각 원소는 대괄호 []에 색인을 넣어서 접근할 수 있고, 슬라이싱도 가능하다.



```python
tup[0]
```

<pre>
'p'
</pre>

```python
tup[1:3]
```

<pre>
('y', 't')
</pre>
튜플은 변경이 불가능하다.



```python
tup = tuple(['py', [4, 1, 3], tuple('leader')])
tup[2] = 'thon' # 결과에는 보이지 않지만 TypeError: 'tuple' object does not support item assignment 라고 출력된다.
```

튜플 내에 저장된 객체는 그 위치에서 바로 변경이 가능하다.



```python
tup[1].append(5)
tup # 기존 [4, 1, 3]에서 [4, 1, 3, 5]로 변경된 것을 볼 수 있다.
```

<pre>
('py', [4, 1, 3, 5], ('l', 'e', 'a', 'd', 'e', 'r'))
</pre>
튜플에 정수를 곱하면 튜플의 복사본이 반복되어 늘어난다.



```python
('hello', 'world') * 4
```

<pre>
('hello', 'world', 'hello', 'world', 'hello', 'world', 'hello', 'world')
</pre>
튜플 패킹과 언패킹



```python
# 튜플 패킹
tup = (1, 2, 3)

# 튜플 언패킹
a, b, c = tup

b
```

<pre>
2
</pre>
중첩된 튜플도 패킹과 언패킹이 가능하다.



```python
tup = 1, 2, (3, 4)

a, b, c = tup

c
```

<pre>
(3, 4)
</pre>
튜플을 사용하면 두 변수의 값을 편리하게 바꿀 수 있다.



```python
a, b = 1, 9 # a = 1, b = 9
b, a = 9, 1
print(a)
print(b)
```

<pre>
1
9
</pre>
편리하게 순회도 가능하다.



```python
seq = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]

for a, b, c in seq:
    print('a={0}, b={1}, c={2}'.format(a, b, c))
```

<pre>
a=1, b=2, c=3
a=4, b=5, c=6
a=7, b=8, c=9
</pre>
담고자 하는 튜플의 길이를 알 수 없을 때는 *를 사용한다.



```python
values = 1, 2, 3, 4, 5
a, b, *rest = values
a, b
```

<pre>
(1, 2)
</pre>

```python
rest # a, b에는 각각 1과 2가 들어가고 남은 3, 4, 5는 리스트 형식으로 rest에 대입됐다.
```

<pre>
[3, 4, 5]
</pre>
count 메서드는 인자로 주어진 값의 갯수를 반환해준다.



```python
a = (1, 2, 2, 2, 3, 4, 2, 1)

a.count(2)
```

<pre>
4
</pre>
index 메서드는 인자로 주어진 값의 위치를 반환해준다. (여러 개일 경우에는 맨 처음 위치만 반환)



```python
a.index(1)
```

<pre>
0
</pre>
tuple 메서드 외에도 파이썬 내장 함수인 len(), max(), min() 등이 있다.



```python
print(len(a)) # 튜플 내 원소의 갯수
print(max(a)) # 튜플 내 원소의 최댓값
print(min(a)) # 튜플 내 원소의 최솟값
```

<pre>
8
4
1
</pre>
### 리스트


객체의 1차원 순차적 자료구조로 튜플과 다르게 크기나 내용의 변경이 가능하다.





대괄호 []나 list() 함수를 사용하여 생성할 수 있다.



```python
a_list = [2, 3, 7, None]

tup = ('foo', 'bar', 'baz')

b_list = list(tup)

b_list
```

<pre>
['foo', 'bar', 'baz']
</pre>

```python
b_list[1] = 'peekaboo' # 튜플은 TypeError가 뜨지만 리스트는 값의 변경이 가능하다.
b_list
```

<pre>
['foo', 'peekaboo', 'baz']
</pre>
list() 함수는 iterator나 generator 표현에서 실제 값을 모두 담기 위한 용도로 자주 사용된다.



```python
gen = range(10) # range(10)은 0부터 10-1까지의 값을 1씩 증가시킨 값을 반환해준다.

gen # generator이므로 바로 값을 반환해주는 것이 아닌, 함수가 호출될 때 반환해주는 iterator의 일종이다.
```

<pre>
range(0, 10)
</pre>

```python
list(gen)
```

<pre>
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</pre>
append 메서드를 사용해서 리스트의 끝에 새로운 값을 추가할 수 있다.



```python
b_list
```

<pre>
['foo', 'peekaboo', 'baz']
</pre>

```python
b_list.append('dwarf')

b_list
```

<pre>
['foo', 'peekaboo', 'baz', 'dwarf']
</pre>
insert 메서드는 리스트의 특정 위치에 값을 추가할 수 있다.



```python
b_list.insert(2, 'python')

b_list
```

<pre>
['foo', 'peekaboo', 'python', 'baz', 'dwarf']
</pre>
pop 메서드는 리스트의 특정 위치의 값을 **반환**하고 해당 값을 리스트에서 삭제한다.



```python
pop_value = b_list.pop(2)
pop_value
```

<pre>
'python'
</pre>

```python
b_list
```

<pre>
['foo', 'peekaboo', 'baz', 'dwarf']
</pre>
remove 메서드는 주어진 인자의 값을 리스트에서 앞에서부터 1개만 삭제한다.



```python
b_list.append('baz') # 1개만 삭제되는 것을 보이기위해 'baz'를 추가한다.

b_list
```

<pre>
['foo', 'peekaboo', 'baz', 'dwarf', 'baz']
</pre>

```python
b_list.remove('baz')

b_list # b_list[2]인 'baz'만 삭제되고 맨 마지막에 추가된 'baz'는 그대로 있는 모습
```

<pre>
['foo', 'peekaboo', 'dwarf', 'baz']
</pre>
in 예약어와 not 예약어를 사용하여 값의 유무를 검사할 수 있다.



```python
'peekaboo' in b_list # 'peekaboo'가 b_list에 존재하는가?
```

<pre>
True
</pre>

```python
'peekaboo' not in b_list # 'peekaboo'가 b_list에 존재하지 않는가?
```

<pre>
False
</pre>
참고로 리스트에 어떤 값이 있는지 검사하는 것은 리스트의 모든 값을 일일이 검사해야 하므로 많이 느리다.


튜플과 마찬가지로 + 연산자를 이용하면 두 개의 리스트를 합칠 수 있다.



```python
[4, None, 'foo'] + [7, 8, (2, 3)]
```

<pre>
[4, None, 'foo', 7, 8, (2, 3)]
</pre>
extend 메서드는 여러 개의 값을 추가할 수 있다.



```python
x = [4, None, 'foo']

x.extend([7, 8, (2, 3)])

x
```

<pre>
[4, None, 'foo', 7, 8, (2, 3)]
</pre>
sort 함수를 이용해서 리스트를 정렬할 수 있다.



```python
a = [7, 2, 5, 1, 3]

a.sort()

a
```

<pre>
[1, 2, 3, 5, 7]
</pre>
sort()는 key인자에 값을 넣어 해당하는 기준으로 값을 정렬할 수 있다.



```python
b = ['swa', 'small', 'H', 'foxes', 'six']

b.sort(key=len) # key 값에 len 을 넣으면 각 원소의 길이를 기준으로 정렬을 한다.

b
```

<pre>
['H', 'swa', 'six', 'small', 'foxes']
</pre>
내장 bisect 모듈은 이진 탐색과 정렬된 리스트에 값을 추가하는 기능을 제공한다.


bisect.bisect_left는 해당 값이 추가될 때 정렬된 상태를 유지할 수 있는 왼쪽의 위치를 반환하며



bisect.bisect와 bisect.bisect_right는 오른쪽의 위치를 반환한다.



```python
import bisect

c = [1, 2, 2, 2, 3, 4, 7]

bisect.bisect_left(c, 2)
```

<pre>
1
</pre>

```python
bisect.bisect(c, 2)
```

<pre>
4
</pre>

```python
bisect.bisect_right(c, 8) - bisect.bisect_left(c, 2) # 이런 식으로 2부터 8까지 해당하는 값의 갯수를 파악할 수도 있다.
```

<pre>
6
</pre>
튜플과 마찬가지로 리스트도 슬라이싱이 가능하다. [start:stop:step]을 지정하면 된다. 단, stop 값은 포함하지 않는다.



```python
seq = [7, 2, 3, 7, 5, 6, 0, 1]

seq[1:5] # step은 생략하면 default인 1로 설정
```

<pre>
[2, 3, 7, 5]
</pre>

```python
seq[3:4] = [6, 3]

seq # 대입도 가능
```

<pre>
[7, 2, 3, 6, 3, 5, 6, 0, 1]
</pre>

```python
seq[:5] # start를 생략하면 0이 들어간다. 즉, seq[0:5]와 같다.
```

<pre>
[7, 2, 3, 6, 3]
</pre>

```python
seq[3:] # stop을 생략하면 마지막 값이 들어간다. 즉, seq[3:7]와 같다.
```

<pre>
[6, 3, 5, 6, 0, 1]
</pre>

```python
seq[-4:] # 음수 색인은 맨 뒤부터 -1로 시작한다.
```

<pre>
[5, 6, 0, 1]
</pre>

```python
seq[-6:-2]
```

<pre>
[6, 3, 5, 6]
</pre>

```python
seq[::-1] # [::-1]로 색인을 하면 역순으로 반환된다.
```

<pre>
[1, 0, 6, 5, 3, 6, 3, 2, 7]
</pre>
### 내장 순차 자료형 함수


enumerate 함수는 순차 자료형에서 현재 아이템의 색인을 반환해준다.



```python
some_list = ['foo', 'bar', 'baz']

for index, value in enumerate(some_list):
    print('{}: {}'.format(index, value))
```

<pre>
0: foo
1: bar
2: baz
</pre>
sorted 함수는 정렬된 새로운 순차 자료형을 반환한다.



```python
b = ['swa', 'small', 'H', 'foxes', 'six']

c = sorted(b)

c # c에는 정렬된 값이 들어간다.
```

<pre>
['H', 'foxes', 'six', 'small', 'swa']
</pre>

```python
b
```

<pre>
['swa', 'small', 'H', 'foxes', 'six']
</pre>
zip 함수는 여러 개의 리스트나 튜플 또는 다른 순차 자료형을 서로 짝지어서 튜플의 리스트를 생성한다.



```python
seq1 = ['foo', 'bar', 'baz']
seq2 = ['one', 'two', 'three']
zipped = zip(seq1, seq2)
zipped
```

<pre>
<zip at 0x20fa583e288>
</pre>

```python
list(zipped)
```

<pre>
[('foo', 'one'), ('bar', 'two'), ('baz', 'three')]
</pre>

```python
seq3 = [False, True]

list(zip(seq1, seq2, seq3)) # 길이가 가장 짧은 seq3에 맞춰서 2개의 튜플만 출력된 모습
```

<pre>
[('foo', 'one', False), ('bar', 'two', True)]
</pre>

```python
for i, (a, b) in enumerate(zip(seq1, seq2)):
    print('{0}: {1}, {2}'.format(i, a, b))
```

<pre>
0: foo, one
1: bar, two
2: baz, three
</pre>

```python
pitchers = [('Nolan', 'Ryan'), ('Roger', 'Clemens'),
            ('Schilling', 'Curt')]
```


```python
pitchers
```

<pre>
[('Nolan', 'Ryan'), ('Roger', 'Clemens'), ('Schilling', 'Curt')]
</pre>

```python
first_names, last_names = zip(*pitchers)
```


```python
first_names
```

<pre>
('Nolan', 'Roger', 'Schilling')
</pre>

```python
last_names
```

<pre>
('Ryan', 'Clemens', 'Curt')
</pre>
reversed는 순차 자료형을 역순으로 순회한다.



```python
list(reversed(range(10))) # reversed는 generator이므로 list()를 통해 출력이 가능하다.
```

<pre>
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
</pre>