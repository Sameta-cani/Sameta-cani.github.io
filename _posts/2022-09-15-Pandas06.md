---
layout: single
title:  "Pandas06"
categories: pandas
tag: [python, pandas]
toc: true
author_profile: false
toc_sticky: true
---

<head>
  <style>
    table.dataframe {
      white-space: normal;
      width: 100%;
      height: 240px;
      display: block;
      overflow: auto;
      font-family: Arial, sans-serif;
      font-size: 0.9rem;
      line-height: 20px;
      text-align: center;
      border: 0px !important;
    }

    table.dataframe th {
      text-align: center;
      font-weight: bold;
      padding: 8px;
    }

    table.dataframe td {
      text-align: center;
      padding: 8px;
    }

    table.dataframe tr:hover {
      background: #b8d1f3; 
    }

    .output_prompt {
      overflow: auto;
      font-size: 0.9rem;
      line-height: 1.45;
      border-radius: 0.3rem;
      -webkit-overflow-scrolling: touch;
      padding: 0.8rem;
      margin-top: 0;
      margin-bottom: 15px;
      font: 1rem Consolas, "Liberation Mono", Menlo, Courier, monospace;
      color: $code-text-color;
      border: solid 1px $border-color;
      border-radius: 0.3rem;
      word-break: normal;
      white-space: pre;
    }

  .dataframe tbody tr th:only-of-type {
      vertical-align: middle;
  }

  .dataframe tbody tr th {
      vertical-align: top;
  }

  .dataframe thead th {
      text-align: center !important;
      padding: 8px;
  }

  .page__content p {
      margin: 0 0 0px !important;
  }

  .page__content p > strong {
    font-size: 0.8rem !important;
  }

  </style>
</head>


# 데이터 집계와 그룹 연산


데이터셋을 분류하고 각 그룹에 집계나 변형 같은 함수를 적용하는 건 데이터 분석 과정에서 무척 중요한 일이다. 데이터를 불러오고 취합해서 하나의 데이터 집합을 준비하고 나면 그룹 통계를 구하거나 가능하다면 <strong>피벗테이블</strong>[^1]을 구해서 보고서를 만들거나 시각화하게 된다. 판다스는 데이터 집합을 자연스럽게 나누고 요약할 수 있는 groupby라는 유연한 방법을 제공한다.<br><br>

관계형 데이터베이스와 SQL<sup>Structured Query Language</sup>이 인기 있는 이유 중 하나는 데이터를 쉽게 합치고 걸러내고 변형하고 집계할 수 있기 때문이다. 하지만 SQL 같은 쿼리문은 그룹 연산에 제약이 있다. 앞으로 살펴보겠지만 파이썬과 판다스의 강력한 표현력을 잘 이용하면 아주 복잡한 그룹 연산도 판다스 객체나 NumPy 배열을 받는 함수의 조합으로 해결할 수 있다. 여기서는 다음 내용을 배우게 된다.<br><br>

- 하나 이상의 키(함수, 배열, 데이터프레임의 칼럼 이름)를 이용해서 판다스 객체를 여러 조각으로 나누는 방법

- 합계, 평균, 표준편차, 사용자 정의 함수 같은 그룹 요약 통계를 계산하는 방법

- 정규화, 선형회귀, 등급 또는 부분집합 선택 같은 집단 내 변형이나 다른 조작을 적용하는 방법

- 피벗테이블과 교차일람표를 구하는 방법

- 변위치 분석과 다른 통계 집단 분석을 수행하는 방법



[^1]: 피벗 테이블(pivot table)은 커다란 표(예: 데이터베이스, 스프레드시트, 비즈니스 인텔리전스 프로그램 등)의 데이터를 요약하는 통계표이다. 이 요약에는 합계, 평균, 기타 통계가 포함될 수 있으며 피벗 테이블이 이들을 함께 의미있는 방식으로 묶어준다.


## GroupBy 메카닉


다수의 인기 있는 R 프로그래밍 패키지의 저자인 해들리 위캠<sup>Hadley Wickham</sup>은 <strong>분리-적용-결합</strong><sup>split-apply-combine</sup>이라는 그룹 연산에 대한 새로운 용어를 만들었는데, 이 말이 그룹 연산에 대한 훌륭한 설명이라고 생각한다. 그룹 연산의 첫 번째 단계에서는 시리즈, 데이터프레임 같은 판다스 객체나 아니면 다른 객체에 들어 있는 데이터를 하나 이상의 <strong>키</strong>를 기준으로 <strong>분리</strong>한다. 객체는 하나의 축을 기준으로 분리하는데, 예를 들어 데이터프레임은 로우(axis=0)로 분리하거나 칼럼(axis=1)으로 분리할 수 있다. 분리하고 나서는 함수를 각 그룹에 <strong>적용</strong>시켜 새로운 값을 얻어낸다. 마지막으로 함수를 적용한 결과를 하나의 객체로 <strong>결합</strong>한다. 결과를 담는 객체는 보통 데이터에 어떤 연산을 했는지에 따라 결정된다. 간단한 그룹 연산의 예시를 살펴보자.

<div style="text-align : center;">
       <img src="../../images/groupby_image.png">
</div><br>

각 3단계의 과정을 정리하면<br><br>

<strong>
    1단계) 분할(split): 데이터를 특정 조건에 의해 분할<br>
    2단계) 적용(apply): 데이터를 집계, 변환, 필터링하는데 필요한 메서드 적용<br>
    3단계) 결합(combine): 2단계의 처리 결과를 하나로 결합
</strong><br><br>

각 그룹의 색인은 다음과 같이 다양한 형태가 될 수 있으며, 모두 같은 타입일 필요도 없다.

- 그룹으로 묶을 축과 동일한 길이의 리스트나 배열

- 데이터프레임의 칼럼 이름을 지칭하는 값

- 그룹으로 묶을 값과 그룹 이름에 대응하는 사전이나 시리즈 객체

- 축 색인 혹은 색인 내의 개별 이름에 대해 실행되는 함수



앞 목록에서 마지막 세 방법은 객체를 나눌 때 사용할 배열을 생성하기 위한 방법이라는 것을 기억하자. 아직까지 확실한 개념이 잡히지 않는다고 너무 걱정하지 말자. 앞으로 차차 이 방법들을 사용하는 다양한 예제를 살펴보게 될 것이다. 먼저 다음과 같이 데이터프레임으로 표현되는 간단한 표 형식의 데이터가 있다고 하자.<br>



```python
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
```


```python
df = pd.DataFrame({'key1': ['a', 'a', 'b', 'b', 'a'],
                   'key2': ['one', 'two', 'one', 'two', 'one'],
                   'data1': np.random.randn(5),
                   'data2': np.random.randn(5)})

df
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key1</th>
      <th>key2</th>
      <th>data1</th>
      <th>data2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>a</td>
      <td>one</td>
      <td>1.897363</td>
      <td>-0.267253</td>
    </tr>
    <tr>
      <th>1</th>
      <td>a</td>
      <td>two</td>
      <td>0.414906</td>
      <td>0.784932</td>
    </tr>
    <tr>
      <th>2</th>
      <td>b</td>
      <td>one</td>
      <td>0.178935</td>
      <td>-1.864723</td>
    </tr>
    <tr>
      <th>3</th>
      <td>b</td>
      <td>two</td>
      <td>-0.958280</td>
      <td>0.692412</td>
    </tr>
    <tr>
      <th>4</th>
      <td>a</td>
      <td>one</td>
      <td>1.233095</td>
      <td>0.793427</td>
    </tr>
  </tbody>
</table>
</div>


데이터프레임의 `groupby()`는 RDBMS SQL의 groupby 키워드와 유사하면서도 다른 면이 있기 때문에 주의가 필요하다. SQL, 판다스 모두 `groupby()`를 분석 작업에 매우 많이 활용한다. <u>데이터프레임의 `groupby()` 사용 시 입력 파라미터 by에 칼럼을 입력하면 대상 칼럼으로 groupby된다.</u> 데이터프레임에 `groupby()`를 호출하면 DataFrameGroupBy라는 또 다른 형태의 데이터프레임을 반환한다. data1에 대해 `groupby()` 메서드를 호출하고 key1 칼럼을 넘겨서 이 데이터를 key1으로 묶고 각 그룹에서 data1의 평균을 구해보자.<br>



```python
grouped = df['data1'].groupby(df['key1'])

grouped
```

<pre>
<pandas.core.groupby.generic.SeriesGroupBy object at 0x000002D5DAB5BA00>
</pre>
이 grouped 변수는 GroupBy 객체다. df['key1']로 참조되는 중간값에 대한 것 외에는 아무것도 계산되지 않은 객체다. SQL의 groupby와 다르게, 데이터프레임에 `groupby()`를 호출해 반환된 결과에 aggregation 함수를 호출하면 `groupby()` 대상 칼럼을 제외한 모든 칼럼에 해당 aggregation 함수를 적용한다. 이 객체는 그룹 연산을 위해 필요한 모든 정보를 가지고 있어서 각 그룹에 어떤 연산을 적용할 수 있게 해준다. 예를 들어 그룹별 평균을 구하려면 GroupBy 객체의 `mean()` 메서드를 사용하면 된다.<br>



```python
grouped.mean()
```

<pre>
key1
a    1.181788
b   -0.389673
Name: data1, dtype: float64
</pre>
`.mean()` 메서드를 호출했을 때의 자세한 내용은 나중에 설명하기로 하고, 이 예제에서 중요한 점은 데이터(시리즈 객체)가 그룹 색인에 따라 수집되고 key1 칼럼에 있는 유일한 값으로 색인되는 새로운 시리즈 객체가 생성된다는 것이다. 새롭게 생성된 시리즈 객체의 색인은 'key1'인데, 그 이유는 전달된 인자가 데이터프레임 칼럼인 df['key1'] 이기 때문이다.<br><br>

만약 여러 개의 배열을 리스트로 넘겼다면 조금 다른 결과를 얻었을 것이다. 여러 개의 기준 값을 사용하기 때문에 반환되는 그룹 객체의 인덱스는 다중 구조를 갖는다.<br>



```python
means = df['data1'].groupby([df['key1'], df['key2']]).mean()

means
```

<pre>
key1  key2
a     one     1.565229
      two     0.414906
b     one     0.178935
      two    -0.958280
Name: data1, dtype: float64
</pre>
여기서는 데이터를 두 개의 색인으로 묶었고, 그 결과 계층적 색인을 가지는 시리즈를 얻을 수 있었다.<br>



```python
means.unstack()    # default: level=-1
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>key2</th>
      <th>one</th>
      <th>two</th>
    </tr>
    <tr>
      <th>key1</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>1.565229</td>
      <td>0.414906</td>
    </tr>
    <tr>
      <th>b</th>
      <td>0.178935</td>
      <td>-0.958280</td>
    </tr>
  </tbody>
</table>
</div>


이 예제에서는 그룹의 색인 모두 시리즈 객체인데, 길이만 같다면 어떤 배열이라도 상관없다.<br>



```python
states = np.array(['Ohio', 'California', 'California', 'Ohio', 'Ohio'])

years = np.array([2005, 2005, 2006, 2005, 2006])

df['data1'].groupby([states, years]).mean()
```

<pre>
California  2005    0.414906
            2006    0.178935
Ohio        2005    0.469541
            2006    1.233095
Name: data1, dtype: float64
</pre>
한 그룹으로 묶을 정보는 주로 같은 데이터프레임 안에서 찾게 되는데, 이 경우 칼럼 이름(문자열, 숫자 혹은 다른 파이썬 객체)을 넘겨서 그룹의 색인으로 사용할 수 있다.<br>



```python
df.groupby('key1').mean()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>data1</th>
      <th>data2</th>
    </tr>
    <tr>
      <th>key1</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>1.181788</td>
      <td>0.437035</td>
    </tr>
    <tr>
      <th>b</th>
      <td>-0.389673</td>
      <td>-0.586156</td>
    </tr>
  </tbody>
</table>
</div>



```python
df.groupby(['key1', 'key2']).mean()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>data1</th>
      <th>data2</th>
    </tr>
    <tr>
      <th>key1</th>
      <th>key2</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">a</th>
      <th>one</th>
      <td>1.565229</td>
      <td>0.263087</td>
    </tr>
    <tr>
      <th>two</th>
      <td>0.414906</td>
      <td>0.784932</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>one</th>
      <td>0.178935</td>
      <td>-1.864723</td>
    </tr>
    <tr>
      <th>two</th>
      <td>-0.958280</td>
      <td>0.692412</td>
    </tr>
  </tbody>
</table>
</div>


위에서 `df.groupby('key1').mean()` 코드를 보면 key2 칼럼이 결과에서 빠져 있는 것을 확인할 수 있다. 그 이유는 df['key2']는 숫자 데이터가 아니기 때문인데, 이런 칼럼은 <strong>성가신 칼럼</strong><sup>nuisance column</sup>이라고 부르며 결과에서 제외시킨다. 기본적으로 모든 숫자 칼럼이 수집되지만 곧 살펴보듯이 원하는 부분만 따로 걸러내는 것도 가능하다.<br><br>

`groupby()`를 쓰는 목적과 별개로, 일반적으로 유용한 GroupBy 메서드는 그룹의 크기를 담고 있는 시리즈를 반환하는 `size()` 메서드다.<br>



```python
df.groupby(['key1', 'key2']).size()
```

<pre>
key1  key2
a     one     2
      two     1
b     one     1
      two     1
dtype: int64
</pre>
그룹 색인에서 누락된 값은 결과에서 제외된다는 것을 기억하자.<br><br>


### 그룹 간 순회하기

GroupBy 객체는 iteration을 지원하는데 그룹 이름과 그에 따른 데이터 묶음을 튜플로 반환한다. 다음 예제를 살펴보자.<br>



```python
for key, group in df.groupby('key1'):
    print('* key :', key)
    print('* number :', len(group))
    print(group)
    print('\n')
```

<pre>
* key : a
* number : 3
  key1 key2     data1     data2
0    a  one  1.897363 -0.267253
1    a  two  0.414906  0.784932
4    a  one  1.233095  0.793427


* key : b
* number : 2
  key1 key2     data1     data2
2    b  one  0.178935 -1.864723
3    b  two -0.958280  0.692412


</pre>
이처럼 색인이 여럿 존재하는 경우 튜플의 첫 번째 원소가 색인값이 된다.<br>



```python
for (key1, key2), group in df.groupby(['key1', 'key2']):
    print('* key :', (key1, key2))
    print('* number :', len(group))
    print(group)
    print('\n')
```

<pre>
* key : ('a', 'one')
* number : 2
  key1 key2     data1     data2
0    a  one  1.897363 -0.267253
4    a  one  1.233095  0.793427


* key : ('a', 'two')
* number : 1
  key1 key2     data1     data2
1    a  two  0.414906  0.784932


* key : ('b', 'one')
* number : 1
  key1 key2     data1     data2
2    b  one  0.178935 -1.864723


* key : ('b', 'two')
* number : 1
  key1 key2    data1     data2
3    b  two -0.95828  0.692412


</pre>
당연히 이 안에서 원하는 데이터만 골라낼 수 있다. 한 줄이면 그룹별 데이터를 사전형으로 쉽게 바꿔서 유용하게 사용할 수 있다.<br>



```python
pieces = dict(list(df.groupby('key1')))

display(pieces)
display(pieces['b'])
```

<pre>
{'a':   key1 key2     data1     data2
 0    a  one  1.897363 -0.267253
 1    a  two  0.414906  0.784932
 4    a  one  1.233095  0.793427,
 'b':   key1 key2     data1     data2
 2    b  one  0.178935 -1.864723
 3    b  two -0.958280  0.692412}
</pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key1</th>
      <th>key2</th>
      <th>data1</th>
      <th>data2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2</th>
      <td>b</td>
      <td>one</td>
      <td>0.178935</td>
      <td>-1.864723</td>
    </tr>
    <tr>
      <th>3</th>
      <td>b</td>
      <td>two</td>
      <td>-0.958280</td>
      <td>0.692412</td>
    </tr>
  </tbody>
</table>
</div>


`groupby()` 메서드는 기본적으로 axis=0에 대해 그룹을 만드는데, 다른 축으로 그룹을 만드는 것도 가능하다. 예를 들어 예제로 살펴본 df의 칼럼을 dtype에 따라 그룹으로 묶을 수도 있다.<br>



```python
df.dtypes
```

<pre>
key1      object
key2      object
data1    float64
data2    float64
dtype: object
</pre>

```python
grouped = df.groupby(df.dtypes, axis=1)

for dtype, group in grouped:
    print('* dtype: ', dtype)
    print(group)
    print('\n')
```

<pre>
* dtype:  float64
      data1     data2
0  1.897363 -0.267253
1  0.414906  0.784932
2  0.178935 -1.864723
3 -0.958280  0.692412
4  1.233095  0.793427


* dtype:  object
  key1 key2
0    a  one
1    a  two
2    b  one
3    b  two
4    a  one


</pre>
### 칼럼이나 칼럼의 일부만 선택하기

데이터프레임에서 만든 GroupBy 객체를 칼럼 이름이나 칼럼 이름이 담긴 배열로 색인하면 수집을 위해 해당 칼럼을 선택하게 된다.<br>



```python
df.groupby('key1')['data1']
df.groupby('key1')[['data2']]
```

<pre>
<pandas.core.groupby.generic.DataFrameGroupBy object at 0x000002D5DABE10A0>
</pre>
위 코드는 아래 코드에 대한 syntactic sugar[^2]로 같은 결과를 반환한다.<br>

[^2]: 사람이 이해하기 쉽고 표현하기 쉽게 컴퓨터 언어를 디자인해 놓은 문맥



```python
df['data1'].groupby(df['key1'])
df[['data2']].groupby(df['key1'])
```

<pre>
<pandas.core.groupby.generic.DataFrameGroupBy object at 0x000002D5DABE1550>
</pre>
특히 대용량 데이터를 다룰 경우 소수의 칼럼만 집계하고 싶을 때가 종종 있는데, 예를 들어 위 데이터에서 data2 칼럼에 대해서만 평균을 구하고 결과를 데이터프레임으로 받고 싶다면 아래와 같이 작성한다.<br>



```python
# syntactic sugar: df[['data2']].groupby([df['key1'], df['key2']]).mean()
df.groupby(['key1', 'key2'])[['data2']].mean()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>data2</th>
    </tr>
    <tr>
      <th>key1</th>
      <th>key2</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">a</th>
      <th>one</th>
      <td>0.263087</td>
    </tr>
    <tr>
      <th>two</th>
      <td>0.784932</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>one</th>
      <td>-1.864723</td>
    </tr>
    <tr>
      <th>two</th>
      <td>0.692412</td>
    </tr>
  </tbody>
</table>
</div>


색인으로 얻은 객체는 `groupby()` 메서드에 리스트나 배열을 넘겼을 경우 DataFrameGroupBy 객체가 되고, 단일 값으로 하나의 칼럼 이름만 넘겼을 경우 SeriesGroupBy 객체가 된다.<br>



```python
s_grouped = df.groupby(['key1', 'key2'])['data2']

display(s_grouped)

display(s_grouped.mean())
```

<pre>
<pandas.core.groupby.generic.SeriesGroupBy object at 0x000002D5DABFAAC0>
</pre>
<pre>
key1  key2
a     one     0.263087
      two     0.784932
b     one    -1.864723
      two     0.692412
Name: data2, dtype: float64
</pre>
### 사전과 Series에서 그룹핑하기

그룹 정보는 배열이 아닌 형태로 존재하기도 한다. 다른 데이터프레임 예제를 살펴보자.<br>



```python
people = pd.DataFrame(np.random.randn(5, 5),
                      columns=['a', 'b', 'c', 'd', 'e'],
                      index=['Joe', 'Steve', 'Wes', 'Jim', 'Travis'])

people.iloc[2:3, [1, 2]] = np.nan    # nan 값을 추가하자.

people
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Joe</th>
      <td>0.211223</td>
      <td>-1.669961</td>
      <td>-0.881966</td>
      <td>-1.957147</td>
      <td>0.599661</td>
    </tr>
    <tr>
      <th>Steve</th>
      <td>-0.640144</td>
      <td>-0.416552</td>
      <td>-0.102563</td>
      <td>0.374840</td>
      <td>0.661327</td>
    </tr>
    <tr>
      <th>Wes</th>
      <td>0.150227</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>0.171901</td>
      <td>-0.900277</td>
    </tr>
    <tr>
      <th>Jim</th>
      <td>1.053917</td>
      <td>0.805950</td>
      <td>-0.795517</td>
      <td>0.101326</td>
      <td>1.632543</td>
    </tr>
    <tr>
      <th>Travis</th>
      <td>-0.818808</td>
      <td>-2.066885</td>
      <td>1.222610</td>
      <td>1.210709</td>
      <td>0.848762</td>
    </tr>
  </tbody>
</table>
</div>


이제 각 칼럼을 나타낼 그룹 목록이 있고, 그룹별로 칼럼의 값을 모두 더한다고 해보자.<br>



```python
mapping = {'a': 'red', 'b': 'red', 'c': 'blue',
           'd': 'blue', 'e': 'red', 'f': 'orange'}

mapping
```

<pre>
{'a': 'red', 'b': 'red', 'c': 'blue', 'd': 'blue', 'e': 'red', 'f': 'orange'}
</pre>
이 사전에서 `groupby()` 메서드로 넘길 배열을 뽑아낼 수 있지만 그냥 이 사전을 `groupby()` 메서드로 넘기자(사용하지 않는 그룹 키가 포함되어 있어도 문제없다는 것을 보이기 위해 'f'도 포함시켰다).<br>



```python
by_column = people.groupby(mapping, axis=1)

by_column.sum()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>blue</th>
      <th>red</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Joe</th>
      <td>-2.839113</td>
      <td>-0.859076</td>
    </tr>
    <tr>
      <th>Steve</th>
      <td>0.272277</td>
      <td>-0.395369</td>
    </tr>
    <tr>
      <th>Wes</th>
      <td>0.171901</td>
      <td>-0.750049</td>
    </tr>
    <tr>
      <th>Jim</th>
      <td>-0.694192</td>
      <td>3.492410</td>
    </tr>
    <tr>
      <th>Travis</th>
      <td>2.433319</td>
      <td>-2.036931</td>
    </tr>
  </tbody>
</table>
</div>


시리즈에 대해서도 같은 기능을 수행할 수 있는데, 고정된 크기의 맵이라고 보면 된다. 여기서 말하는 고정된 크기란 시리즈 칸을 생각하면 될 것 같다.<br>



```python
map_series = pd.Series(mapping)

map_series
```

<pre>
a       red
b       red
c      blue
d      blue
e       red
f    orange
dtype: object
</pre>

```python
people.groupby(map_series, axis=1).count()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>blue</th>
      <th>red</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Joe</th>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>Steve</th>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>Wes</th>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>Jim</th>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>Travis</th>
      <td>2</td>
      <td>3</td>
    </tr>
  </tbody>
</table>
</div>


Wes 행의 데이터가 다른 이유는 nan 값 때문이다. aggregation 함수는 nan 값을 자동으로 제외하고 연산을 한다.<br>


### 함수로 그룹핑하기

파이썬 함수를 사용하는 것은 사전이나 시리즈를 사용해서 그룹을 매핑하는 것보다 좀 더 일반적인 방법이다. 그룹 색인을 넘긴 함수는 색인값 하나마다 한 번씩 호출되며, 반환값이 그 그룹의 이름으로 사용된다. 좀 더 구체적으로 말하면 좀 전에 살펴본 예제에서 people 데이터프레임은 사람의 이름을 색인값으로 사용했다. 만약 이름의 길이별로 그룹을 묶고 싶다면 이름의 길이가 담긴 배열을 만들어 넘기는 대신 `len()` 함수를 넘기면 된다.<br>



```python
people.groupby(len).sum()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>3</th>
      <td>1.415368</td>
      <td>-0.864011</td>
      <td>-1.677483</td>
      <td>-1.683921</td>
      <td>1.331927</td>
    </tr>
    <tr>
      <th>5</th>
      <td>-0.640144</td>
      <td>-0.416552</td>
      <td>-0.102563</td>
      <td>0.374840</td>
      <td>0.661327</td>
    </tr>
    <tr>
      <th>6</th>
      <td>-0.818808</td>
      <td>-2.066885</td>
      <td>1.222610</td>
      <td>1.210709</td>
      <td>0.848762</td>
    </tr>
  </tbody>
</table>
</div>


내부적으로는 모두 배열로 변환되므로 함수를 배열, 사전 또는 시리즈와 섞어 쓰더라도 전혀 문제가 되지 않는다.<br>



```python
key_list = ['one', 'one', 'one', 'two', 'two']

people.groupby([len, key_list]).min()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">3</th>
      <th>one</th>
      <td>0.150227</td>
      <td>-1.669961</td>
      <td>-0.881966</td>
      <td>-1.957147</td>
      <td>-0.900277</td>
    </tr>
    <tr>
      <th>two</th>
      <td>1.053917</td>
      <td>0.805950</td>
      <td>-0.795517</td>
      <td>0.101326</td>
      <td>1.632543</td>
    </tr>
    <tr>
      <th>5</th>
      <th>one</th>
      <td>-0.640144</td>
      <td>-0.416552</td>
      <td>-0.102563</td>
      <td>0.374840</td>
      <td>0.661327</td>
    </tr>
    <tr>
      <th>6</th>
      <th>two</th>
      <td>-0.818808</td>
      <td>-2.066885</td>
      <td>1.222610</td>
      <td>1.210709</td>
      <td>0.848762</td>
    </tr>
  </tbody>
</table>
</div>


### 색인 단계로 그룹핑하기

계층적으로 색인된 데이터는 축 색인의 단계 중 하나를 사용해서 편리하게 집계할 수 있는 기능을 제공한다. 다음 예제를 보자.<br>



```python
columns = pd.MultiIndex.from_arrays([['US', 'US', 'US', 'JP', 'JP'],
                                     [1, 3, 5, 1, 3]],
                                    names=['cty', 'tenor'])

columns
```

<pre>
MultiIndex([('US', 1),
            ('US', 3),
            ('US', 5),
            ('JP', 1),
            ('JP', 3)],
           names=['cty', 'tenor'])
</pre>

```python
hier_df = pd.DataFrame(np.random.randn(4, 5), columns=columns)

hier_df
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th>cty</th>
      <th colspan="3" halign="left">US</th>
      <th colspan="2" halign="left">JP</th>
    </tr>
    <tr>
      <th>tenor</th>
      <th>1</th>
      <th>3</th>
      <th>5</th>
      <th>1</th>
      <th>3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>-1.538885</td>
      <td>-0.088384</td>
      <td>0.093003</td>
      <td>-1.025512</td>
      <td>-0.181741</td>
    </tr>
    <tr>
      <th>1</th>
      <td>-0.649020</td>
      <td>1.003128</td>
      <td>0.330653</td>
      <td>-1.825196</td>
      <td>-1.139156</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-0.463565</td>
      <td>-1.247414</td>
      <td>1.180932</td>
      <td>-1.117207</td>
      <td>1.312400</td>
    </tr>
    <tr>
      <th>3</th>
      <td>-0.187331</td>
      <td>1.577278</td>
      <td>0.380216</td>
      <td>1.717873</td>
      <td>-1.178039</td>
    </tr>
  </tbody>
</table>
</div>


이 기능을 사용하려면 level 예약어를 사용해서 레벨 번호나 이름을 넘기면 된다.<br>



```python
hier_df.groupby(level='cty', axis=1).count()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>cty</th>
      <th>JP</th>
      <th>US</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2</td>
      <td>3</td>
    </tr>
  </tbody>
</table>
</div>


## 데이터 집계

데이터 집계(aggreagation)는 배열로부터 스칼라값을 만들어내는 모든 데이터 변환 작업을 말한다. 위 예제에서는 `mean()`, `count()`, `min()`, `sum()`을 이용해서 스칼라값을 구했다. GroupBy 객체에 대해 `mean()`을 수행하면 어떤 일이 생기는지 궁금할 것이다. 밑의 표에 있는 것과 같이 일반적인 데이터 집계는 데이터 묶음에 대한 준비된 통계를 계산해내는 최적화된 구현을 가지고 있다. 하지만 이 메서드만 사용해야 하는 건 아니다.<br><br>



<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-ehbx{background-color:#9698ed;border-color:inherit;font-weight:bold;text-align:left;vertical-align:top}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-ehbx">함수</th>
    <th class="tg-ehbx">설명</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0pky">count</td>
    <td class="tg-0pky">그룹에서 NA가 아닌 값의 수를 반환한다.</td>
  </tr>
  <tr>
    <td class="tg-0pky">sum</td>
    <td class="tg-0pky">NA가 아닌 값들의 합을 구한다.</td>
  </tr>
  <tr>
    <td class="tg-0pky">mean</td>
    <td class="tg-0pky">NA가 아닌 값들의 평균을 구한다.</td>
  </tr>
  <tr>
    <td class="tg-0pky">median</td>
    <td class="tg-0pky">NA가 아닌 값들의 산술 중간값을 구한다.</td>
  </tr>
  <tr>
    <td class="tg-0pky">std, var</td>
    <td class="tg-0pky">편향되지 않은(n - 1을 분모로 하는) 표준편차와 분산</td>
  </tr>
  <tr>
    <td class="tg-0pky">min, max</td>
    <td class="tg-0pky">NA가 아닌 값들 중 최솟값과 최댓값</td>
  </tr>
  <tr>
    <td class="tg-0pky">prod</td>
    <td class="tg-0pky">NA가 아닌 값들의 곱</td>
  </tr>
  <tr>
    <td class="tg-0lax">first, last</td>
    <td class="tg-0lax">NA가 아닌 값들 중 첫째 값과 마지막 값</td>
  </tr>
</tbody>
</table>

<br><br>

직접 고안한 집계함수를 사용하고 추가적으로 그룹 객체에 이미 정의된 메서드를 연결해서 사용하는 것도 가능하다. 예를 들어 <code>quantile()</code> 메서드가 시리즈나 데이터프레임의 칼럼의 변위치를 계산한다는 점을 생각해보자.<br><br>

<code>quantile()</code> 메서드는 GroupBy만을 위해 구현된 건 아니지만 시리즈 메서드이기 때문에 여기서 사용할 수 있다. 내부적으로 GroupBy는 시리즈를 효과적으로 잘게 자르고, 각 조각에 대해 piece.quantile(0.9)를 호출한다. 그리고 이 결과들을 모두 하나의 객체로 합쳐서 반환한다. 이는 위에서 보았던 <strong>분할-적용-결합</strong>의 원리이다.<br>



```python
df
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key1</th>
      <th>key2</th>
      <th>data1</th>
      <th>data2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>a</td>
      <td>one</td>
      <td>1.897363</td>
      <td>-0.267253</td>
    </tr>
    <tr>
      <th>1</th>
      <td>a</td>
      <td>two</td>
      <td>0.414906</td>
      <td>0.784932</td>
    </tr>
    <tr>
      <th>2</th>
      <td>b</td>
      <td>one</td>
      <td>0.178935</td>
      <td>-1.864723</td>
    </tr>
    <tr>
      <th>3</th>
      <td>b</td>
      <td>two</td>
      <td>-0.958280</td>
      <td>0.692412</td>
    </tr>
    <tr>
      <th>4</th>
      <td>a</td>
      <td>one</td>
      <td>1.233095</td>
      <td>0.793427</td>
    </tr>
  </tbody>
</table>
</div>



```python
grouped = df.groupby('key1')

grouped['data1'].quantile(0.9)
```

<pre>
key1
a    1.764509
b    0.065213
Name: data1, dtype: float64
</pre>
자신만의 데이터 집계함수를 사용하려면 배열의 `aggregate()`나 `agg()` 메서드에 해당 함수를 넘기면 된다.<br>



```python
def peak_to_peak(arr):
    return arr.max() - arr.min()

grouped.agg(peak_to_peak)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>data1</th>
      <th>data2</th>
    </tr>
    <tr>
      <th>key1</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>1.482456</td>
      <td>1.060680</td>
    </tr>
    <tr>
      <th>b</th>
      <td>1.137215</td>
      <td>2.557135</td>
    </tr>
  </tbody>
</table>
</div>


`describe()` 같은 메서드는 데이터를 집계하지 않는데도 잘 작동함을 확인할 수 있다.<br>



```python
grouped.describe()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th colspan="8" halign="left">data1</th>
      <th colspan="8" halign="left">data2</th>
    </tr>
    <tr>
      <th></th>
      <th>count</th>
      <th>mean</th>
      <th>std</th>
      <th>min</th>
      <th>25%</th>
      <th>50%</th>
      <th>75%</th>
      <th>max</th>
      <th>count</th>
      <th>mean</th>
      <th>std</th>
      <th>min</th>
      <th>25%</th>
      <th>50%</th>
      <th>75%</th>
      <th>max</th>
    </tr>
    <tr>
      <th>key1</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>3.0</td>
      <td>1.181788</td>
      <td>0.742559</td>
      <td>0.414906</td>
      <td>0.824001</td>
      <td>1.233095</td>
      <td>1.565229</td>
      <td>1.897363</td>
      <td>3.0</td>
      <td>0.437035</td>
      <td>0.609946</td>
      <td>-0.267253</td>
      <td>0.25884</td>
      <td>0.784932</td>
      <td>0.789180</td>
      <td>0.793427</td>
    </tr>
    <tr>
      <th>b</th>
      <td>2.0</td>
      <td>-0.389673</td>
      <td>0.804132</td>
      <td>-0.958280</td>
      <td>-0.673976</td>
      <td>-0.389673</td>
      <td>-0.105369</td>
      <td>0.178935</td>
      <td>2.0</td>
      <td>-0.586156</td>
      <td>1.808168</td>
      <td>-1.864723</td>
      <td>-1.22544</td>
      <td>-0.586156</td>
      <td>0.053128</td>
      <td>0.692412</td>
    </tr>
  </tbody>
</table>
</div>


<strong>NOTE_</strong>사용자 정의 집계함수는 일반적으로 위의 표에 있는 함수에 비해 무척 느리게 동작하는데, 그 이유는 중간 데이터를 생성하는 과정에서 함수 호출이나 데이터 정렬 같은 오버헤드가 발생하기 때문이다.<br><br>


### 칼럼에 여러 가지 함수 적용하기

앞서 살펴본 팁 데이터로 다시 돌아가자. 여기서는 `read_csv()` 함수로 데이터를 불러온 다음, 팁의 비율을 담기 위한 칼럼인 tip_pct를 추가했다.<br>



```python
tips = pd.read_csv('examples/tips.csv')

# total_bill 에서 팁의 비율을 추가하지.
tips['tip_pct'] = tips['tip'] / tips['total_bill']

tips.head()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>total_bill</th>
      <th>tip</th>
      <th>smoker</th>
      <th>day</th>
      <th>time</th>
      <th>size</th>
      <th>tip_pct</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>16.99</td>
      <td>1.01</td>
      <td>No</td>
      <td>Sun</td>
      <td>Dinner</td>
      <td>2</td>
      <td>0.059447</td>
    </tr>
    <tr>
      <th>1</th>
      <td>10.34</td>
      <td>1.66</td>
      <td>No</td>
      <td>Sun</td>
      <td>Dinner</td>
      <td>3</td>
      <td>0.160542</td>
    </tr>
    <tr>
      <th>2</th>
      <td>21.01</td>
      <td>3.50</td>
      <td>No</td>
      <td>Sun</td>
      <td>Dinner</td>
      <td>3</td>
      <td>0.166587</td>
    </tr>
    <tr>
      <th>3</th>
      <td>23.68</td>
      <td>3.31</td>
      <td>No</td>
      <td>Sun</td>
      <td>Dinner</td>
      <td>2</td>
      <td>0.139780</td>
    </tr>
    <tr>
      <th>4</th>
      <td>24.59</td>
      <td>3.61</td>
      <td>No</td>
      <td>Sun</td>
      <td>Dinner</td>
      <td>4</td>
      <td>0.146808</td>
    </tr>
  </tbody>
</table>
</div>


이미 살펴봤듯이 시리즈나 데이터프레임의 모든 칼럼을 집계하는 것은 `mean()`이나 `std()` 같은 메서드를 호출하거나 원하는 함수에 `aggregate()`를 사용하는 것이다. 하지만 칼럼에 따라 다른 함수를 사용해서 집계를 수행하거나 여러 개의 함수를 한 번에 적용하길 원한다면 이를 쉽고 간단하게 수행할 수 있다. 앞으로 몇몇 예제를 통해 이를 자세히 알아볼 텐데, 먼저 tips를 day와 smoker별로 묶어보자.<br>



```python
grouped = tips.groupby(['day', 'smoker'])
```

위 표의 내용과 같은 기술 통계에서는 함수 이름을 문자열로 넘기면 된다.<br>



```python
grouped_pct = grouped['tip_pct']

grouped_pct.agg('mean')
```

<pre>
day   smoker
Fri   No        0.151650
      Yes       0.174783
Sat   No        0.158048
      Yes       0.147906
Sun   No        0.160113
      Yes       0.187250
Thur  No        0.160298
      Yes       0.163863
Name: tip_pct, dtype: float64
</pre>
만일 함수 목록이나 함수 이름을 넘기면 함수 이름을 칼럼 이름으로 하는 데이터프레임을 얻게 된다.<br>



```python
grouped_pct.agg(['mean', 'std', peak_to_peak])
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>mean</th>
      <th>std</th>
      <th>peak_to_peak</th>
    </tr>
    <tr>
      <th>day</th>
      <th>smoker</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">Fri</th>
      <th>No</th>
      <td>0.151650</td>
      <td>0.028123</td>
      <td>0.067349</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>0.174783</td>
      <td>0.051293</td>
      <td>0.159925</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Sat</th>
      <th>No</th>
      <td>0.158048</td>
      <td>0.039767</td>
      <td>0.235193</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>0.147906</td>
      <td>0.061375</td>
      <td>0.290095</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Sun</th>
      <th>No</th>
      <td>0.160113</td>
      <td>0.042347</td>
      <td>0.193226</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>0.187250</td>
      <td>0.154134</td>
      <td>0.644685</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Thur</th>
      <th>No</th>
      <td>0.160298</td>
      <td>0.038774</td>
      <td>0.193350</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>0.163863</td>
      <td>0.039389</td>
      <td>0.151240</td>
    </tr>
  </tbody>
</table>
</div>


여기서는 데이터 그룹에 대해 독립적으로 적용하기 위해 `agg()`에 집계함수들의 리스트를 넘겼다.<br><br>

GroupBy 객체에서 자동으로 지정하는 칼럼 이름을 그대로 쓰지 않아도 된다. lambda 함수는 이름(함수 이름은 \_\_name\_\_ 속성으로 확인 가능하다)이 '\<lambda\>'인데, 이를 그대로 쓸 경우 알아보기 힘들어진다. 이때 이름과 함수가 담긴 (name, function) 튜플의 리스트를 넘기면 각 튜플에서 첫 번째 원소가 데이터프레임에서 칼럼 이름으로 사용된다(2개의 튜플을 가지는 리스트가 순서대로 매핑된다).<br>



```python
grouped_pct.agg([('foo', 'mean'), ('bar', np.std)])
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>foo</th>
      <th>bar</th>
    </tr>
    <tr>
      <th>day</th>
      <th>smoker</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">Fri</th>
      <th>No</th>
      <td>0.151650</td>
      <td>0.028123</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>0.174783</td>
      <td>0.051293</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Sat</th>
      <th>No</th>
      <td>0.158048</td>
      <td>0.039767</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>0.147906</td>
      <td>0.061375</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Sun</th>
      <th>No</th>
      <td>0.160113</td>
      <td>0.042347</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>0.187250</td>
      <td>0.154134</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Thur</th>
      <th>No</th>
      <td>0.160298</td>
      <td>0.038774</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>0.163863</td>
      <td>0.039389</td>
    </tr>
  </tbody>
</table>
</div>


또는 `grouped.agg()`에 mean_pct = 'mean'처럼 요약값을 할당할 변수명과 '='를 입력한 다음, 값을 요약하는데 사용할 변수와 함수를 괄호 안에 나열하면 된다.<br>



```python
grouped.agg(mean_pct=('tip_pct', 'mean'))
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>mean_pct</th>
    </tr>
    <tr>
      <th>day</th>
      <th>smoker</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">Fri</th>
      <th>No</th>
      <td>0.151650</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>0.174783</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Sat</th>
      <th>No</th>
      <td>0.158048</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>0.147906</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Sun</th>
      <th>No</th>
      <td>0.160113</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>0.187250</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Thur</th>
      <th>No</th>
      <td>0.160298</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>0.163863</td>
    </tr>
  </tbody>
</table>
</div>


데이터프레임은 칼럼마다 다른 함수를 적용하거나 여러 개의 함수를 모든 칼럼에 적용할 수 있다. tip_pct와 total_bill 칼럼에 대해 동일한 세 가지 통계를 계산한다고 가정하자.<br>



```python
functions = ['count', 'mean', 'max']

result = grouped['tip_pct', 'total_bill'].agg(functions)

result
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th colspan="3" halign="left">tip_pct</th>
      <th colspan="3" halign="left">total_bill</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>count</th>
      <th>mean</th>
      <th>max</th>
      <th>count</th>
      <th>mean</th>
      <th>max</th>
    </tr>
    <tr>
      <th>day</th>
      <th>smoker</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">Fri</th>
      <th>No</th>
      <td>4</td>
      <td>0.151650</td>
      <td>0.187735</td>
      <td>4</td>
      <td>18.420000</td>
      <td>22.75</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>15</td>
      <td>0.174783</td>
      <td>0.263480</td>
      <td>15</td>
      <td>16.813333</td>
      <td>40.17</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Sat</th>
      <th>No</th>
      <td>45</td>
      <td>0.158048</td>
      <td>0.291990</td>
      <td>45</td>
      <td>19.661778</td>
      <td>48.33</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>42</td>
      <td>0.147906</td>
      <td>0.325733</td>
      <td>42</td>
      <td>21.276667</td>
      <td>50.81</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Sun</th>
      <th>No</th>
      <td>57</td>
      <td>0.160113</td>
      <td>0.252672</td>
      <td>57</td>
      <td>20.506667</td>
      <td>48.17</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>19</td>
      <td>0.187250</td>
      <td>0.710345</td>
      <td>19</td>
      <td>24.120000</td>
      <td>45.35</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Thur</th>
      <th>No</th>
      <td>45</td>
      <td>0.160298</td>
      <td>0.266312</td>
      <td>45</td>
      <td>17.113111</td>
      <td>41.19</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>17</td>
      <td>0.163863</td>
      <td>0.241255</td>
      <td>17</td>
      <td>19.190588</td>
      <td>43.11</td>
    </tr>
  </tbody>
</table>
</div>


위에서 확인할 수 있듯이 반환된 데이터프레임은 계층적인 칼럼을 가지고 있으며 이는 각 칼럼을 따로 계산한 다음 `concat()` 메서드를 이용해서 keys 인자로 칼럼 이름을 넘겨서 이어붙인 것과 동일하다.<br>



```python
result['tip_pct']
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>count</th>
      <th>mean</th>
      <th>max</th>
    </tr>
    <tr>
      <th>day</th>
      <th>smoker</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">Fri</th>
      <th>No</th>
      <td>4</td>
      <td>0.151650</td>
      <td>0.187735</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>15</td>
      <td>0.174783</td>
      <td>0.263480</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Sat</th>
      <th>No</th>
      <td>45</td>
      <td>0.158048</td>
      <td>0.291990</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>42</td>
      <td>0.147906</td>
      <td>0.325733</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Sun</th>
      <th>No</th>
      <td>57</td>
      <td>0.160113</td>
      <td>0.252672</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>19</td>
      <td>0.187250</td>
      <td>0.710345</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Thur</th>
      <th>No</th>
      <td>45</td>
      <td>0.160298</td>
      <td>0.266312</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>17</td>
      <td>0.163863</td>
      <td>0.241255</td>
    </tr>
  </tbody>
</table>
</div>


위에서처럼 칼럼 이름과 메서드가 담긴 튜플의 리스트를 넘기는 것도 가능하다.[^3]<br>

[^3]: Durchschnitt은 평균, Abweichung은 편차라는 의미의 독일어다.



```python
ftuples = [('Durchschnitt', 'mean'), ('Abweichung', np.var)]

grouped['tip_pct', 'total_bill'].agg(ftuples)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th colspan="2" halign="left">tip_pct</th>
      <th colspan="2" halign="left">total_bill</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Durchschnitt</th>
      <th>Abweichung</th>
      <th>Durchschnitt</th>
      <th>Abweichung</th>
    </tr>
    <tr>
      <th>day</th>
      <th>smoker</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">Fri</th>
      <th>No</th>
      <td>0.151650</td>
      <td>0.000791</td>
      <td>18.420000</td>
      <td>25.596333</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>0.174783</td>
      <td>0.002631</td>
      <td>16.813333</td>
      <td>82.562438</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Sat</th>
      <th>No</th>
      <td>0.158048</td>
      <td>0.001581</td>
      <td>19.661778</td>
      <td>79.908965</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>0.147906</td>
      <td>0.003767</td>
      <td>21.276667</td>
      <td>101.387535</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Sun</th>
      <th>No</th>
      <td>0.160113</td>
      <td>0.001793</td>
      <td>20.506667</td>
      <td>66.099980</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>0.187250</td>
      <td>0.023757</td>
      <td>24.120000</td>
      <td>109.046044</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Thur</th>
      <th>No</th>
      <td>0.160298</td>
      <td>0.001503</td>
      <td>17.113111</td>
      <td>59.625081</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>0.163863</td>
      <td>0.001551</td>
      <td>19.190588</td>
      <td>69.808518</td>
    </tr>
  </tbody>
</table>
</div>


칼럼마다 다른 함수를 적용하고 싶다면 `agg()` 메서드에 칼럼 이름에 대응하는 함수가 들어 있는 사전을 넘기면 된다.<br>



```python
grouped.agg({'tip': np.max, 'size': 'sum'})
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>tip</th>
      <th>size</th>
    </tr>
    <tr>
      <th>day</th>
      <th>smoker</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">Fri</th>
      <th>No</th>
      <td>3.50</td>
      <td>9</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>4.73</td>
      <td>31</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Sat</th>
      <th>No</th>
      <td>9.00</td>
      <td>115</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>10.00</td>
      <td>104</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Sun</th>
      <th>No</th>
      <td>6.00</td>
      <td>167</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>6.50</td>
      <td>49</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Thur</th>
      <th>No</th>
      <td>6.70</td>
      <td>112</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>5.00</td>
      <td>40</td>
    </tr>
  </tbody>
</table>
</div>



```python
grouped.agg({'tip_pct': ['min', 'max', 'mean', 'std'],
             'size': 'sum'})
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th colspan="4" halign="left">tip_pct</th>
      <th>size</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>min</th>
      <th>max</th>
      <th>mean</th>
      <th>std</th>
      <th>sum</th>
    </tr>
    <tr>
      <th>day</th>
      <th>smoker</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">Fri</th>
      <th>No</th>
      <td>0.120385</td>
      <td>0.187735</td>
      <td>0.151650</td>
      <td>0.028123</td>
      <td>9</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>0.103555</td>
      <td>0.263480</td>
      <td>0.174783</td>
      <td>0.051293</td>
      <td>31</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Sat</th>
      <th>No</th>
      <td>0.056797</td>
      <td>0.291990</td>
      <td>0.158048</td>
      <td>0.039767</td>
      <td>115</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>0.035638</td>
      <td>0.325733</td>
      <td>0.147906</td>
      <td>0.061375</td>
      <td>104</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Sun</th>
      <th>No</th>
      <td>0.059447</td>
      <td>0.252672</td>
      <td>0.160113</td>
      <td>0.042347</td>
      <td>167</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>0.065660</td>
      <td>0.710345</td>
      <td>0.187250</td>
      <td>0.154134</td>
      <td>49</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Thur</th>
      <th>No</th>
      <td>0.072961</td>
      <td>0.266312</td>
      <td>0.160298</td>
      <td>0.038774</td>
      <td>112</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>0.090014</td>
      <td>0.241255</td>
      <td>0.163863</td>
      <td>0.039389</td>
      <td>40</td>
    </tr>
  </tbody>
</table>
</div>


단 하나의 칼럼에라도 여러 개의 함수가 적용되었다면 데이터프레임은 계층적인 칼럼을 가지게 된다.<br><br>


### 색인되지 않은 형태로 집계된 데이터 반환하기

지금까지 살펴본 모든 예제에서 집계된 데이터는 유일한 그룹키 조합으로 색인(어떤 경우에는 계층적 색인)되어 반환되었다. 하지만 항상 이런 동작을 기대하는 것은 아니므로 `groupby()` 메서드에 as_index=False를 넘겨서 색인되지 않도록 할 수 있다.<br>



```python
tips.groupby(['day', 'smoker'], as_index=False).mean()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>day</th>
      <th>smoker</th>
      <th>total_bill</th>
      <th>tip</th>
      <th>size</th>
      <th>tip_pct</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Fri</td>
      <td>No</td>
      <td>18.420000</td>
      <td>2.812500</td>
      <td>2.250000</td>
      <td>0.151650</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Fri</td>
      <td>Yes</td>
      <td>16.813333</td>
      <td>2.714000</td>
      <td>2.066667</td>
      <td>0.174783</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Sat</td>
      <td>No</td>
      <td>19.661778</td>
      <td>3.102889</td>
      <td>2.555556</td>
      <td>0.158048</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Sat</td>
      <td>Yes</td>
      <td>21.276667</td>
      <td>2.875476</td>
      <td>2.476190</td>
      <td>0.147906</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Sun</td>
      <td>No</td>
      <td>20.506667</td>
      <td>3.167895</td>
      <td>2.929825</td>
      <td>0.160113</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Sun</td>
      <td>Yes</td>
      <td>24.120000</td>
      <td>3.516842</td>
      <td>2.578947</td>
      <td>0.187250</td>
    </tr>
    <tr>
      <th>6</th>
      <td>Thur</td>
      <td>No</td>
      <td>17.113111</td>
      <td>2.673778</td>
      <td>2.488889</td>
      <td>0.160298</td>
    </tr>
    <tr>
      <th>7</th>
      <td>Thur</td>
      <td>Yes</td>
      <td>19.190588</td>
      <td>3.030000</td>
      <td>2.352941</td>
      <td>0.163863</td>
    </tr>
  </tbody>
</table>
</div>


물론 이렇게 하지 않고 색인된 결과에 대해 `reset_index()` 메서드를 호출해서 같은 결과를 얻을 수 있다. as_index=False 옵션을 사용하면 불필요한 계산을 피할 수 있다.<br><br>


## Transform: 그룹 연산 데이터 변환


앞에서 살펴본 `agg()` 메서드는 각 그룹별 데이터에 연산을 위한 함수를 구분 적용하고, 그룹별로 연산 결과를 집계하여 반환한다. 반면 `transform()` 메서드는 그룹별로 구분하여 각 원소에 함수를 적용하지만 그룹별 집계 대신 각 원소의 본래 행 인덱스와 열 이름을 기준으로 연산 결과를 반환한다. 즉, 그룹 연산의 결과를 원본 데이터프레임과 같은 형태로 변형하여 정리하는 것이다.<br><br>

다음의 예제에서 'age' 열에 포함된 개별 데이터의 z-score를 구하는 과정을 살펴보자. 먼저 앞에서 배운 집계 연산 메서드를 사용하여 개별 그룹의 평균과 표준편차를 계산한다. 그리고 각 그룹에 대해 반복문을 사용하여 z-score를 계산하고, 각 그룹별로 첫 3행의 결과를 출력한다.<br>



```python
# 라이브러리 불러오기
import pandas as pd
import seaborn as sns

# titanic 데이터셋에서 age, sex 등 5개 열을 선택하여 데이터프레임 만들기
titanic = sns.load_dataset('titanic')
df = titanic.loc[:, ['age', 'sex', 'class', 'fare', 'survived']]

# class 열을 기준으로 분할
grouped = df.groupby(['class'])

# 그룹별 age 열의 평균 집계 연산
age_mean = grouped.age.mean()
print(age_mean)
print('\n')

# 그룹별 age 열의 표준편차 집계 연산
age_std = grouped.age.std()
print(age_std)
print('\n')

# 그룹 객체의 age 열을 iteration으로 z-score를 계산하여 출력
for key, group in grouped.age:
    group_zscore = (group - age_mean.loc[key]) / age_std.loc[key]
    print('* origin :', key)
    print(group_zscore.head(3))    # 각 그룹의 첫 3개의 행 출력
    print('\n')
```

<pre>
class
First     38.233441
Second    29.877630
Third     25.140620
Name: age, dtype: float64


class
First     14.802856
Second    14.001077
Third     12.495398
Name: age, dtype: float64


* origin : First
1   -0.015770
3   -0.218434
6    1.065103
Name: age, dtype: float64


* origin : Second
9    -1.134029
15    1.794317
17         NaN
Name: age, dtype: float64


* origin : Third
0   -0.251342
2    0.068776
4    0.789041
Name: age, dtype: float64


</pre>
이번에는 <code>transform()</code> 메서드를 사용하여 'age' 열의 데이터를 z-score로 직접 변환한다. z-score를 계산하는 사용자 함수를 정의하고, <code>transform()</code> 메서드의 인자로 전달한다. 각 그룹별 평균과 표준편차를 이용하여 각 원소의 z-score를 계산하지만, 반환되는 객체는 그룹별로 나누지 않고 원래 행 인덱스 순서로 정렬된다. 이 경우 891명 승객의 데이터가 본래 행 인덱스 순서대로 정렬된다. 위의 계산 결과와 비교하기 위해 각 그룹의 첫 행에 해당하는 1, 9, 0 행을 출력한다.<br>



```python
# z-score를 계산하는 사용자 함수 정의
def z_score(x):
    return (x - x.mean()) / x.std()

# transform() 메서드를 이용하여 age 열의 데이터를 z-score로 변환
age_zscore = grouped.age.transform(z_score)
print(age_zscore.loc[[1, 9, 0]])    # 1, 2, 3 그룹의 각 첫 데이터 확인(변환 결과)
print('\n')
print(len(age_zscore))              # transform 메서드 반환 값의 길이
print('\n')
print(age_zscore.loc[0:9])          # transform 메서드 반환 값 출력(첫 10개)
print('\n')
print(type(age_zscore))             # transform 메서드 반환 객체의 자료형
```

<pre>
1   -0.015770
9   -1.134029
0   -0.251342
Name: age, dtype: float64


891


0   -0.251342
1   -0.015770
2    0.068776
3   -0.218434
4    0.789041
5         NaN
6    1.065103
7   -1.851931
8    0.148805
9   -1.134029
Name: age, dtype: float64


<class 'pandas.core.series.Series'>
</pre>
<br><br>

## Filter: 그룹 객체 필터링


그룹 객체에 <code>filter()</code> 메서드를 적용할 때 조건식을 가진 함수를 전달하면 조건이 참인 그룹만을 남긴다.<br><br>

데이터 개수가 200개 이상인 그룹만을 따로 필터링한다. 'class' 열을 기준으로 구분된 3개의 그룹 중에서 조건을 충족하는 'First'와 'Third'인 그룹의 데이터만 추출된다.<br>



```python
# 데이터 개수가 200개 이상인 그룹만을 필터링하여 데이터프레임으로 반환
grouped_filter = grouped.filter(lambda x: len(x) >= 200)
print(grouped_filter.head())
print('\n')
print(grouped_filter['class'].unique())
print('\n')
print(type(grouped_filter))
```

<pre>
    age     sex  class     fare  survived
0  22.0    male  Third   7.2500         0
1  38.0  female  First  71.2833         1
2  26.0  female  Third   7.9250         1
3  35.0  female  First  53.1000         1
4  35.0    male  Third   8.0500         0


['Third', 'First']
Categories (3, object): ['First', 'Second', 'Third']


<class 'pandas.core.frame.DataFrame'>
</pre>
이번에는 'age' 열의 평균값이 30보다 작은 그룹만을 따로 선택한다. 평균 나이가 30세가 안되는 그룹은 'class' 값이 'Second'와 'Third'인 2등석과 3등석 승객들이다.<br>



```python
# age 열의 평균이 30보다 작은 그룹만을 필터링하여 데이터프레임으로 반환
age_filter = grouped.filter(lambda x: x.age.mean() < 30)
print(age_filter.tail())
print('\n')
print(age_filter['class'].unique())
print('\n')
print(type(age_filter))
```

<pre>
      age     sex   class    fare  survived
884  25.0    male   Third   7.050         0
885  39.0  female   Third  29.125         0
886  27.0    male  Second  13.000         0
888   NaN  female   Third  23.450         0
890  32.0    male   Third   7.750         0


['Third', 'Second']
Categories (3, object): ['First', 'Second', 'Third']


<class 'pandas.core.frame.DataFrame'>
</pre>
<br><br>

## Apply: 그룹 객체에 함수 매핑


<code>apply()</code> 메서드는 판다스 객체의 개별 원소를 특정 함수에 일대일로 매핑한다. 사용자가 원하는 대부분의 연산을 그룹 객체에도 적용할 수 있다.<br><br>

'class' 열을 기준으로 구분한 3개의 그룹에 요약 통계 정보를 나타내는 <code>describe()</code> 메서드를 적용한다. 각 그룹별 데이터의 개수, 평균, 표준편차, 최소값, 최대값 등을 확인할 수 있다.<br>



```python
# 집계: 각 그룹별 요약 통계 정보 집계
agg_grouped = grouped.apply(lambda x: x.describe())
agg_grouped
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>age</th>
      <th>fare</th>
      <th>survived</th>
    </tr>
    <tr>
      <th>class</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="8" valign="top">First</th>
      <th>count</th>
      <td>186.000000</td>
      <td>216.000000</td>
      <td>216.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>38.233441</td>
      <td>84.154687</td>
      <td>0.629630</td>
    </tr>
    <tr>
      <th>std</th>
      <td>14.802856</td>
      <td>78.380373</td>
      <td>0.484026</td>
    </tr>
    <tr>
      <th>min</th>
      <td>0.920000</td>
      <td>0.000000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>27.000000</td>
      <td>30.923950</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>37.000000</td>
      <td>60.287500</td>
      <td>1.000000</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>49.000000</td>
      <td>93.500000</td>
      <td>1.000000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>80.000000</td>
      <td>512.329200</td>
      <td>1.000000</td>
    </tr>
    <tr>
      <th rowspan="8" valign="top">Second</th>
      <th>count</th>
      <td>173.000000</td>
      <td>184.000000</td>
      <td>184.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>29.877630</td>
      <td>20.662183</td>
      <td>0.472826</td>
    </tr>
    <tr>
      <th>std</th>
      <td>14.001077</td>
      <td>13.417399</td>
      <td>0.500623</td>
    </tr>
    <tr>
      <th>min</th>
      <td>0.670000</td>
      <td>0.000000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>23.000000</td>
      <td>13.000000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>29.000000</td>
      <td>14.250000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>36.000000</td>
      <td>26.000000</td>
      <td>1.000000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>70.000000</td>
      <td>73.500000</td>
      <td>1.000000</td>
    </tr>
    <tr>
      <th rowspan="8" valign="top">Third</th>
      <th>count</th>
      <td>355.000000</td>
      <td>491.000000</td>
      <td>491.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>25.140620</td>
      <td>13.675550</td>
      <td>0.242363</td>
    </tr>
    <tr>
      <th>std</th>
      <td>12.495398</td>
      <td>11.778142</td>
      <td>0.428949</td>
    </tr>
    <tr>
      <th>min</th>
      <td>0.420000</td>
      <td>0.000000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>18.000000</td>
      <td>7.750000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>24.000000</td>
      <td>8.050000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>32.000000</td>
      <td>15.500000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>74.000000</td>
      <td>69.550000</td>
      <td>1.000000</td>
    </tr>
  </tbody>
</table>
</div>


z-score를 계산하는 사용자 함수를 사용하여 'age' 열의 데이터를 z-score로 변환한다.<br>



```python
# z-score를 계산하는 사용자 함수 정의
def z_score(x):
    return (x - x.mean()) / x.std()

age_zscore = grouped.age.apply(z_score)    # 기본값 axis=0
age_zscore.head()
```

<pre>
0   -0.251342
1   -0.015770
2    0.068776
3   -0.218434
4    0.789041
Name: age, dtype: float64
</pre>
'age' 열의 평균값이 30보다 작은 즉, 평균나이가 30세 미만인 그룹을 판별한다. 조건이 참인 그룹은 'class' 값이 'Second'와 'Third'인 그룹이다. 반복문을 사용하여 데이터를 출력한다.<br>



```python
# 필터링: age 열의 데이터 평균이 30보다 작은 그룹만을 필터링하여 출력
age_filter = grouped.apply(lambda x: x.age.mean() < 30)
print(age_filter)
print('\n')
for x in age_filter.index:
    if age_filter[x]==True:
        age_filter_df = grouped.get_group(x)
        print(age_filter_df.head())
        print('\n')
```

<pre>
class
First     False
Second     True
Third      True
dtype: bool


     age     sex   class     fare  survived
9   14.0  female  Second  30.0708         1
15  55.0  female  Second  16.0000         1
17   NaN    male  Second  13.0000         1
20  35.0    male  Second  26.0000         0
21  34.0    male  Second  13.0000         1


    age     sex  class     fare  survived
0  22.0    male  Third   7.2500         0
2  26.0  female  Third   7.9250         1
4  35.0    male  Third   8.0500         0
5   NaN    male  Third   8.4583         0
7   2.0    male  Third  21.0750         0


</pre>
위 예제에서 쓰인 <code>get_group()</code> 메서드는 그룹 객체에서 특정 그룹만을 선택할 수 있다. 위에서는 x에 필터링 조건에 해당하는 'class'값인 'Second'와 'Third'가 들어가게 된다.<br><br>


그룹별 상위 5개의 age 값을 골라보자. 우선 특정 칼럼에서 가장 큰 값을 가지는 로우를 선택하는 함수를 바로 작성해보자.<br>



```python
def top(df, n=5, column='age'):
    return df.sort_values(by=column, ascending=False)[:n]

top(df)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>age</th>
      <th>sex</th>
      <th>class</th>
      <th>fare</th>
      <th>survived</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>630</th>
      <td>80.0</td>
      <td>male</td>
      <td>First</td>
      <td>30.0000</td>
      <td>1</td>
    </tr>
    <tr>
      <th>851</th>
      <td>74.0</td>
      <td>male</td>
      <td>Third</td>
      <td>7.7750</td>
      <td>0</td>
    </tr>
    <tr>
      <th>493</th>
      <td>71.0</td>
      <td>male</td>
      <td>First</td>
      <td>49.5042</td>
      <td>0</td>
    </tr>
    <tr>
      <th>96</th>
      <td>71.0</td>
      <td>male</td>
      <td>First</td>
      <td>34.6542</td>
      <td>0</td>
    </tr>
    <tr>
      <th>116</th>
      <td>70.5</td>
      <td>male</td>
      <td>Third</td>
      <td>7.7500</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>


이제 'class' 열 그룹에 대해 이 함수(top)를 apply하면 다음과 같은 결과를 얻을 수 있다.<br>



```python
df.groupby('class').apply(top)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>age</th>
      <th>sex</th>
      <th>class</th>
      <th>fare</th>
      <th>survived</th>
    </tr>
    <tr>
      <th>class</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5" valign="top">First</th>
      <th>630</th>
      <td>80.0</td>
      <td>male</td>
      <td>First</td>
      <td>30.0000</td>
      <td>1</td>
    </tr>
    <tr>
      <th>493</th>
      <td>71.0</td>
      <td>male</td>
      <td>First</td>
      <td>49.5042</td>
      <td>0</td>
    </tr>
    <tr>
      <th>96</th>
      <td>71.0</td>
      <td>male</td>
      <td>First</td>
      <td>34.6542</td>
      <td>0</td>
    </tr>
    <tr>
      <th>745</th>
      <td>70.0</td>
      <td>male</td>
      <td>First</td>
      <td>71.0000</td>
      <td>0</td>
    </tr>
    <tr>
      <th>456</th>
      <td>65.0</td>
      <td>male</td>
      <td>First</td>
      <td>26.5500</td>
      <td>0</td>
    </tr>
    <tr>
      <th rowspan="5" valign="top">Second</th>
      <th>672</th>
      <td>70.0</td>
      <td>male</td>
      <td>Second</td>
      <td>10.5000</td>
      <td>0</td>
    </tr>
    <tr>
      <th>33</th>
      <td>66.0</td>
      <td>male</td>
      <td>Second</td>
      <td>10.5000</td>
      <td>0</td>
    </tr>
    <tr>
      <th>570</th>
      <td>62.0</td>
      <td>male</td>
      <td>Second</td>
      <td>10.5000</td>
      <td>1</td>
    </tr>
    <tr>
      <th>684</th>
      <td>60.0</td>
      <td>male</td>
      <td>Second</td>
      <td>39.0000</td>
      <td>0</td>
    </tr>
    <tr>
      <th>232</th>
      <td>59.0</td>
      <td>male</td>
      <td>Second</td>
      <td>13.5000</td>
      <td>0</td>
    </tr>
    <tr>
      <th rowspan="5" valign="top">Third</th>
      <th>851</th>
      <td>74.0</td>
      <td>male</td>
      <td>Third</td>
      <td>7.7750</td>
      <td>0</td>
    </tr>
    <tr>
      <th>116</th>
      <td>70.5</td>
      <td>male</td>
      <td>Third</td>
      <td>7.7500</td>
      <td>0</td>
    </tr>
    <tr>
      <th>280</th>
      <td>65.0</td>
      <td>male</td>
      <td>Third</td>
      <td>7.7500</td>
      <td>0</td>
    </tr>
    <tr>
      <th>483</th>
      <td>63.0</td>
      <td>female</td>
      <td>Third</td>
      <td>9.5875</td>
      <td>1</td>
    </tr>
    <tr>
      <th>326</th>
      <td>61.0</td>
      <td>male</td>
      <td>Third</td>
      <td>6.2375</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>


위 결과를 보면 top 함수가 나뉘어진 데이터프레임의 각 부분에 모두 적용이 되었고, `pandas.concat()`을 이용해서 하나로 합쳐진 다음 그룹 이름표(class)가 붙었다. 그리하여 결과는 계층적 색인을 가지게 되고 내부 색인은 원본 데이터프레임의 인덱스값을 가지게 된다.<br><br>

만일 `apply()` 메서드로 넘길 함수가 추가적인 인자를 받는다면 함수 이름 뒤에 붙여서 넘겨주면 된다.<br>



```python
df.groupby(['class', 'sex']).apply(top, n=1, column='age')
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th></th>
      <th>age</th>
      <th>sex</th>
      <th>class</th>
      <th>fare</th>
      <th>survived</th>
    </tr>
    <tr>
      <th>class</th>
      <th>sex</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">First</th>
      <th>female</th>
      <th>275</th>
      <td>63.0</td>
      <td>female</td>
      <td>First</td>
      <td>77.9583</td>
      <td>1</td>
    </tr>
    <tr>
      <th>male</th>
      <th>630</th>
      <td>80.0</td>
      <td>male</td>
      <td>First</td>
      <td>30.0000</td>
      <td>1</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Second</th>
      <th>female</th>
      <th>772</th>
      <td>57.0</td>
      <td>female</td>
      <td>Second</td>
      <td>10.5000</td>
      <td>0</td>
    </tr>
    <tr>
      <th>male</th>
      <th>672</th>
      <td>70.0</td>
      <td>male</td>
      <td>Second</td>
      <td>10.5000</td>
      <td>0</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Third</th>
      <th>female</th>
      <th>483</th>
      <td>63.0</td>
      <td>female</td>
      <td>Third</td>
      <td>9.5875</td>
      <td>1</td>
    </tr>
    <tr>
      <th>male</th>
      <th>851</th>
      <td>74.0</td>
      <td>male</td>
      <td>Third</td>
      <td>7.7750</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>


<strong>NOTE_</strong>여기서 소개하는 기본적인 사용 방법 외에도 <code>apply()</code> 메서드를 창의적인 방법으로 다양하게 사용할 수 있다. 넘기는 함수 안에서 하는 일은 전적으로 사용자에게 달려 있다. 단치 판다스 객체나 스칼라값을 반환하는 함수면 된다. 이 페이지의 남은 부분에서는 주로 <code>groupby()</code>를 사용해서 다양한 문제를 해결하는 방법을 보여주는 에제를 다룰 것이다.<br><br>


### 그룹 색인 생략하기

앞서 살펴본 예제들에서 반환된 객체는 원본 객체의 각 조각에 대한 인덱스와 그룹 키가 계층적 색인으로 사용됨을 볼 수 있었다. 이런 결과는 `groupby()` 메서드에 group_keys=False를 넘겨서 막을 수 있다.<br>



```python
df.groupby('sex', group_keys=False).apply(top)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>age</th>
      <th>sex</th>
      <th>class</th>
      <th>fare</th>
      <th>survived</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>483</th>
      <td>63.0</td>
      <td>female</td>
      <td>Third</td>
      <td>9.5875</td>
      <td>1</td>
    </tr>
    <tr>
      <th>275</th>
      <td>63.0</td>
      <td>female</td>
      <td>First</td>
      <td>77.9583</td>
      <td>1</td>
    </tr>
    <tr>
      <th>829</th>
      <td>62.0</td>
      <td>female</td>
      <td>First</td>
      <td>80.0000</td>
      <td>1</td>
    </tr>
    <tr>
      <th>366</th>
      <td>60.0</td>
      <td>female</td>
      <td>First</td>
      <td>75.2500</td>
      <td>1</td>
    </tr>
    <tr>
      <th>268</th>
      <td>58.0</td>
      <td>female</td>
      <td>First</td>
      <td>153.4625</td>
      <td>1</td>
    </tr>
    <tr>
      <th>630</th>
      <td>80.0</td>
      <td>male</td>
      <td>First</td>
      <td>30.0000</td>
      <td>1</td>
    </tr>
    <tr>
      <th>851</th>
      <td>74.0</td>
      <td>male</td>
      <td>Third</td>
      <td>7.7750</td>
      <td>0</td>
    </tr>
    <tr>
      <th>96</th>
      <td>71.0</td>
      <td>male</td>
      <td>First</td>
      <td>34.6542</td>
      <td>0</td>
    </tr>
    <tr>
      <th>493</th>
      <td>71.0</td>
      <td>male</td>
      <td>First</td>
      <td>49.5042</td>
      <td>0</td>
    </tr>
    <tr>
      <th>116</th>
      <td>70.5</td>
      <td>male</td>
      <td>Third</td>
      <td>7.7500</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>


<br><br>

### 변위치 분석과 버킷 분석

판다스의 <code>cut()</code>과 <code>qcut()</code> 메서드를 사용해서 선택한 크기만큼 혹은 표본 변위치에 따라 데이터를 나눌 수 있었다. 즉, 동일한 길이로 나누거나 동일한 개수로 나눌 수 있었다. 이 함수들을 <code>groupby()</code>와 조합하면 데이터 묶음에 대해 변위치 분석이나 버킷 분석을 매우 쉽게 수행할 수 있다. 임의의 데이터 묶음을 <code>cut()</code>을 이용해서 등간격 구간으로 나누어보자.<br>



```python
frame = pd.DataFrame({'data1': np.random.randn(1000),
                      'data2': np.random.randn(1000)})

quartiles = pd.cut(frame.data1, 4)

quartiles[:10]
```

<pre>
0     (-0.104, 1.396]
1      (1.396, 2.895]
2    (-1.603, -0.104]
3     (-0.104, 1.396]
4    (-3.109, -1.603]
5     (-0.104, 1.396]
6     (-0.104, 1.396]
7     (-0.104, 1.396]
8    (-1.603, -0.104]
9     (-0.104, 1.396]
Name: data1, dtype: category
Categories (4, interval[float64, right]): [(-3.109, -1.603] < (-1.603, -0.104] < (-0.104, 1.396] < (1.396, 2.895]]
</pre>
<code>cut()</code>에서 반환된 Categorical 객체는 바로 <code>groupby()</code>로 넘길 수 있다. 그러므로 data2 칼럼에 대한 몇 가지 통계를 다음과 같이 계산할 수 있다.<br>



```python
def get_stats(group):
    return {'min': group.min(), 'max': group.max(),
            'count': group.count(), 'mean': group.mean()}

grouped = frame.data2.groupby(quartiles)

grouped.apply(get_stats).unstack()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>min</th>
      <th>max</th>
      <th>count</th>
      <th>mean</th>
    </tr>
    <tr>
      <th>data1</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>(-3.109, -1.603]</th>
      <td>-2.394062</td>
      <td>2.082127</td>
      <td>58.0</td>
      <td>-0.007639</td>
    </tr>
    <tr>
      <th>(-1.603, -0.104]</th>
      <td>-3.030777</td>
      <td>2.478698</td>
      <td>378.0</td>
      <td>-0.006070</td>
    </tr>
    <tr>
      <th>(-0.104, 1.396]</th>
      <td>-3.171915</td>
      <td>3.101419</td>
      <td>476.0</td>
      <td>-0.062328</td>
    </tr>
    <tr>
      <th>(1.396, 2.895]</th>
      <td>-1.829379</td>
      <td>2.569917</td>
      <td>88.0</td>
      <td>0.015193</td>
    </tr>
  </tbody>
</table>
</div>


이는 등간격 버킷이었고, 표본 변위치에 기반하여 크키가 같은 버킷을 계산하려면 <code>qcut()</code>을 사용한다. 다음 예제에서는 labels=False를 넘겨서 변위치 숫자를 구했다.<br>



```python
# 변위치 숫자를 반환
grouping = pd.qcut(frame.data1, 10, labels=False)

grouped = frame.data2.groupby(grouping)

grouped.apply(get_stats).unstack()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>min</th>
      <th>max</th>
      <th>count</th>
      <th>mean</th>
    </tr>
    <tr>
      <th>data1</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>-2.908298</td>
      <td>2.359413</td>
      <td>100.0</td>
      <td>-0.024017</td>
    </tr>
    <tr>
      <th>1</th>
      <td>-3.030777</td>
      <td>2.478698</td>
      <td>100.0</td>
      <td>-0.108802</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-2.446722</td>
      <td>2.361564</td>
      <td>100.0</td>
      <td>0.130300</td>
    </tr>
    <tr>
      <th>3</th>
      <td>-2.235216</td>
      <td>2.091979</td>
      <td>100.0</td>
      <td>-0.096549</td>
    </tr>
    <tr>
      <th>4</th>
      <td>-2.536442</td>
      <td>2.272229</td>
      <td>100.0</td>
      <td>0.015848</td>
    </tr>
    <tr>
      <th>5</th>
      <td>-2.557897</td>
      <td>2.120211</td>
      <td>100.0</td>
      <td>-0.030039</td>
    </tr>
    <tr>
      <th>6</th>
      <td>-3.171915</td>
      <td>2.274249</td>
      <td>100.0</td>
      <td>-0.155419</td>
    </tr>
    <tr>
      <th>7</th>
      <td>-2.588174</td>
      <td>2.690629</td>
      <td>100.0</td>
      <td>-0.155062</td>
    </tr>
    <tr>
      <th>8</th>
      <td>-2.831150</td>
      <td>3.101419</td>
      <td>100.0</td>
      <td>0.075913</td>
    </tr>
    <tr>
      <th>9</th>
      <td>-2.565913</td>
      <td>2.569917</td>
      <td>100.0</td>
      <td>0.037139</td>
    </tr>
  </tbody>
</table>
</div>


<br><br>

### 예제: 그룹에 따른 값으로 결측치 채우기

누락된 데이터를 정리할 때면 어떤 경우에는 <code>dropna()</code>를 사용해서 데이터를 살펴보고 걸러내기도 한다. 하지만 어떤 경우에는 누락된 값을 고정된 값이나 혹은 데이터로부터 도출된 어떤 값으로 채우고 싶을 때도 있다. 이런 경우 <code>fillna()</code> 메서드를 사용하는데, 누락된 값을 평균값으로 대체하는 예제를 살펴보자.<br>



```python
s = pd.Series(np.random.randn(6))

s[::2] = np.nan

s
```

<pre>
0         NaN
1    0.321992
2         NaN
3    0.409872
4         NaN
5   -0.225796
dtype: float64
</pre>

```python
s.fillna(s.mean())
```

<pre>
0    0.168689
1    0.321992
2    0.168689
3    0.409872
4    0.168689
5   -0.225796
dtype: float64
</pre>
그룹별로 채워 넣고 싶은 값이 다르다고 가정해보자. 아마도 추측했듯이 데이터를 그룹으로 나누고 <code>apply</code> 함수를 사용해서 각 그룹에 대해 <code>fillna</code>를 적용하면 된다. 여기서 사용된 데이터는 동부와 서부로 나눈 미국의 지역에 대한 데이터다.<br>



```python
states = ['Ohio', 'New York', 'Vermont', 'Florida',
          'Oregon', 'Nevada', 'California', 'Idaho']

group_key = ['East'] * 4 + ['West'] * 4

data = pd.Series(np.random.randn(8), index=states)

data
```

<pre>
Ohio          0.744933
New York      0.831884
Vermont       0.724275
Florida       0.455120
Oregon        0.846945
Nevada       -0.660623
California    0.319344
Idaho         0.030500
dtype: float64
</pre>
데이터에서 몇몇 값을 결측치로 만들어보자.<br>



```python
data[['Vermont', 'Nevada', 'Idaho']] = np.nan

data
```

<pre>
Ohio          0.744933
New York      0.831884
Vermont            NaN
Florida       0.455120
Oregon        0.846945
Nevada             NaN
California    0.319344
Idaho              NaN
dtype: float64
</pre>

```python
data.groupby(group_key).mean()
```

<pre>
East    0.677312
West    0.583144
dtype: float64
</pre>
다음과 같이 누락된 값을 그룹의 평균값으로 채울 수 있다.<br>



```python
fill_mean = lambda g: g.fillna(g.mean())

data.groupby(group_key).apply(fill_mean)
```

<pre>
Ohio          0.744933
New York      0.831884
Vermont       0.677312
Florida       0.455120
Oregon        0.846945
Nevada        0.583144
California    0.319344
Idaho         0.583144
dtype: float64
</pre>
아니면 그룹에 따라 미리 정의된 다른 값을 채워 넣어야 할 경우도 있다. 각 그룹은 내부적으로 name이라는 속성을 가지고 있으므로 이를 이용하자.<br>



```python
fill_values = {'East': 0.5, 'West': -1}

fill_func = lambda g: g.fillna(fill_values[g.name])

data.groupby(group_key).apply(fill_func)
```

<pre>
Ohio          0.744933
New York      0.831884
Vermont       0.500000
Florida       0.455120
Oregon        0.846945
Nevada       -1.000000
California    0.319344
Idaho        -1.000000
dtype: float64
</pre>
<br><br>

### 예제: 랜덤 표본과 순열

대용량의 데이터를 몬테카를로 시뮬레이션이나 다른 애플리케이션에서 사용하기 위해 랜덤 표본을 뽑아낸다고 해보자. 뽑아내는 방법은 여러 가지가 있는데, 여기서는 Series의 <code>sample()</code> 메서드를 사용하자.<br><br>

예시를 위해 트럼프 카드 덱을 한번 만들어보자.<br>



```python
# 하트, 스페이드, 클러버, 다이아몬드
suits = ['H', 'S', 'C', 'D']
card_val = (list(range(1, 11)) + [10] * 3) * 4
base_names = ['A'] + list(range(2, 11)) + ['J', 'K', 'Q']
cards = []
for suit in suits:
    cards.extend(str(num) + suit for num in base_names)
    
deck = pd.Series(card_val, index=cards)
```

이렇게 해서 블랙잭 같은 게임에서 사용하는 카드 이름과 값을 색인으로 하는 52장의 카드가 시리즈 객체로 준비되었다(단순히 하기 위해 에이스 'A'를 1로 취급했다).<br>



```python
deck[:13]
```

<pre>
AH      1
2H      2
3H      3
4H      4
5H      5
6H      6
7H      7
8H      8
9H      9
10H    10
JH     10
KH     10
QH     10
dtype: int64
</pre>
이제 앞에서 얘기한 것처럼 5장의 카드를 뽑기 위해 다음 코드를 작성한다.<br>



```python
def draw(deck, n=5):
    return deck.sample(n)

draw(deck)
```

<pre>
7D     7
4D     4
6H     6
JS    10
7S     7
dtype: int64
</pre>
각 세트(하트, 스페이드, 클러버, 다이아몬드)별로 2장의 카드를 무작위로 뽑고 싶다고 가정하자. 세트는 각 카드 이름의 마지막 글자이므로 이를 이용해서 그룹을 나누고 <code>apply()</code>를 사용하자.<br>



```python
get_suit = lambda card: card[-1]    # 마지막 글자가 세트

deck.groupby(get_suit).apply(draw, n=2)
```

<pre>
C  8C     8
   6C     6
D  9D     9
   JD    10
H  9H     9
   3H     3
S  9S     9
   7S     7
dtype: int64
</pre>
아래와 같은 방법으로 각 세트별 2장의 카드를 무작위로 뽑을 수도 있다.<br>



```python
deck.groupby(get_suit, group_keys=False).apply(draw, n=2)
```

<pre>
5C     5
KC    10
KD    10
2D     2
QH    10
7H     7
5S     5
7S     7
dtype: int64
</pre>
<br><br>

### 예제: 그룹 가중 평균과 상관관계

<code>groupby()</code>의 나누고 적용하고 합치는 패러다임에서 (그룹 가중 평균과 같은) 데이터프레임의 칼럼 간 연산이나 두 시리즈 간의 연산은 일상적인 일이다. 예를 들어 그룹 키와 값 그리고 어떤 가중치를 갖는 다음 데이터 묶음을 살펴보자.<br>



```python
df = pd.DataFrame({'category': ['a', 'a', 'a', 'a',
                                'b', 'b', 'b', 'b'],
                   'data': np.random.randn(8),
                   'weights': np.random.rand(8)})

df
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>category</th>
      <th>data</th>
      <th>weights</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>a</td>
      <td>1.209936</td>
      <td>0.377531</td>
    </tr>
    <tr>
      <th>1</th>
      <td>a</td>
      <td>0.824663</td>
      <td>0.328378</td>
    </tr>
    <tr>
      <th>2</th>
      <td>a</td>
      <td>0.663372</td>
      <td>0.331725</td>
    </tr>
    <tr>
      <th>3</th>
      <td>a</td>
      <td>0.671434</td>
      <td>0.517987</td>
    </tr>
    <tr>
      <th>4</th>
      <td>b</td>
      <td>1.256572</td>
      <td>0.116242</td>
    </tr>
    <tr>
      <th>5</th>
      <td>b</td>
      <td>-2.311121</td>
      <td>0.768394</td>
    </tr>
    <tr>
      <th>6</th>
      <td>b</td>
      <td>-0.122240</td>
      <td>0.234716</td>
    </tr>
    <tr>
      <th>7</th>
      <td>b</td>
      <td>1.163265</td>
      <td>0.753302</td>
    </tr>
  </tbody>
</table>
</div>


category 별 그룹 가중 평균을 보면 다음과 같다.<br>



```python
grouped = df.groupby('category')

get_wavg = lambda g: np.average(g['data'], weights=g['weights'])

grouped.apply(get_wavg)
```

<pre>
category
a    0.832748
b   -0.417689
dtype: float64
</pre>
좀 더 복잡한 예제로 야후! 파이낸스에서 가져온 몇몇 주식과 S&P 500 지수(종목 코드 SPX)의 종가 데이터를 살펴보자.<br>



```python
close_px = pd.read_csv('examples/stock_px_2.csv', parse_dates=True,
                       index_col=0)

close_px.info()
```

<pre>
<class 'pandas.core.frame.DataFrame'>
DatetimeIndex: 2214 entries, 2003-01-02 to 2011-10-14
Data columns (total 4 columns):
 #   Column  Non-Null Count  Dtype  
---  ------  --------------  -----  
 0   AAPL    2214 non-null   float64
 1   MSFT    2214 non-null   float64
 2   XOM     2214 non-null   float64
 3   SPX     2214 non-null   float64
dtypes: float64(4)
memory usage: 86.5 KB
</pre>

```python
close_px[-4:]
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>AAPL</th>
      <th>MSFT</th>
      <th>XOM</th>
      <th>SPX</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2011-10-11</th>
      <td>400.29</td>
      <td>27.00</td>
      <td>76.27</td>
      <td>1195.54</td>
    </tr>
    <tr>
      <th>2011-10-12</th>
      <td>402.19</td>
      <td>26.96</td>
      <td>77.16</td>
      <td>1207.25</td>
    </tr>
    <tr>
      <th>2011-10-13</th>
      <td>408.43</td>
      <td>27.18</td>
      <td>76.37</td>
      <td>1203.66</td>
    </tr>
    <tr>
      <th>2011-10-14</th>
      <td>422.00</td>
      <td>27.27</td>
      <td>78.11</td>
      <td>1224.58</td>
    </tr>
  </tbody>
</table>
</div>


퍼센트 변화율로 일일 수익률을 계산하여 연간 SPX 지수와의 상관관계를 살펴보는 일은 흥미로울 수 있는데, 다음과 같이 구할 수 있다. 우선 'SPX' 칼럼과 다른 칼럼의 상관관계를 계산하는 함수를 만든다.<br>



```python
spx_corr = lambda x: x.corrwith(x['SPX'])
```

그리고 <code>pct_change()</code> 함수를 이용해서 close_px의 퍼센트 변화율을 계산한다.<br>



```python
rets = close_px.pct_change().dropna()

rets
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>AAPL</th>
      <th>MSFT</th>
      <th>XOM</th>
      <th>SPX</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2003-01-03</th>
      <td>0.006757</td>
      <td>0.001421</td>
      <td>0.000684</td>
      <td>-0.000484</td>
    </tr>
    <tr>
      <th>2003-01-06</th>
      <td>0.000000</td>
      <td>0.017975</td>
      <td>0.024624</td>
      <td>0.022474</td>
    </tr>
    <tr>
      <th>2003-01-07</th>
      <td>-0.002685</td>
      <td>0.019052</td>
      <td>-0.033712</td>
      <td>-0.006545</td>
    </tr>
    <tr>
      <th>2003-01-08</th>
      <td>-0.020188</td>
      <td>-0.028272</td>
      <td>-0.004145</td>
      <td>-0.014086</td>
    </tr>
    <tr>
      <th>2003-01-09</th>
      <td>0.008242</td>
      <td>0.029094</td>
      <td>0.021159</td>
      <td>0.019386</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>2011-10-10</th>
      <td>0.051406</td>
      <td>0.026286</td>
      <td>0.036977</td>
      <td>0.034125</td>
    </tr>
    <tr>
      <th>2011-10-11</th>
      <td>0.029526</td>
      <td>0.002227</td>
      <td>-0.000131</td>
      <td>0.000544</td>
    </tr>
    <tr>
      <th>2011-10-12</th>
      <td>0.004747</td>
      <td>-0.001481</td>
      <td>0.011669</td>
      <td>0.009795</td>
    </tr>
    <tr>
      <th>2011-10-13</th>
      <td>0.015515</td>
      <td>0.008160</td>
      <td>-0.010238</td>
      <td>-0.002974</td>
    </tr>
    <tr>
      <th>2011-10-14</th>
      <td>0.033225</td>
      <td>0.003311</td>
      <td>0.022784</td>
      <td>0.017380</td>
    </tr>
  </tbody>
</table>
<p>2213 rows × 4 columns</p>
</div>


마지막으로 각 datetims에서 연도 속성만 반환하는 한줄 짜리 함수를 이용해서 연도별 퍼센트 변화율을 구한다.<br>



```python
get_year = lambda x: x.year

by_year = rets.groupby(get_year)

by_year.apply(spx_corr)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>AAPL</th>
      <th>MSFT</th>
      <th>XOM</th>
      <th>SPX</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2003</th>
      <td>0.541124</td>
      <td>0.745174</td>
      <td>0.661265</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>2004</th>
      <td>0.374283</td>
      <td>0.588531</td>
      <td>0.557742</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>2005</th>
      <td>0.467540</td>
      <td>0.562374</td>
      <td>0.631010</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>2006</th>
      <td>0.428267</td>
      <td>0.406126</td>
      <td>0.518514</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>2007</th>
      <td>0.508118</td>
      <td>0.658770</td>
      <td>0.786264</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>2008</th>
      <td>0.681434</td>
      <td>0.804626</td>
      <td>0.828303</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>2009</th>
      <td>0.707103</td>
      <td>0.654902</td>
      <td>0.797921</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>2010</th>
      <td>0.710105</td>
      <td>0.730118</td>
      <td>0.839057</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>2011</th>
      <td>0.691931</td>
      <td>0.800996</td>
      <td>0.859975</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
</div>


물론 두 칼럼 간의 상관관계를 계산하는 것도 가능하다. 다음은 애플('AAPL')과 마이크로소프트('MSFT') 주가의 연간 상관관계다.<br>



```python
by_year.apply(lambda g: g['AAPL'].corr(g['MSFT']))
```

<pre>
2003    0.480868
2004    0.259024
2005    0.300093
2006    0.161735
2007    0.417738
2008    0.611901
2009    0.432738
2010    0.571946
2011    0.581987
dtype: float64
</pre>
<br><br>

### 예제: 그룹상의 선형회귀

이전 예제와 같은 맥락으로, 판다스 객체나 스칼라값을 반환하기만 한다면 <code>groupby()</code>를 좀 더 복잡한 그룹상의 통계 분석을 위해 사용할 수 있다. 예를 들어 계량경제 라이브러리<sup>econometrics library</sup>인 statsmodels를 사용해서 regress라는 함수를 작성하고 각 데이터 묶음마다 최소제곱<sup>Ordinary Least Squares, OLS</sup>으로 회귀를 수행할 수 있다.<br>



```python
import statsmodels.api as sm

def regress(data, yvar, xvars):
    Y = data[yvar]
    X = data[xvars]
    X['intercept'] = 1.
    result = sm.OLS(Y, X).fit()
    return result.params
```

이제 SPX 수익률에 대한 애플('AAPL') 주식의 연간 선형회귀는 다음과 같이 수행할 수 있다.<br>



```python
by_year.apply(regress, 'AAPL', ['SPX'])
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>SPX</th>
      <th>intercept</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2003</th>
      <td>1.195406</td>
      <td>0.000710</td>
    </tr>
    <tr>
      <th>2004</th>
      <td>1.363463</td>
      <td>0.004201</td>
    </tr>
    <tr>
      <th>2005</th>
      <td>1.766415</td>
      <td>0.003246</td>
    </tr>
    <tr>
      <th>2006</th>
      <td>1.645496</td>
      <td>0.000080</td>
    </tr>
    <tr>
      <th>2007</th>
      <td>1.198761</td>
      <td>0.003438</td>
    </tr>
    <tr>
      <th>2008</th>
      <td>0.968016</td>
      <td>-0.001110</td>
    </tr>
    <tr>
      <th>2009</th>
      <td>0.879103</td>
      <td>0.002954</td>
    </tr>
    <tr>
      <th>2010</th>
      <td>1.052608</td>
      <td>0.001261</td>
    </tr>
    <tr>
      <th>2011</th>
      <td>0.806605</td>
      <td>0.001514</td>
    </tr>
  </tbody>
</table>
</div>


<br><br>

## 피벗테이블과 교차일람표


<strong>피벗테이블</strong>은 스프레드시트 프로그램과 그 외 다른 데이터 분석 소프트웨어에서 흔히 볼 수 있는 데이터 요약화 도구다. 피벗테이블은 데이터를 하나 이상의 키로 수집해서 어떤 키는 로우에, 어떤 키는 칼럼에 나열해서 데이터를 정렬한다. 판다스에서 피벗테이블은 이 장에서 설명했던 <code>groupby()</code> 기능을 사용해서 계층적 색인을 활용한 재형성 연산을 가능하게 해준다. 데이터프레임에는 <code>pivot_table()</code> 메서드가 있는데 이는 판다스 모듈의 최상위 함수로도 존재한다(<code>pandas.pivot_table()</code>). <code>groupby()</code>를 위한 편리한 인터페이스를 제공하기 위해 <code>pivot_table()</code>은 <strong>마진</strong>이라고 하는 부분합을 추가할 수 있는 기능을 제공한다.<br><br>

팁 데이터로 돌아가서 요일(day)과 흡연자(smoker) 집단에서 평균(<code>pivot_table()</code>의 기본 연산)을 구해보자.<br>



```python
tips.pivot_table(index=['day', 'smoker'])
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>size</th>
      <th>tip</th>
      <th>tip_pct</th>
      <th>total_bill</th>
    </tr>
    <tr>
      <th>day</th>
      <th>smoker</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">Fri</th>
      <th>No</th>
      <td>2.250000</td>
      <td>2.812500</td>
      <td>0.151650</td>
      <td>18.420000</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>2.066667</td>
      <td>2.714000</td>
      <td>0.174783</td>
      <td>16.813333</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Sat</th>
      <th>No</th>
      <td>2.555556</td>
      <td>3.102889</td>
      <td>0.158048</td>
      <td>19.661778</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>2.476190</td>
      <td>2.875476</td>
      <td>0.147906</td>
      <td>21.276667</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Sun</th>
      <th>No</th>
      <td>2.929825</td>
      <td>3.167895</td>
      <td>0.160113</td>
      <td>20.506667</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>2.578947</td>
      <td>3.516842</td>
      <td>0.187250</td>
      <td>24.120000</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Thur</th>
      <th>No</th>
      <td>2.488889</td>
      <td>2.673778</td>
      <td>0.160298</td>
      <td>17.113111</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>2.352941</td>
      <td>3.030000</td>
      <td>0.163863</td>
      <td>19.190588</td>
    </tr>
  </tbody>
</table>
</div>


이는 <code>groupby()</code>를 사용해서 쉽게 구할 수 있는데, 이제 tip_pct와 size에 대해서만 집계를 하고 날짜(time)별로 그룹지어보자. 이를 위해 day 로우와 smoker 칼럼을 추가했다.<br>



```python
tips.pivot_table(values=['tip_pct', 'size'], index=['time', 'day'],
                 columns='smoker')
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th colspan="2" halign="left">size</th>
      <th colspan="2" halign="left">tip_pct</th>
    </tr>
    <tr>
      <th></th>
      <th>smoker</th>
      <th>No</th>
      <th>Yes</th>
      <th>No</th>
      <th>Yes</th>
    </tr>
    <tr>
      <th>time</th>
      <th>day</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4" valign="top">Dinner</th>
      <th>Fri</th>
      <td>2.000000</td>
      <td>2.222222</td>
      <td>0.139622</td>
      <td>0.165347</td>
    </tr>
    <tr>
      <th>Sat</th>
      <td>2.555556</td>
      <td>2.476190</td>
      <td>0.158048</td>
      <td>0.147906</td>
    </tr>
    <tr>
      <th>Sun</th>
      <td>2.929825</td>
      <td>2.578947</td>
      <td>0.160113</td>
      <td>0.187250</td>
    </tr>
    <tr>
      <th>Thur</th>
      <td>2.000000</td>
      <td>NaN</td>
      <td>0.159744</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Lunch</th>
      <th>Fri</th>
      <td>3.000000</td>
      <td>1.833333</td>
      <td>0.187735</td>
      <td>0.188937</td>
    </tr>
    <tr>
      <th>Thur</th>
      <td>2.500000</td>
      <td>2.352941</td>
      <td>0.160311</td>
      <td>0.163863</td>
    </tr>
  </tbody>
</table>
</div>


이 테이블은 margins=True를 넘겨서 부분합을 포함하도록 확장할 수 있는데, 그렇게 하면 All 칼럼과 All 로우가 추가되어 단일 줄 안에서 그룹 통계를 얻을 수 있다.<br>



```python
tips.pivot_table(values=['tip_pct', 'size'], index=['time', 'day'],
                 columns='smoker', margins=True)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th colspan="3" halign="left">size</th>
      <th colspan="3" halign="left">tip_pct</th>
    </tr>
    <tr>
      <th></th>
      <th>smoker</th>
      <th>No</th>
      <th>Yes</th>
      <th>All</th>
      <th>No</th>
      <th>Yes</th>
      <th>All</th>
    </tr>
    <tr>
      <th>time</th>
      <th>day</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4" valign="top">Dinner</th>
      <th>Fri</th>
      <td>2.000000</td>
      <td>2.222222</td>
      <td>2.166667</td>
      <td>0.139622</td>
      <td>0.165347</td>
      <td>0.158916</td>
    </tr>
    <tr>
      <th>Sat</th>
      <td>2.555556</td>
      <td>2.476190</td>
      <td>2.517241</td>
      <td>0.158048</td>
      <td>0.147906</td>
      <td>0.153152</td>
    </tr>
    <tr>
      <th>Sun</th>
      <td>2.929825</td>
      <td>2.578947</td>
      <td>2.842105</td>
      <td>0.160113</td>
      <td>0.187250</td>
      <td>0.166897</td>
    </tr>
    <tr>
      <th>Thur</th>
      <td>2.000000</td>
      <td>NaN</td>
      <td>2.000000</td>
      <td>0.159744</td>
      <td>NaN</td>
      <td>0.159744</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Lunch</th>
      <th>Fri</th>
      <td>3.000000</td>
      <td>1.833333</td>
      <td>2.000000</td>
      <td>0.187735</td>
      <td>0.188937</td>
      <td>0.188765</td>
    </tr>
    <tr>
      <th>Thur</th>
      <td>2.500000</td>
      <td>2.352941</td>
      <td>2.459016</td>
      <td>0.160311</td>
      <td>0.163863</td>
      <td>0.161301</td>
    </tr>
    <tr>
      <th>All</th>
      <th></th>
      <td>2.668874</td>
      <td>2.408602</td>
      <td>2.569672</td>
      <td>0.159328</td>
      <td>0.163196</td>
      <td>0.160803</td>
    </tr>
  </tbody>
</table>
</div>


여기서 All 값은 흡연자와 비흡연자를 구분하지 않은 평균값(All 칼럼)이거나 로우에서 두 단계를 묶은 그룹의 평균값(All 로우)이다.<br><br>

다른 집계함수를 사용하려면 그냥 aggfunc로 넘기면 되는데, 예를 들어 'count'나 <code>len()</code> 함수는 그룹 크기의 교차일람표(총 개수나 빈도)를 반환한다.<br>



```python
tips.pivot_table(values='tip_pct', index=['time', 'smoker'], columns='day',
                 aggfunc=len, margins=True)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>day</th>
      <th>Fri</th>
      <th>Sat</th>
      <th>Sun</th>
      <th>Thur</th>
      <th>All</th>
    </tr>
    <tr>
      <th>time</th>
      <th>smoker</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">Dinner</th>
      <th>No</th>
      <td>3.0</td>
      <td>45.0</td>
      <td>57.0</td>
      <td>1.0</td>
      <td>106</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>9.0</td>
      <td>42.0</td>
      <td>19.0</td>
      <td>NaN</td>
      <td>70</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Lunch</th>
      <th>No</th>
      <td>1.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>44.0</td>
      <td>45</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>6.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>17.0</td>
      <td>23</td>
    </tr>
    <tr>
      <th>All</th>
      <th></th>
      <td>19.0</td>
      <td>87.0</td>
      <td>76.0</td>
      <td>62.0</td>
      <td>244</td>
    </tr>
  </tbody>
</table>
</div>


만약 어떤 조합이 비어 있다면(혹은 NA 값) fill_value를 넘길 수도 있다.<br>



```python
tips.pivot_table(values='tip_pct', index=['time', 'size', 'smoker'],
                 columns='day', aggfunc='mean', fill_value=0)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>day</th>
      <th>Fri</th>
      <th>Sat</th>
      <th>Sun</th>
      <th>Thur</th>
    </tr>
    <tr>
      <th>time</th>
      <th>size</th>
      <th>smoker</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="11" valign="top">Dinner</th>
      <th rowspan="2" valign="top">1</th>
      <th>No</th>
      <td>0.000000</td>
      <td>0.137931</td>
      <td>0.000000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>0.000000</td>
      <td>0.325733</td>
      <td>0.000000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">2</th>
      <th>No</th>
      <td>0.139622</td>
      <td>0.162705</td>
      <td>0.168859</td>
      <td>0.159744</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>0.171297</td>
      <td>0.148668</td>
      <td>0.207893</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">3</th>
      <th>No</th>
      <td>0.000000</td>
      <td>0.154661</td>
      <td>0.152663</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>0.000000</td>
      <td>0.144995</td>
      <td>0.152660</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">4</th>
      <th>No</th>
      <td>0.000000</td>
      <td>0.150096</td>
      <td>0.148143</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>0.117750</td>
      <td>0.124515</td>
      <td>0.193370</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">5</th>
      <th>No</th>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.206928</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>0.000000</td>
      <td>0.106572</td>
      <td>0.065660</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>6</th>
      <th>No</th>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.103799</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th rowspan="10" valign="top">Lunch</th>
      <th rowspan="2" valign="top">1</th>
      <th>No</th>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.181728</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>0.223776</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">2</th>
      <th>No</th>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.166005</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>0.181969</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.158843</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">3</th>
      <th>No</th>
      <td>0.187735</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.084246</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.204952</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">4</th>
      <th>No</th>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.138919</td>
    </tr>
    <tr>
      <th>Yes</th>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.155410</td>
    </tr>
    <tr>
      <th>5</th>
      <th>No</th>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.121389</td>
    </tr>
    <tr>
      <th>6</th>
      <th>No</th>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.173706</td>
    </tr>
  </tbody>
</table>
</div>


데이터프레임 pdf의 행을 선택하기 위해 xs 인덱서를 사용하는 방법을 살펴보자. xs 인덱서는 기본값으로 행 인덱스에 접근하고, 축 값은 axis=0으로 자동 설정된다. 먼저 행 인덱스가 'Dinner'인 점심 시간의 데이터를 추출해보자.<br>



```python
pdf = tips.pivot_table(values=['tip_pct', 'size'], index=['time', 'day'],
                 columns='smoker', margins=True)

pdf
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th colspan="3" halign="left">size</th>
      <th colspan="3" halign="left">tip_pct</th>
    </tr>
    <tr>
      <th></th>
      <th>smoker</th>
      <th>No</th>
      <th>Yes</th>
      <th>All</th>
      <th>No</th>
      <th>Yes</th>
      <th>All</th>
    </tr>
    <tr>
      <th>time</th>
      <th>day</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4" valign="top">Dinner</th>
      <th>Fri</th>
      <td>2.000000</td>
      <td>2.222222</td>
      <td>2.166667</td>
      <td>0.139622</td>
      <td>0.165347</td>
      <td>0.158916</td>
    </tr>
    <tr>
      <th>Sat</th>
      <td>2.555556</td>
      <td>2.476190</td>
      <td>2.517241</td>
      <td>0.158048</td>
      <td>0.147906</td>
      <td>0.153152</td>
    </tr>
    <tr>
      <th>Sun</th>
      <td>2.929825</td>
      <td>2.578947</td>
      <td>2.842105</td>
      <td>0.160113</td>
      <td>0.187250</td>
      <td>0.166897</td>
    </tr>
    <tr>
      <th>Thur</th>
      <td>2.000000</td>
      <td>NaN</td>
      <td>2.000000</td>
      <td>0.159744</td>
      <td>NaN</td>
      <td>0.159744</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Lunch</th>
      <th>Fri</th>
      <td>3.000000</td>
      <td>1.833333</td>
      <td>2.000000</td>
      <td>0.187735</td>
      <td>0.188937</td>
      <td>0.188765</td>
    </tr>
    <tr>
      <th>Thur</th>
      <td>2.500000</td>
      <td>2.352941</td>
      <td>2.459016</td>
      <td>0.160311</td>
      <td>0.163863</td>
      <td>0.161301</td>
    </tr>
    <tr>
      <th>All</th>
      <th></th>
      <td>2.668874</td>
      <td>2.408602</td>
      <td>2.569672</td>
      <td>0.159328</td>
      <td>0.163196</td>
      <td>0.160803</td>
    </tr>
  </tbody>
</table>
</div>



```python
pdf.xs('Dinner')    # 행 인덱스가 Dinner인 행을 선택
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th colspan="3" halign="left">size</th>
      <th colspan="3" halign="left">tip_pct</th>
    </tr>
    <tr>
      <th>smoker</th>
      <th>No</th>
      <th>Yes</th>
      <th>All</th>
      <th>No</th>
      <th>Yes</th>
      <th>All</th>
    </tr>
    <tr>
      <th>day</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Fri</th>
      <td>2.000000</td>
      <td>2.222222</td>
      <td>2.166667</td>
      <td>0.139622</td>
      <td>0.165347</td>
      <td>0.158916</td>
    </tr>
    <tr>
      <th>Sat</th>
      <td>2.555556</td>
      <td>2.476190</td>
      <td>2.517241</td>
      <td>0.158048</td>
      <td>0.147906</td>
      <td>0.153152</td>
    </tr>
    <tr>
      <th>Sun</th>
      <td>2.929825</td>
      <td>2.578947</td>
      <td>2.842105</td>
      <td>0.160113</td>
      <td>0.187250</td>
      <td>0.166897</td>
    </tr>
    <tr>
      <th>Thur</th>
      <td>2.000000</td>
      <td>NaN</td>
      <td>2.000000</td>
      <td>0.159744</td>
      <td>NaN</td>
      <td>0.159744</td>
    </tr>
  </tbody>
</table>
</div>


다음으로 행 인덱스 레벨 0에서 'Dinner'를 가져오고, 행 인덱스 레벨 1에서 'Sun'을 가져온다. 두 개의 인덱스 값을 튜플로 전달하면 일요일 점심 시간의 데이터만을 선택할 수 있다.<br>



```python
pdf.xs(('Dinner', 'Sun'))    # 행 인덱스가 ('Dinner', 'Sun')인 행을 선택
```

<pre>
         smoker
size     No        2.929825
         Yes       2.578947
         All       2.842105
tip_pct  No        0.160113
         Yes       0.187250
         All       0.166897
Name: (Dinner, Sun), dtype: float64
</pre>
이번에는 행 인덱스 레벨을 직접 지정하는 방법이다. 'day' 레벨에서 토요일을 나타내는 'Sat'에 해당하는 데이터만을 추출한다.<br>



```python
pdf.xs('Sat', level='day')    # 행 인덱스의 day 레벨이 Sat인 행을 선택
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th colspan="3" halign="left">size</th>
      <th colspan="3" halign="left">tip_pct</th>
    </tr>
    <tr>
      <th>smoker</th>
      <th>No</th>
      <th>Yes</th>
      <th>All</th>
      <th>No</th>
      <th>Yes</th>
      <th>All</th>
    </tr>
    <tr>
      <th>time</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Dinner</th>
      <td>2.555556</td>
      <td>2.47619</td>
      <td>2.517241</td>
      <td>0.158048</td>
      <td>0.147906</td>
      <td>0.153152</td>
    </tr>
  </tbody>
</table>
</div>


마지막으로 행 인덱스 레벨 0에서 'Lunch'를 가져오고 행 인덱스 레벨 'day'에서 'Fri'을 가져온다. 이때 레벨 이름 'day' 대신에 숫자형 레벨 1을 사용해도 결과는 동일하다.<br>



```python
pdf.xs(('Lunch', 'Fri'), level=[0, 'day'])    # Lunch, Fri인 행을 선택
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th colspan="3" halign="left">size</th>
      <th colspan="3" halign="left">tip_pct</th>
    </tr>
    <tr>
      <th></th>
      <th>smoker</th>
      <th>No</th>
      <th>Yes</th>
      <th>All</th>
      <th>No</th>
      <th>Yes</th>
      <th>All</th>
    </tr>
    <tr>
      <th>time</th>
      <th>day</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Lunch</th>
      <th>Fri</th>
      <td>3.0</td>
      <td>1.833333</td>
      <td>2.0</td>
      <td>0.187735</td>
      <td>0.188937</td>
      <td>0.188765</td>
    </tr>
  </tbody>
</table>
</div>


xs 인덱서를 이용하여 열 인덱스에 접근하기 위해서는 축 값을 axis=1로 설정해야 한다. 먼저 데이터프레임 pdf의 'size' 열을 선택하여 식사를 한 사람 평균 명수 데이터를 추출한다.<br>



```python
pdf.xs('size', axis=1)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>smoker</th>
      <th>No</th>
      <th>Yes</th>
      <th>All</th>
    </tr>
    <tr>
      <th>time</th>
      <th>day</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4" valign="top">Dinner</th>
      <th>Fri</th>
      <td>2.000000</td>
      <td>2.222222</td>
      <td>2.166667</td>
    </tr>
    <tr>
      <th>Sat</th>
      <td>2.555556</td>
      <td>2.476190</td>
      <td>2.517241</td>
    </tr>
    <tr>
      <th>Sun</th>
      <td>2.929825</td>
      <td>2.578947</td>
      <td>2.842105</td>
    </tr>
    <tr>
      <th>Thur</th>
      <td>2.000000</td>
      <td>NaN</td>
      <td>2.000000</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Lunch</th>
      <th>Fri</th>
      <td>3.000000</td>
      <td>1.833333</td>
      <td>2.000000</td>
    </tr>
    <tr>
      <th>Thur</th>
      <td>2.500000</td>
      <td>2.352941</td>
      <td>2.459016</td>
    </tr>
    <tr>
      <th>All</th>
      <th></th>
      <td>2.668874</td>
      <td>2.408602</td>
      <td>2.569672</td>
    </tr>
  </tbody>
</table>
</div>


다음 표에 <code>pivot_table()</code> 메서드를 요약해두었다.<br>

<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-ehbx{background-color:#9698ed;border-color:inherit;font-weight:bold;text-align:left;vertical-align:top}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-ehbx">함수</th>
    <th class="tg-ehbx">설명</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0pky">values</td>
    <td class="tg-0pky">집계하려는 칼럼 이름 혹은 이름의 리스트. 기본적으로 모든 숫자 칼럼을 집계한다.</td>
  </tr>
  <tr>
    <td class="tg-0pky">index</td>
    <td class="tg-0pky">만들어지는 피벗테이블의 로우를 그룹으로 묶을 칼럼 이름이나 그룹 키</td>
  </tr>
  <tr>
    <td class="tg-0pky">columns</td>
    <td class="tg-0pky">만들어지는 피벗테이블의 칼럼을 그룹으로 묶을 칼럼 이름이나 그룹 키</td>
  </tr>
  <tr>
    <td class="tg-0pky">aggfunc</td>
    <td class="tg-0pky">집계함수나 함수 리스트. 기본값으로 'mean'이 사용된다. groupby 컨텍스트 안에서 유효한 어떤 함수라도 가능하다.</td>
  </tr>
  <tr>
    <td class="tg-0pky">fill_value</td>
    <td class="tg-0pky">결과 테이블에서 누락된 값을 대체하기 위한 값</td>
  </tr>
  <tr>
    <td class="tg-0pky">dropna</td>
    <td class="tg-0pky">True인 경우 모든 항목이 NA인 칼럼은 포함하지 않는다.</td>
  </tr>
  <tr>
    <td class="tg-0pky">margins</td>
    <td class="tg-0pky">부분합이나 총계를 담기 위한 로우/칼럼을 추가할지 여부. 기본값은 False</td>
  </tr>
</tbody>
</table>


<br><br>

### 교차일람표

교차일람표(또는 <strong>교차표</strong>)는 그룹 빈도를 계산하기 위한 피벗테이블의 특수한 경우다. 다음은 위키피디아의 교차일람표 페이지에서 가져온 기본 예제다.<br>



```python
data
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Sample</th>
      <th>Nationality</th>
      <th>Handedness</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>USA</td>
      <td>Right-handed</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>Japan</td>
      <td>Left-handed</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>USA</td>
      <td>Right-handed</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4</td>
      <td>Japan</td>
      <td>Right-handed</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>Japan</td>
      <td>Left-handed</td>
    </tr>
    <tr>
      <th>5</th>
      <td>6</td>
      <td>Japan</td>
      <td>Right-handed</td>
    </tr>
    <tr>
      <th>6</th>
      <td>7</td>
      <td>USA</td>
      <td>Right-handed</td>
    </tr>
    <tr>
      <th>7</th>
      <td>8</td>
      <td>USA</td>
      <td>Left-handed</td>
    </tr>
    <tr>
      <th>8</th>
      <td>9</td>
      <td>Japan</td>
      <td>Right-handed</td>
    </tr>
    <tr>
      <th>9</th>
      <td>10</td>
      <td>USA</td>
      <td>Right-handed</td>
    </tr>
  </tbody>
</table>
</div>


설문 분석의 일부로서 이 데이터를 국적<sup>nationality</sup>과 잘 쓰는 손<sup>handedness</sup>에 따라 요약해보자. 이를 위해 <code>pivot_table()</code> 메서드를 사용할 수 있지만 <code>pandas.crosstab()</code> 함수가 훨씬 더 편리하다.<br>



```python
pd.crosstab(data.Nationality, data.Handedness, margins=True)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>Handedness</th>
      <th>Left-handed</th>
      <th>Right-handed</th>
      <th>All</th>
    </tr>
    <tr>
      <th>Nationality</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Japan</th>
      <td>2</td>
      <td>3</td>
      <td>5</td>
    </tr>
    <tr>
      <th>USA</th>
      <td>1</td>
      <td>4</td>
      <td>5</td>
    </tr>
    <tr>
      <th>All</th>
      <td>3</td>
      <td>7</td>
      <td>10</td>
    </tr>
  </tbody>
</table>
</div>


<code>crosstab()</code> 함수의 처음 두 인자는 배열이나 시리즈 혹은 배열의 리스트가 될 수 있다. 팁 데이터에 대해 교차표를 구해보자.<br>



```python
pd.crosstab([tips.time, tips.day], tips.smoker, margins=True)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>smoker</th>
      <th>No</th>
      <th>Yes</th>
      <th>All</th>
    </tr>
    <tr>
      <th>time</th>
      <th>day</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4" valign="top">Dinner</th>
      <th>Fri</th>
      <td>3</td>
      <td>9</td>
      <td>12</td>
    </tr>
    <tr>
      <th>Sat</th>
      <td>45</td>
      <td>42</td>
      <td>87</td>
    </tr>
    <tr>
      <th>Sun</th>
      <td>57</td>
      <td>19</td>
      <td>76</td>
    </tr>
    <tr>
      <th>Thur</th>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Lunch</th>
      <th>Fri</th>
      <td>1</td>
      <td>6</td>
      <td>7</td>
    </tr>
    <tr>
      <th>Thur</th>
      <td>44</td>
      <td>17</td>
      <td>61</td>
    </tr>
    <tr>
      <th>All</th>
      <th></th>
      <td>151</td>
      <td>93</td>
      <td>244</td>
    </tr>
  </tbody>
</table>
</div>

