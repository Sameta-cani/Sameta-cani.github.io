---
layout: single
title:  "Pandas04"
categories: pandas
tag: [python, pandas]
toc: true
author_profile: false
toc_sticky: true
---

<head>
  <style>
    table.dataframe {
      white-space: normal;
      width: 100%;
      height: 240px;
      display: block;
      overflow: auto;
      font-family: Arial, sans-serif;
      font-size: 0.9rem;
      line-height: 20px;
      text-align: center;
      border: 0px !important;
    }

    table.dataframe th {
      text-align: center;
      font-weight: bold;
      padding: 8px;
    }

    table.dataframe td {
      text-align: center;
      padding: 8px;
    }

    table.dataframe tr:hover {
      background: #b8d1f3; 
    }

    .output_prompt {
      overflow: auto;
      font-size: 0.9rem;
      line-height: 1.45;
      border-radius: 0.3rem;
      -webkit-overflow-scrolling: touch;
      padding: 0.8rem;
      margin-top: 0;
      margin-bottom: 15px;
      font: 1rem Consolas, "Liberation Mono", Menlo, Courier, monospace;
      color: $code-text-color;
      border: solid 1px $border-color;
      border-radius: 0.3rem;
      word-break: normal;
      white-space: pre;
    }

  .dataframe tbody tr th:only-of-type {
      vertical-align: middle;
  }

  .dataframe tbody tr th {
      vertical-align: top;
  }

  .dataframe thead th {
      text-align: center !important;
      padding: 8px;
  }

  .page__content p {
      margin: 0 0 0px !important;
  }

  .page__content p > strong {
    font-size: 0.8rem !important;
  }

  </style>
</head>


# 데이터 준비하기: 조인, 병합, 변형


대부분의 경우 데이터는 여러 파일이나 데이터베이스 혹은 분석하기 쉽지 않은 형태로 기록되어 있다. 여기서는 데이터를 합치고, 재배열할 수 있는 도구들을 살펴보자.<br><br>

먼저 데이터를 병합하거나 변환하는 과정에서 사용되는 판다스의 멀티 인덱스의 개념을 알아보고 이를 활용하여 데이터를 다듬는 과정을 심도 있게 살펴볼 것이다.


## 멀티 인덱스

<strong>멀티 인덱스</strong>는 판다스의 중요한 기능인데 축에 대해 다중(둘 이상) 인덱스 <strong>단계</strong>를 지정할 수 있도록 해준다. 약간 추상적으로 말하면, 높은 차원의 데이터를 낮은 차원의 형식으로 다룰 수 있게 해주는 기능이다. 간단한 예제를 하나 살펴보자. 우선 리스트의 리스트(또는 배열)를 인덱스로 하는 시리즈를 하나 생성하자.



```python
data = pd.Series(np.random.randn(9),
                 index=[['a', 'a', 'a', 'b', 'b', 'c', 'c', 'd', 'd'],
                        [1, 2, 3, 1, 3, 1, 2, 2, 3]])

data
```

<pre>
a  1    0.860255
   2    0.990249
   3   -1.681696
b  1   -1.016254
   3    1.249738
c  1   -0.507521
   2   -0.063223
d  2   -0.328800
   3   -0.163897
dtype: float64
</pre>
지금 생성한 객체가 MultiIndex를 인덱스로 하는 시리즈인데, 인덱스의 계층을 보여주고 있다. 바로 위 단계의 인덱스를 이용해서 하위 계층을 직접 접근할 수 있다.



```python
data.index
```

<pre>
MultiIndex([('a', 1),
            ('a', 2),
            ('a', 3),
            ('b', 1),
            ('b', 3),
            ('c', 1),
            ('c', 2),
            ('d', 2),
            ('d', 3)],
           )
</pre>
계층적으로 인덱싱된 객체는 데이터의 부분집합을 <strong>부분적 인덱싱으로 접근</strong><sup>partial indexing</sup>하는 것이 가능하다.



```python
data['b']
```

<pre>
1   -1.016254
3    1.249738
dtype: float64
</pre>

```python
data['b':'c']
```

<pre>
b  1   -1.016254
   3    1.249738
c  1   -0.507521
   2   -0.063223
dtype: float64
</pre>

```python
data.loc[['b', 'd']]
```

<pre>
b  1   -1.016254
   3    1.249738
d  2   -0.328800
   3   -0.163897
dtype: float64
</pre>
하위 계층의 객체를 선택하는 것도 가능하다.



```python
data.loc[:, 2]
```

<pre>
a    0.990249
c   -0.063223
d   -0.328800
dtype: float64
</pre>
계층적인 인덱스는 데이터를 재형성하고 피벗테이블 생성 같은 그룹 기반의 작업을 할 때 중요하게 사용된다. 예를 들어 위에서 만든 시리즈 객체에 `unstack()` 메서드를 사용해서 데이터를 데이터프레임으로 새롭게 배열할 수도 있다.



```python
print(data.unstack())
print('\n')
print(type(data.unstack()))
```

<pre>
          1         2         3
a  0.860255  0.990249 -1.681696
b -1.016254       NaN  1.249738
c -0.507521 -0.063223       NaN
d       NaN -0.328800 -0.163897


<class 'pandas.core.frame.DataFrame'>
</pre>
`unstack()`의 반대 작업은 `stack()` 메서드로 수행한다.



```python
print(data.unstack().stack())
print('\n')
print(type(data.unstack().stack()))
```

<pre>
a  1    0.860255
   2    0.990249
   3   -1.681696
b  1   -1.016254
   3    1.249738
c  1   -0.507521
   2   -0.063223
d  2   -0.328800
   3   -0.163897
dtype: float64


<class 'pandas.core.series.Series'>
</pre>
`stack()`과 `unstack()` 메서드는 후에 더 자세히 알아보기로 한다.


데이터프레임에서는 두 축 모두 계층적 인덱스를 가질 수 있다.



```python
frame = pd.DataFrame(np.arange(12).reshape((4, 3)),
                     index=[['a', 'a', 'b', 'b'], [1, 2, 1, 2,]],
                     columns=[['Ohio', 'Ohio', 'Colorado'],
                              ['Green', 'Red', 'Green']])

frame
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th colspan="2" halign="left">Ohio</th>
      <th>Colorado</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Green</th>
      <th>Red</th>
      <th>Green</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">a</th>
      <th>1</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>4</td>
      <td>5</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>1</th>
      <td>6</td>
      <td>7</td>
      <td>8</td>
    </tr>
    <tr>
      <th>2</th>
      <td>9</td>
      <td>10</td>
      <td>11</td>
    </tr>
  </tbody>
</table>
</div>


계층적 인덱스의 각 단계는 이름(문자열이나 어떤 파이썬 객체라도 가능하다)을 가질 수 있고, 만약 이름을 가지고 있다면 콘솔 출력 시 함께 나타난다.



```python
frame.index.names = ['key1', 'key2']
frame.columns.names = ['state', 'color']

frame
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>state</th>
      <th colspan="2" halign="left">Ohio</th>
      <th>Colorado</th>
    </tr>
    <tr>
      <th></th>
      <th>color</th>
      <th>Green</th>
      <th>Red</th>
      <th>Green</th>
    </tr>
    <tr>
      <th>key1</th>
      <th>key2</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">a</th>
      <th>1</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>4</td>
      <td>5</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>1</th>
      <td>6</td>
      <td>7</td>
      <td>8</td>
    </tr>
    <tr>
      <th>2</th>
      <td>9</td>
      <td>10</td>
      <td>11</td>
    </tr>
  </tbody>
</table>
</div>


칼럼의 부분집합을 부분적인 인덱싱으로 접근하는 것도 칼럼에 대한 부분적 인덱싱과 비슷하게 사용하면 된다.



```python
frame['Ohio']
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>color</th>
      <th>Green</th>
      <th>Red</th>
    </tr>
    <tr>
      <th>key1</th>
      <th>key2</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">a</th>
      <th>1</th>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>4</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>1</th>
      <td>6</td>
      <td>7</td>
    </tr>
    <tr>
      <th>2</th>
      <td>9</td>
      <td>10</td>
    </tr>
  </tbody>
</table>
</div>


참고로 MultiIndex는 따로 생성한 다음에 재사용 가능하고 다음처럼 재지정도 가능하다.



```python
multi_columns = pd.MultiIndex.from_arrays([['NS', 'P', 'P'], ['Green', 'Blue', 'Green']],
                          names=['state', 'color'])

frame.columns = multi_columns

frame
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>state</th>
      <th>NS</th>
      <th colspan="2" halign="left">P</th>
    </tr>
    <tr>
      <th></th>
      <th>color</th>
      <th>Green</th>
      <th>Blue</th>
      <th>Green</th>
    </tr>
    <tr>
      <th>key1</th>
      <th>key2</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">a</th>
      <th>1</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>4</td>
      <td>5</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>1</th>
      <td>6</td>
      <td>7</td>
      <td>8</td>
    </tr>
    <tr>
      <th>2</th>
      <td>9</td>
      <td>10</td>
      <td>11</td>
    </tr>
  </tbody>
</table>
</div>


### 계층의 순서를 바꾸고 정렬하기

계층적 인덱스에서 계층의 순서를 바꾸거나 지정된 계층에 따라 데이터를 정렬해야 하는 경우가 있을 수 있다. `swaplevel()`은 넘겨받은 두 개의 계층 번호나 이름이 뒤바뀐 새로운 객체를 반환한다(하지만 데이터는 변경되지 않는다).



```python
frame
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>state</th>
      <th colspan="2" halign="left">Ohio</th>
      <th>Colorado</th>
    </tr>
    <tr>
      <th></th>
      <th>color</th>
      <th>Green</th>
      <th>Red</th>
      <th>Green</th>
    </tr>
    <tr>
      <th>key1</th>
      <th>key2</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">a</th>
      <th>1</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>4</td>
      <td>5</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>1</th>
      <td>6</td>
      <td>7</td>
      <td>8</td>
    </tr>
    <tr>
      <th>2</th>
      <td>9</td>
      <td>10</td>
      <td>11</td>
    </tr>
  </tbody>
</table>
</div>



```python
frame.swaplevel('key1', 'key2')
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>state</th>
      <th colspan="2" halign="left">Ohio</th>
      <th>Colorado</th>
    </tr>
    <tr>
      <th></th>
      <th>color</th>
      <th>Green</th>
      <th>Red</th>
      <th>Green</th>
    </tr>
    <tr>
      <th>key2</th>
      <th>key1</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <th>a</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <th>a</th>
      <td>3</td>
      <td>4</td>
      <td>5</td>
    </tr>
    <tr>
      <th>1</th>
      <th>b</th>
      <td>6</td>
      <td>7</td>
      <td>8</td>
    </tr>
    <tr>
      <th>2</th>
      <th>b</th>
      <td>9</td>
      <td>10</td>
      <td>11</td>
    </tr>
  </tbody>
</table>
</div>


반면 `sort_index()` 메서드는 단일 계층에 속한 데이터를 정렬한다. `swaplevel()`을 이용해서 계층을 바꿀 때 `sort_index()`를 사용해서 결과가 사전적으로 정렬되도록 만드는 것도 드물지 않은 일이다.



```python
frame.sort_index(level=1)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>state</th>
      <th colspan="2" halign="left">Ohio</th>
      <th>Colorado</th>
    </tr>
    <tr>
      <th></th>
      <th>color</th>
      <th>Green</th>
      <th>Red</th>
      <th>Green</th>
    </tr>
    <tr>
      <th>key1</th>
      <th>key2</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <th>1</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>b</th>
      <th>1</th>
      <td>6</td>
      <td>7</td>
      <td>8</td>
    </tr>
    <tr>
      <th>a</th>
      <th>2</th>
      <td>3</td>
      <td>4</td>
      <td>5</td>
    </tr>
    <tr>
      <th>b</th>
      <th>2</th>
      <td>9</td>
      <td>10</td>
      <td>11</td>
    </tr>
  </tbody>
</table>
</div>



```python
frame.swaplevel(0, 1).sort_index(level=0)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>state</th>
      <th colspan="2" halign="left">Ohio</th>
      <th>Colorado</th>
    </tr>
    <tr>
      <th></th>
      <th>color</th>
      <th>Green</th>
      <th>Red</th>
      <th>Green</th>
    </tr>
    <tr>
      <th>key2</th>
      <th>key1</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">1</th>
      <th>a</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>b</th>
      <td>6</td>
      <td>7</td>
      <td>8</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">2</th>
      <th>a</th>
      <td>3</td>
      <td>4</td>
      <td>5</td>
    </tr>
    <tr>
      <th>b</th>
      <td>9</td>
      <td>10</td>
      <td>11</td>
    </tr>
  </tbody>
</table>
</div>


객체가 계층적 인덱스로 상위 계층부터 사전식으로 정렬되어 있다면(sort_index(level=0)이나 sort_index()의 결과처럼) 데이터를 선택하는 성능이 훨씬 좋아진다.


### 계층별 요약 통계

데이터프레임과 시리즈의 많은 기술 통계와 요약 통계는 level 옵션을 가지고 있는데, 어떤 한 축에 대해 합을 구하고 싶은 단계를 지정할 수 있는 옵션이다. 앞에서 살펴본 데이터프레임에서 로우나 칼럼을 아래처럼 계층별로 합할 수 있다.



```python
frame.sum(level='key2')
```

<pre>
C:\Users\Sangjin\AppData\Local\Temp\ipykernel_32044\2004046222.py:1: FutureWarning: Using the level keyword in DataFrame and Series aggregations is deprecated and will be removed in a future version. Use groupby instead. df.sum(level=1) should use df.groupby(level=1).sum().
  frame.sum(level='key2')
</pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th>state</th>
      <th colspan="2" halign="left">Ohio</th>
      <th>Colorado</th>
    </tr>
    <tr>
      <th>color</th>
      <th>Green</th>
      <th>Red</th>
      <th>Green</th>
    </tr>
    <tr>
      <th>key2</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>6</td>
      <td>8</td>
      <td>10</td>
    </tr>
    <tr>
      <th>2</th>
      <td>12</td>
      <td>14</td>
      <td>16</td>
    </tr>
  </tbody>
</table>
</div>



```python
frame.sum(level='color', axis=1)
```

<pre>
C:\Users\Sangjin\AppData\Local\Temp\ipykernel_32044\4133796543.py:1: FutureWarning: Using the level keyword in DataFrame and Series aggregations is deprecated and will be removed in a future version. Use groupby instead. df.sum(level=1) should use df.groupby(level=1).sum().
  frame.sum(level='color', axis=1)
</pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>color</th>
      <th>Green</th>
      <th>Red</th>
    </tr>
    <tr>
      <th>key1</th>
      <th>key2</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">a</th>
      <th>1</th>
      <td>2</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>8</td>
      <td>4</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>1</th>
      <td>14</td>
      <td>7</td>
    </tr>
    <tr>
      <th>2</th>
      <td>20</td>
      <td>10</td>
    </tr>
  </tbody>
</table>
</div>


이는 내부적으로 다음처럼 판다스의 groupby 기능을 이용해서 구현되었는데, 판다스에서는 같은 결과를 출력하는 다음을 권고한다. 또한 groupby에 대해서는 후에 알아볼 것이다.



```python
frame.groupby(level='key2').sum()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th>state</th>
      <th colspan="2" halign="left">Ohio</th>
      <th>Colorado</th>
    </tr>
    <tr>
      <th>color</th>
      <th>Green</th>
      <th>Red</th>
      <th>Green</th>
    </tr>
    <tr>
      <th>key2</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>6</td>
      <td>8</td>
      <td>10</td>
    </tr>
    <tr>
      <th>2</th>
      <td>12</td>
      <td>14</td>
      <td>16</td>
    </tr>
  </tbody>
</table>
</div>



```python
frame.groupby(axis=1, level='color').sum()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>color</th>
      <th>Green</th>
      <th>Red</th>
    </tr>
    <tr>
      <th>key1</th>
      <th>key2</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">a</th>
      <th>1</th>
      <td>2</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>8</td>
      <td>4</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>1</th>
      <td>14</td>
      <td>7</td>
    </tr>
    <tr>
      <th>2</th>
      <td>20</td>
      <td>10</td>
    </tr>
  </tbody>
</table>
</div>


### 데이터프레임의 칼럼 사용하기

데이터프레임에서 로우의 인덱스로 하나 이상의 칼럼을 사용하는 것은 드물지 않은 일이다. 아니면 로우의 인덱스를 데이터프레임의 칼럼으로 옮기고 싶을 것이다. 다음은 예제 데이터프레임이다.



```python
frame = pd.DataFrame({'a': range(7), 'b': range(7, 0, -1),
                      'c': ['one', 'one', 'one', 'two', 'two',
                            'two', 'two'],
                      'd': [0, 1, 2, 0, 1, 2, 3]})

frame
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>7</td>
      <td>one</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>6</td>
      <td>one</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>5</td>
      <td>one</td>
      <td>2</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3</td>
      <td>4</td>
      <td>two</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4</td>
      <td>3</td>
      <td>two</td>
      <td>1</td>
    </tr>
    <tr>
      <th>5</th>
      <td>5</td>
      <td>2</td>
      <td>two</td>
      <td>2</td>
    </tr>
    <tr>
      <th>6</th>
      <td>6</td>
      <td>1</td>
      <td>two</td>
      <td>3</td>
    </tr>
  </tbody>
</table>
</div>


데이터프레임의 `set_index()` 함수는 하나 이상의 칼럼을 인덱스로 하는 새로운 데이터프레임을 생성한다.



```python
frame2 = frame.set_index(['c', 'd'])

frame2
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>a</th>
      <th>b</th>
    </tr>
    <tr>
      <th>c</th>
      <th>d</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="3" valign="top">one</th>
      <th>0</th>
      <td>0</td>
      <td>7</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>6</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>5</td>
    </tr>
    <tr>
      <th rowspan="4" valign="top">two</th>
      <th>0</th>
      <td>3</td>
      <td>4</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4</td>
      <td>3</td>
    </tr>
    <tr>
      <th>2</th>
      <td>5</td>
      <td>2</td>
    </tr>
    <tr>
      <th>3</th>
      <td>6</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>


다음처럼 칼럼을 명시적으로 남겨두지 않으면 데이터프레임에서 삭제된다.



```python
frame.set_index(['c', 'd'], drop=False)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
    <tr>
      <th>c</th>
      <th>d</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="3" valign="top">one</th>
      <th>0</th>
      <td>0</td>
      <td>7</td>
      <td>one</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>6</td>
      <td>one</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>5</td>
      <td>one</td>
      <td>2</td>
    </tr>
    <tr>
      <th rowspan="4" valign="top">two</th>
      <th>0</th>
      <td>3</td>
      <td>4</td>
      <td>two</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4</td>
      <td>3</td>
      <td>two</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>5</td>
      <td>2</td>
      <td>two</td>
      <td>2</td>
    </tr>
    <tr>
      <th>3</th>
      <td>6</td>
      <td>1</td>
      <td>two</td>
      <td>3</td>
    </tr>
  </tbody>
</table>
</div>


반면 `reset_index()` 함수는 `set_index()`와 반대되는 개념인데 계층적 인덱스 단계가 칼럼으로 이동한다.



```python
frame2.reset_index()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>c</th>
      <th>d</th>
      <th>a</th>
      <th>b</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>one</td>
      <td>0</td>
      <td>0</td>
      <td>7</td>
    </tr>
    <tr>
      <th>1</th>
      <td>one</td>
      <td>1</td>
      <td>1</td>
      <td>6</td>
    </tr>
    <tr>
      <th>2</th>
      <td>one</td>
      <td>2</td>
      <td>2</td>
      <td>5</td>
    </tr>
    <tr>
      <th>3</th>
      <td>two</td>
      <td>0</td>
      <td>3</td>
      <td>4</td>
    </tr>
    <tr>
      <th>4</th>
      <td>two</td>
      <td>1</td>
      <td>4</td>
      <td>3</td>
    </tr>
    <tr>
      <th>5</th>
      <td>two</td>
      <td>2</td>
      <td>5</td>
      <td>2</td>
    </tr>
    <tr>
      <th>6</th>
      <td>two</td>
      <td>3</td>
      <td>6</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>


## 데이터 합치기

데이터가 여러 군데 나누어져 있을 때 하나로 합치거나 데이터를 연결해야 하는 경우가 있다. 판다스 객체에 저장된 데이터는 다음을 통해 여러 가지 방법으로 합칠 수 있다.

- `pandas.merge()`는 하나 이상의 키를 기준으로 데이터프레임의 로우를 합친다. SQL이나 다른 관계형 데이터베이스의 join 연산과 유사하다.

- `pandas.concat()`은 하나의 축을 따라 객체를 이어붙인다.

- `combine_first` 인스턴스 메서드는 두 객체를 포개서 한 객체에서 누락된 데이터를 다른 객체에 있는 값으로 채울 수 있도록 한다.



각각의 데이터를 합치는 방법에 대해 다양한 예제와 함께 살펴보자.


### 데이터베이스 스타일로 데이터프레임 합치기

<strong>병합</strong>(머지<sup>merge</sup>)이나 <strong>조인</strong><sup>join</sup>연산은 관계형 데이터베이스의 핵심적인 연산인데, 하나 이상의 <strong>키</strong>를 사용해서 데이터 집합의 로우를 합친다. 여기서 말하는 키(key)란 기준이 되는 칼럼이나 인덱스를 뜻한다. 키가 되는 칼럼이나 인덱스는 반드시 양쪽 데이터프레임에 모두 존재해야 한다. 판다스의 `merge()`함수를 이용해서 이런 알고리즘을 데이터에 적용할 수 있다.



```python
df1 = pd.DataFrame({'key': ['b', 'b', 'a', 'c', 'a', 'a', 'b'],
                    'data1': range(7)})
df2 = pd.DataFrame({'key': ['a', 'b', 'd'],
                    'data2': range(3)})
print(df1)
print('\n')
print(df2)
```

<pre>
  key  data1
0   b      0
1   b      1
2   a      2
3   c      3
4   a      4
5   a      5
6   b      6


  key  data2
0   a      0
1   b      1
2   d      2
</pre>
위 예제는 <strong>다대일</strong>의 경우다. df1의 데이터는 key 칼럼에 여러 개의 a, b 로우를 가지고 있고 df2의 데이터는 key 칼럼에 유일한 로우를 가지고 있다. 이 객체에 대해 `merge()` 함수를 호출하면 다음과 같은 결과를 얻는다.



```python
pd.merge(df1, df2)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key</th>
      <th>data1</th>
      <th>data2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>b</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>b</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>b</td>
      <td>6</td>
      <td>1</td>
    </tr>
    <tr>
      <th>3</th>
      <td>a</td>
      <td>2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>a</td>
      <td>4</td>
      <td>0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>a</td>
      <td>5</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>


위의 예시에서는 어떤 칼럼을 기준으로 병합할 것인지 명시하지 않았는데, `merge()` 함수는 중복된 칼럼 이름을 키로 사용한다(위 예에서는 key 칼럼). 하지만 명시적으로 지정해주는 습관을 들이는 게 좋다.



```python
pd.merge(df1, df2, on='key')
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key</th>
      <th>data1</th>
      <th>data2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>b</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>b</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>b</td>
      <td>6</td>
      <td>1</td>
    </tr>
    <tr>
      <th>3</th>
      <td>a</td>
      <td>2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>a</td>
      <td>4</td>
      <td>0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>a</td>
      <td>5</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>


만약 두 객체에 중복된 칼럼 이름이 하나도 없다면 따로 지정해주면 된다.



```python
df3 = pd.DataFrame({'lkey': ['b', 'b', 'a', 'c', 'a', 'a', 'b'],
                    'data1': range(7)})
df4 = pd.DataFrame({'rkey': ['a', 'b', 'd'],
                    'data2': range(3)})

pd.merge(df3, df4, left_on='lkey', right_on='rkey')
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>lkey</th>
      <th>data1</th>
      <th>rkey</th>
      <th>data2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>b</td>
      <td>0</td>
      <td>b</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>b</td>
      <td>1</td>
      <td>b</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>b</td>
      <td>6</td>
      <td>b</td>
      <td>1</td>
    </tr>
    <tr>
      <th>3</th>
      <td>a</td>
      <td>2</td>
      <td>a</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>a</td>
      <td>4</td>
      <td>a</td>
      <td>0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>a</td>
      <td>5</td>
      <td>a</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>


결과를 잘 살펴보면 'c'와 'd'에 해당하는 값이 빠진 것을 알 수 있다. `merge()` 함수는 기본적으로 내부 조인<sup>inner join</sup>을 수행하여 교집합인 결과를 반환한다. how 인자로 'left', 'right', 'outer'를 넘겨서 각각 왼쪽 조인, 오른쪽 조인, 외부 조인을 수행할 수도 있다. 외부 조인은 합집합인 결과를 반환하고 왼쪽 조인과 오른쪽 조인은 각각 왼쪽 또는 오른쪽의 모든 로우를 포함하는 결과를 반환한다.



```python
pd.merge(df1, df2, on='key', how='outer')
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key</th>
      <th>data1</th>
      <th>data2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>b</td>
      <td>0.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>b</td>
      <td>1.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>b</td>
      <td>6.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>a</td>
      <td>2.0</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>a</td>
      <td>4.0</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>a</td>
      <td>5.0</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>6</th>
      <td>c</td>
      <td>3.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>7</th>
      <td>d</td>
      <td>NaN</td>
      <td>2.0</td>
    </tr>
  </tbody>
</table>
</div>


다음은 how 옵션에 따라 조인 연산이 어떻게 동작하는지 요약한 것이다.

<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-ehbx{background-color:#9698ed;border-color:inherit;font-weight:bold;text-align:left;vertical-align:top}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-ehbx">옵션</th>
    <th class="tg-ehbx">동작</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0pky">'inner'</td>
    <td class="tg-0pky">양쪽 테이블 모두에 존재하는 키 조합을 사용한다.</td>
  </tr>
  <tr>
    <td class="tg-0pky">'left'</td>
    <td class="tg-0pky">왼쪽 테이블에 존재하는 모든 키 조합을 사용한다.</td>
  </tr>
  <tr>
    <td class="tg-0pky">'right'</td>
    <td class="tg-0pky">오른쪽 테이블에 존재하는 모든 키 조합을 사용한다.</td>
  </tr>
  <tr>
    <td class="tg-0pky">'outer'</td>
    <td class="tg-0pky">양쪽 테이블에 존재하는 모든 키 조합을 사용한다.</td>
  </tr>
</tbody>
</table>


<strong>다대다</strong> 병합은 잘 정의되어 있긴 하지만 직관적이지는 않다.



```python
df1 = pd.DataFrame({'key': ['b', 'b', 'a', 'c', 'a', 'b'],
                    'data1': range(6)})
df2 = pd.DataFrame({'key': ['a', 'b', 'a', 'b', 'd'],
                    'data2': range(5)})

print(df1)
print('\n')
print(df2)
```

<pre>
  key  data1
0   b      0
1   b      1
2   a      2
3   c      3
4   a      4
5   b      5


  key  data2
0   a      0
1   b      1
2   a      2
3   b      3
4   d      4
</pre>

```python
pd.merge(df1, df2, on='key', how='left')
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key</th>
      <th>data1</th>
      <th>data2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>b</td>
      <td>0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>b</td>
      <td>0</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>b</td>
      <td>1</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>b</td>
      <td>1</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>a</td>
      <td>2</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>a</td>
      <td>2</td>
      <td>2.0</td>
    </tr>
    <tr>
      <th>6</th>
      <td>c</td>
      <td>3</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>7</th>
      <td>a</td>
      <td>4</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>8</th>
      <td>a</td>
      <td>4</td>
      <td>2.0</td>
    </tr>
    <tr>
      <th>9</th>
      <td>b</td>
      <td>5</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>10</th>
      <td>b</td>
      <td>5</td>
      <td>3.0</td>
    </tr>
  </tbody>
</table>
</div>


다대다 조인은 두 로우의 데카르트곱을 반환한다. 왼쪽 데이터프레임에는 3개의 'b' 로우가 있고 오른쪽에는 2개의 'b' 로우가 있으며, 결과는 6개의 'b' 로우가 된다. 조인 메서드는 결과에 나타나는 구별되는 키에 대해서만 적용된다.



```python
pd.merge(df1, df2, how='inner')
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key</th>
      <th>data1</th>
      <th>data2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>b</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>b</td>
      <td>0</td>
      <td>3</td>
    </tr>
    <tr>
      <th>2</th>
      <td>b</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>3</th>
      <td>b</td>
      <td>1</td>
      <td>3</td>
    </tr>
    <tr>
      <th>4</th>
      <td>b</td>
      <td>5</td>
      <td>1</td>
    </tr>
    <tr>
      <th>5</th>
      <td>b</td>
      <td>5</td>
      <td>3</td>
    </tr>
    <tr>
      <th>6</th>
      <td>a</td>
      <td>2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>7</th>
      <td>a</td>
      <td>2</td>
      <td>2</td>
    </tr>
    <tr>
      <th>8</th>
      <td>a</td>
      <td>4</td>
      <td>0</td>
    </tr>
    <tr>
      <th>9</th>
      <td>a</td>
      <td>4</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
</div>


여러 개의 키를 기준으로 병합하려면 칼럼 이름이 담긴 리스트를 넘기면 된다.



```python
left = pd.DataFrame({'key1': ['foo', 'foo', 'bar'],
                     'key2': ['one', 'two', 'one'],
                     'lval': [1, 2, 3]})
right = pd.DataFrame({'key1': ['foo', 'foo', 'bar', 'bar'],
                      'key2': ['one', 'one', 'one', 'two'],
                      'rval': [4, 5, 6, 7]})
print(left)
print('\n')
print(right)
```

<pre>
  key1 key2  lval
0  foo  one     1
1  foo  two     2
2  bar  one     3


  key1 key2  rval
0  foo  one     4
1  foo  one     5
2  bar  one     6
3  bar  two     7
</pre>

```python
pd.merge(left, right, on=['key1', 'key2'], how='outer')
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key1</th>
      <th>key2</th>
      <th>lval</th>
      <th>rval</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>foo</td>
      <td>one</td>
      <td>1.0</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>foo</td>
      <td>one</td>
      <td>1.0</td>
      <td>5.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>foo</td>
      <td>two</td>
      <td>2.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>3</th>
      <td>bar</td>
      <td>one</td>
      <td>3.0</td>
      <td>6.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>bar</td>
      <td>two</td>
      <td>NaN</td>
      <td>7.0</td>
    </tr>
  </tbody>
</table>
</div>


`merge()` 메서드의 종류에 따라 어떤 키 조합이 결과로 반환되는지 알려면 실제 구현과는 조금 다르지만 여러 개의 키가 들어 있는 튜플의 배열이 단일 조인키로 사용된다고 생각하면 된다.<br><br>

칼럼과 칼럼을 조인할 때 전달한 데이터프레임 객체의 인덱스는 무시된다.<br><br>

병합 연산에서 고려해야 할 마지막 사항은 겹치는 칼럼 이름에 대한 처리다. 다음에서 살펴보겠지만 축 이름을 변경해서 수동으로 칼럼 이름이 겹치게 할 수도 있고, `merge()` 함수에 있는 suffixes 인자로 두 데이터프레임 객체에서 겹치는 칼럼 이름 뒤에 붙일 문자열을 지정해줄 수도 있다.



```python
pd.merge(left, right, on='key1')
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key1</th>
      <th>key2_x</th>
      <th>lval</th>
      <th>key2_y</th>
      <th>rval</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>foo</td>
      <td>one</td>
      <td>1</td>
      <td>one</td>
      <td>4</td>
    </tr>
    <tr>
      <th>1</th>
      <td>foo</td>
      <td>one</td>
      <td>1</td>
      <td>one</td>
      <td>5</td>
    </tr>
    <tr>
      <th>2</th>
      <td>foo</td>
      <td>two</td>
      <td>2</td>
      <td>one</td>
      <td>4</td>
    </tr>
    <tr>
      <th>3</th>
      <td>foo</td>
      <td>two</td>
      <td>2</td>
      <td>one</td>
      <td>5</td>
    </tr>
    <tr>
      <th>4</th>
      <td>bar</td>
      <td>one</td>
      <td>3</td>
      <td>one</td>
      <td>6</td>
    </tr>
    <tr>
      <th>5</th>
      <td>bar</td>
      <td>one</td>
      <td>3</td>
      <td>two</td>
      <td>7</td>
    </tr>
  </tbody>
</table>
</div>



```python
pd.merge(left, right, on='key1', suffixes=('_left', '_right'))
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key1</th>
      <th>key2_left</th>
      <th>lval</th>
      <th>key2_right</th>
      <th>rval</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>foo</td>
      <td>one</td>
      <td>1</td>
      <td>one</td>
      <td>4</td>
    </tr>
    <tr>
      <th>1</th>
      <td>foo</td>
      <td>one</td>
      <td>1</td>
      <td>one</td>
      <td>5</td>
    </tr>
    <tr>
      <th>2</th>
      <td>foo</td>
      <td>two</td>
      <td>2</td>
      <td>one</td>
      <td>4</td>
    </tr>
    <tr>
      <th>3</th>
      <td>foo</td>
      <td>two</td>
      <td>2</td>
      <td>one</td>
      <td>5</td>
    </tr>
    <tr>
      <th>4</th>
      <td>bar</td>
      <td>one</td>
      <td>3</td>
      <td>one</td>
      <td>6</td>
    </tr>
    <tr>
      <th>5</th>
      <td>bar</td>
      <td>one</td>
      <td>3</td>
      <td>two</td>
      <td>7</td>
    </tr>
  </tbody>
</table>
</div>


다음은 `merge()` 함수의 인자를 정리한 것이다.

<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-ehbx{background-color:#9698ed;border-color:inherit;font-weight:bold;text-align:left;vertical-align:top}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-ehbx">인자</th>
    <th class="tg-ehbx">동작</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0pky">left</td>
    <td class="tg-0pky">병합하려는 데이터프레임 중 왼쪽에 위치한 데이터프레임</td>
  </tr>
  <tr>
    <td class="tg-0pky">right</td>
    <td class="tg-0pky">병합하려는 데이터프레임 중 오른쪽에 위치한 데이터프레임</td>
  </tr>
  <tr>
    <td class="tg-0pky">how</td>
    <td class="tg-0pky">조인 방법. inner', 'outer', 'left', 'right'. 기본값은 'inner'</td>
  </tr>
  <tr>
    <td class="tg-0pky">on</td>
    <td class="tg-0pky">조인하려는 칼럼 이름. 반드시 두 데이터프레임 객체 모두에 존재하는 이럼이어야 한다. 만약 명시되지 않고 다른 조인키도 주어지지 않으면 left와 right에서 공통되는 칼럼을 조인키로 사용한다.</td>
  </tr>
  <tr>
    <td class="tg-0lax">left_on</td>
    <td class="tg-0lax">조인키로 사용할 left 데이터프레임의 칼럼</td>
  </tr>
  <tr>
    <td class="tg-0lax">right_on</td>
    <td class="tg-0lax">조인키로 사용할 right 데이터프레임의 칼럼</td>
  </tr>
  <tr>
    <td class="tg-0lax">left_index</td>
    <td class="tg-0lax">조인키로 사용할 left 데이터프레임의 인덱스 로우(다중 인덱스일 경우 키)</td>
  </tr>
  <tr>
    <td class="tg-0lax">right_index</td>
    <td class="tg-0lax">조인키로 사용할 right 데이터프레임의 인덱스 로우(다중 인덱스일 경우 키)</td>
  </tr>
  <tr>
    <td class="tg-0lax">sort</td>
    <td class="tg-0lax">조인키에 따라 병합된 데이터를 사전순으로 정렬. 기본값은 True. 대용량 데이터의 경우 False로 하면 성능상의 이득을 얻을 수 있다.</td>
  </tr>
  <tr>
    <td class="tg-0lax">suffixes</td>
    <td class="tg-0lax">칼럼 이름이 겹칠 경우 각 칼럼 이름 뒤에 붙일 문자열의 튜플. 기본값은 ('_x', '_y'). </td>
  </tr>
  <tr>
    <td class="tg-0lax">copy</td>
    <td class="tg-0lax">False일 경우. 예외적인 경우에 데이터가 결과로 복사되지 않도록 한다. 기본값은 항상 복사가 이루어진다.</td>
  </tr>
  <tr>
    <td class="tg-0lax">indicator</td>
    <td class="tg-0lax">merge라는 이름의 특별한 칼럼을 추가하여 각 로우의 소스가 어디인지 나타낸다. 'left_only', 'right_only', 'both' 값을 가진다.</td>
  </tr>
</tbody>
</table>


### 로우 인덱스 병합하기

병합하려는 키가 데이터프레임의 인덱스일 경우가 있다. 이런 경우에는 left_index=True 혹은 right_index=True 옵션(또는 둘 다)을 지정해서 해당 인덱스를 병합키로 사용할 수 있다.



```python
left1 = pd.DataFrame({'key': ['a', 'b', 'a', 'a', 'b', 'c'],
                      'value': range(6)})
right1 = pd.DataFrame({'group_val': [3.5, 7]}, index=['a', 'b'])

print(left1)
print('\n')
print(right1)
```

<pre>
  key  value
0   a      0
1   b      1
2   a      2
3   a      3
4   b      4
5   c      5


   group_val
a        3.5
b        7.0
</pre>

```python
pd.merge(left1, right1, left_on='key', right_index=True)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key</th>
      <th>value</th>
      <th>group_val</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>a</td>
      <td>0</td>
      <td>3.5</td>
    </tr>
    <tr>
      <th>2</th>
      <td>a</td>
      <td>2</td>
      <td>3.5</td>
    </tr>
    <tr>
      <th>3</th>
      <td>a</td>
      <td>3</td>
      <td>3.5</td>
    </tr>
    <tr>
      <th>1</th>
      <td>b</td>
      <td>1</td>
      <td>7.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>b</td>
      <td>4</td>
      <td>7.0</td>
    </tr>
  </tbody>
</table>
</div>


병합은 기본적으로 교집합을 구하지만 외부 조인을 실행해서 합집합을 구할 수도 있다.



```python
pd.merge(left1, right1, left_on='key', right_index=True, how='outer')
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key</th>
      <th>value</th>
      <th>group_val</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>a</td>
      <td>0</td>
      <td>3.5</td>
    </tr>
    <tr>
      <th>2</th>
      <td>a</td>
      <td>2</td>
      <td>3.5</td>
    </tr>
    <tr>
      <th>3</th>
      <td>a</td>
      <td>3</td>
      <td>3.5</td>
    </tr>
    <tr>
      <th>1</th>
      <td>b</td>
      <td>1</td>
      <td>7.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>b</td>
      <td>4</td>
      <td>7.0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>c</td>
      <td>5</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>


멀티 인덱스 데이터는 암묵적으로 여러 키를 병합하는 것이라 약간 복잡하다.



```python
lefth = pd.DataFrame({'key1': ['Ohio', 'Ohio', 'Ohio',
                               'Nevada', 'Nevada'],
                      'key2': [2000, 2001, 2002, 2001, 2002],
                      'data': np.arange(5.)})
righth = pd.DataFrame(np.arange(12).reshape((6, 2)),
                      index=[['Nevada', 'Nevada', 'Ohio', 'Ohio',
                              'Ohio', 'Ohio'],
                             [2001, 2000, 2000, 2000, 2001, 2002]],
                      columns=['event1', 'event2'])
print(lefth)
print('\n')
print(righth)
```

<pre>
     key1  key2  data
0    Ohio  2000   0.0
1    Ohio  2001   1.0
2    Ohio  2002   2.0
3  Nevada  2001   3.0
4  Nevada  2002   4.0


             event1  event2
Nevada 2001       0       1
       2000       2       3
Ohio   2000       4       5
       2000       6       7
       2001       8       9
       2002      10      11
</pre>
이 경우에는 리스트로 여러 개의 칼럼을 지정해서 병합해야 한다(중복되는 인덱스값을 다룰 때는 how='outer' 옵션을 사용해야 한다).



```python
pd.merge(lefth, righth, left_on=['key1', 'key2'], right_index=True)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key1</th>
      <th>key2</th>
      <th>data</th>
      <th>event1</th>
      <th>event2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Ohio</td>
      <td>2000</td>
      <td>0.0</td>
      <td>4</td>
      <td>5</td>
    </tr>
    <tr>
      <th>0</th>
      <td>Ohio</td>
      <td>2000</td>
      <td>0.0</td>
      <td>6</td>
      <td>7</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Ohio</td>
      <td>2001</td>
      <td>1.0</td>
      <td>8</td>
      <td>9</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Ohio</td>
      <td>2002</td>
      <td>2.0</td>
      <td>10</td>
      <td>11</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Nevada</td>
      <td>2001</td>
      <td>3.0</td>
      <td>0</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>



```python
pd.merge(lefth, righth, left_on=['key1', 'key2'],
         right_index=True, how='outer')
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key1</th>
      <th>key2</th>
      <th>data</th>
      <th>event1</th>
      <th>event2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Ohio</td>
      <td>2000</td>
      <td>0.0</td>
      <td>4.0</td>
      <td>5.0</td>
    </tr>
    <tr>
      <th>0</th>
      <td>Ohio</td>
      <td>2000</td>
      <td>0.0</td>
      <td>6.0</td>
      <td>7.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Ohio</td>
      <td>2001</td>
      <td>1.0</td>
      <td>8.0</td>
      <td>9.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Ohio</td>
      <td>2002</td>
      <td>2.0</td>
      <td>10.0</td>
      <td>11.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Nevada</td>
      <td>2001</td>
      <td>3.0</td>
      <td>0.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Nevada</td>
      <td>2002</td>
      <td>4.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Nevada</td>
      <td>2000</td>
      <td>NaN</td>
      <td>2.0</td>
      <td>3.0</td>
    </tr>
  </tbody>
</table>
</div>


양쪽에 공통적으로 존재하는 여러 개의 인덱스를 병합하는 것도 가능하다.



```python
left2 = pd.DataFrame([[1., 2.], [3., 4.], [5., 6.]],
                     index=['a', 'c', 'e'],
                     columns=['Ohio', 'Nevada'])
right2 = pd.DataFrame([[7., 8.], [9., 10.], [11., 12.], [13, 14]],
                      index=['b', 'c', 'd', 'e'],
                      columns=['Missouri', 'Alabama'])
print(left2)
print('\n')
print(right2)
```

<pre>
   Ohio  Nevada
a   1.0     2.0
c   3.0     4.0
e   5.0     6.0


   Missouri  Alabama
b       7.0      8.0
c       9.0     10.0
d      11.0     12.0
e      13.0     14.0
</pre>

```python
pd.merge(left2, right2, how='outer', left_index=True, right_index=True)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Ohio</th>
      <th>Nevada</th>
      <th>Missouri</th>
      <th>Alabama</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>1.0</td>
      <td>2.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>b</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>7.0</td>
      <td>8.0</td>
    </tr>
    <tr>
      <th>c</th>
      <td>3.0</td>
      <td>4.0</td>
      <td>9.0</td>
      <td>10.0</td>
    </tr>
    <tr>
      <th>d</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>11.0</td>
      <td>12.0</td>
    </tr>
    <tr>
      <th>e</th>
      <td>5.0</td>
      <td>6.0</td>
      <td>13.0</td>
      <td>14.0</td>
    </tr>
  </tbody>
</table>
</div>


로우 인덱스로 병합할 때 데이터프레임의 `join()` 메서드를 사용하면 편리하다. `join()` 메서드는 칼럼이 겹치지 않으며 완전히 같거나 유사한 인덱스 구조를 가진 여러 개의 데이터프레임 객체를 병합할 때 사용할 수 있다. 위에서 본 예제는 다음처럼 작성할 수 있다.



```python
left2.join(right2, how='outer')
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Ohio</th>
      <th>Nevada</th>
      <th>Missouri</th>
      <th>Alabama</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>1.0</td>
      <td>2.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>b</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>7.0</td>
      <td>8.0</td>
    </tr>
    <tr>
      <th>c</th>
      <td>3.0</td>
      <td>4.0</td>
      <td>9.0</td>
      <td>10.0</td>
    </tr>
    <tr>
      <th>d</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>11.0</td>
      <td>12.0</td>
    </tr>
    <tr>
      <th>e</th>
      <td>5.0</td>
      <td>6.0</td>
      <td>13.0</td>
      <td>14.0</td>
    </tr>
  </tbody>
</table>
</div>


과거에 작성된 판다스의 일부 코드 제약으로 인해 데이터프레임의 `join()` 메서드는 왼쪽 조인을 수행한다. 즉, left1에 `join()` 메서드를 적용하면서 right1을 인자로 전달하면 왼쪽에 위치한 left1의 행 인덱스를 기준으로 결합하는 how='left' 옵션이 기본 적용된다. `join()` 메서드를 호출한 데이터프레임의 칼럼 중 하나에 대해 조인을 수행하는 것도 가능하다.



```python
left1.join(right1, on='key')
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key</th>
      <th>value</th>
      <th>group_val</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>a</td>
      <td>0</td>
      <td>3.5</td>
    </tr>
    <tr>
      <th>1</th>
      <td>b</td>
      <td>1</td>
      <td>7.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>a</td>
      <td>2</td>
      <td>3.5</td>
    </tr>
    <tr>
      <th>3</th>
      <td>a</td>
      <td>3</td>
      <td>3.5</td>
    </tr>
    <tr>
      <th>4</th>
      <td>b</td>
      <td>4</td>
      <td>7.0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>c</td>
      <td>5</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>


마지막으로 인덱스 대 인덱스로 두 데이터프레임을 병합하려면 그냥 간단하게 병합하려는 데이터프레임의 리스트를 `join()` 메서드로 넘기면 된다. 하지만 보통 이런 병합은 아래에서 살펴볼 `concat()`메서드를 사용한다.



```python
another = pd.DataFrame([[7., 8.], [9., 10.], [11., 12.], [16., 17.]],
                       index=['a', 'c', 'e', 'f'], 
                       columns=['New York', 'Oregon'])
print(left2)
print('\n')
print(right2)
print('\n')
print(another)
```

<pre>
   Ohio  Nevada
a   1.0     2.0
c   3.0     4.0
e   5.0     6.0


   Missouri  Alabama
b       7.0      8.0
c       9.0     10.0
d      11.0     12.0
e      13.0     14.0


   New York  Oregon
a       7.0     8.0
c       9.0    10.0
e      11.0    12.0
f      16.0    17.0
</pre>

```python
left2.join([right2, another])
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Ohio</th>
      <th>Nevada</th>
      <th>Missouri</th>
      <th>Alabama</th>
      <th>New York</th>
      <th>Oregon</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>1.0</td>
      <td>2.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>7.0</td>
      <td>8.0</td>
    </tr>
    <tr>
      <th>c</th>
      <td>3.0</td>
      <td>4.0</td>
      <td>9.0</td>
      <td>10.0</td>
      <td>9.0</td>
      <td>10.0</td>
    </tr>
    <tr>
      <th>e</th>
      <td>5.0</td>
      <td>6.0</td>
      <td>13.0</td>
      <td>14.0</td>
      <td>11.0</td>
      <td>12.0</td>
    </tr>
  </tbody>
</table>
</div>



```python
left2.join([right2, another], how='outer')
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Ohio</th>
      <th>Nevada</th>
      <th>Missouri</th>
      <th>Alabama</th>
      <th>New York</th>
      <th>Oregon</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>1.0</td>
      <td>2.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>7.0</td>
      <td>8.0</td>
    </tr>
    <tr>
      <th>c</th>
      <td>3.0</td>
      <td>4.0</td>
      <td>9.0</td>
      <td>10.0</td>
      <td>9.0</td>
      <td>10.0</td>
    </tr>
    <tr>
      <th>e</th>
      <td>5.0</td>
      <td>6.0</td>
      <td>13.0</td>
      <td>14.0</td>
      <td>11.0</td>
      <td>12.0</td>
    </tr>
    <tr>
      <th>b</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>7.0</td>
      <td>8.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>d</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>11.0</td>
      <td>12.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>f</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>16.0</td>
      <td>17.0</td>
    </tr>
  </tbody>
</table>
</div>


### 축 따라 이어붙이기

서로 다른 데이터프레임들의 구성 형태와 속성이 균일하다면, 행 또는 열 중에 어느 한 방향으로 이어 붙여도 데이터의 일관성을 유지할 수 있다.<br><br>

데이터를 합치는 또 다른 방법으로 이어붙이기<sup>concatenation</sup>(연결<sup>binding</sup>, 적층<sup>stacking</sup>이라고 한다)가 있다. NumPy는 ndarray를 이어붙이는 `concatenate()` 함수를 제공한다.



```python
arr = np.arange(12).reshape((3, 4))

arr
```

<pre>
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</pre>

```python
np.concatenate([arr, arr], axis=0)
```

<pre>
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</pre>

```python
np.concatenate([arr, arr], axis=1)
```

<pre>
array([[ 0,  1,  2,  3,  0,  1,  2,  3],
       [ 4,  5,  6,  7,  4,  5,  6,  7],
       [ 8,  9, 10, 11,  8,  9, 10, 11]])
</pre>
시리즈나 데이터프레임 같은 판다스 객체의 컨텍스트 내부에는 축마다 이름이 있어서 배열을 쉽게 이어붙일 수 있도록 되어 있다. 이때 다음 사항을 고려해야 한다.

- 만약 연결하려는 두 객체의 인덱스가 서로 다르면 결과는 그 인덱스의 교집합이어야 하는가 아니면 합집합이어야 하는가?

- 합쳐진 결과에서 합쳐지기 전 객체의 데이터를 구분할 수 있어야 하는가?

- 어떤 축으로 연결할 것인지 고려해야 하는가? 많은 경우 데이터프레임의 기본 정수 라벨이 가장 먼저 무시된다.



판다스의 `concat()` 함수는 위 사항에 대한 답을 제공한다. `concat()` 함수가 어떻게 동작하는지 다양한 예제로 알아보자. 인덱스가 겹치지 않는 3개의 시리즈 객체가 있다고 하자.



```python
s1 = pd.Series([0, 1], index=['a', 'b'])
s2 = pd.Series([2, 3, 4], index=['c', 'd', 'e'])
s3 = pd.Series([5, 6], index=['f', 'g'])

display(s1)
display(s2)
display(s3)
```

<pre>
a    0
b    1
dtype: int64
</pre>
<pre>
c    2
d    3
e    4
dtype: int64
</pre>
<pre>
f    5
g    6
dtype: int64
</pre>
이 세 객체를 리스트로 묶어서 `concat()` 함수에 전달하면 값과 인덱스를 연결해준다.



```python
pd.concat([s1, s2, s3])
```

<pre>
a    0
b    1
c    2
d    3
e    4
f    5
g    6
dtype: int64
</pre>
`concat()` 함수는 axis=0을 기본값으로 하여 새로운 시리즈 객체를 생성한다. 만약 axis=1을 넘긴다면 결과는 시리즈가 아니라 데이터프레임이 될 것이다(axis=1은 칼럼을 의미한다).



```python
pd.concat([s1, s2, s3], axis=1)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>0.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>b</th>
      <td>1.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>c</th>
      <td>NaN</td>
      <td>2.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>d</th>
      <td>NaN</td>
      <td>3.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>e</th>
      <td>NaN</td>
      <td>4.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>f</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>5.0</td>
    </tr>
    <tr>
      <th>g</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>6.0</td>
    </tr>
  </tbody>
</table>
</div>


겹치는 축이 없기 때문에 외부 조인으로 정렬된 합집합을 얻었지만 join='inner'를 넘겨서 교집합을 구할 수도 있다.



```python
s4 = pd.concat([s1, s3])

s4
```

<pre>
a    0
b    1
f    5
g    6
dtype: int64
</pre>

```python
pd.concat([s1, s4], axis=1)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>0.0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>b</th>
      <td>1.0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>f</th>
      <td>NaN</td>
      <td>5</td>
    </tr>
    <tr>
      <th>g</th>
      <td>NaN</td>
      <td>6</td>
    </tr>
  </tbody>
</table>
</div>



```python
pd.concat([s1, s4], axis=1, join='inner')
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>b</th>
      <td>1</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>


마지막 예제에서 'f'와 'g' 라벨은 join='inner' 옵션으로 인해 사라지게 된다.<br><br>

시리즈를 이어붙이기 전의 개별 시리즈를 구분할 수 없는 문제가 생기는데, 이어붙인 축에 대해 계층적 인덱스를 생성하여 식별이 가능하도록 할 수 있다. 계층적 인덱스를 생성하려면 keys 인자를 사용하면 된다.



```python
result = pd.concat([s1, s1, s3], keys=['one', 'two', 'three'])

result
```

<pre>
one    a    0
       b    1
two    a    0
       b    1
three  f    5
       g    6
dtype: int64
</pre>

```python
result.index
```

<pre>
MultiIndex([(  'one', 'a'),
            (  'one', 'b'),
            (  'two', 'a'),
            (  'two', 'b'),
            ('three', 'f'),
            ('three', 'g')],
           )
</pre>

```python
result.unstack()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>f</th>
      <th>g</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>one</th>
      <td>0.0</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>two</th>
      <td>0.0</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>three</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>5.0</td>
      <td>6.0</td>
    </tr>
  </tbody>
</table>
</div>


시리즈를 axis=1로 병합할 경우 keys는 데이터프레임의 칼럼 제목이 된다.



```python
pd.concat([s1, s2, s3], axis=1, keys=['one', 'two', 'three'])
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>one</th>
      <th>two</th>
      <th>three</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>0.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>b</th>
      <td>1.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>c</th>
      <td>NaN</td>
      <td>2.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>d</th>
      <td>NaN</td>
      <td>3.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>e</th>
      <td>NaN</td>
      <td>4.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>f</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>5.0</td>
    </tr>
    <tr>
      <th>g</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>6.0</td>
    </tr>
  </tbody>
</table>
</div>


데이터프레임 객체에 대해서도 지금까지와 같은 방식으로 적용할 수 있다.



```python
df1 = pd.DataFrame(np.arange(6).reshape((3, 2)), index=['a', 'b', 'c'],
                   columns=['one', 'two'])
df2 = pd.DataFrame(5 + np.arange(4).reshape((2, 2)), index=['a', 'c'],
                   columns=['three', 'four'])

display(df1)
display(df2)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>one</th>
      <th>two</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>b</th>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>c</th>
      <td>4</td>
      <td>5</td>
    </tr>
  </tbody>
</table>
</div>


<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>three</th>
      <th>four</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>5</td>
      <td>6</td>
    </tr>
    <tr>
      <th>c</th>
      <td>7</td>
      <td>8</td>
    </tr>
  </tbody>
</table>
</div>



```python
pd.concat([df1, df2], axis=1, keys=['level1', 'level2'])
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th colspan="2" halign="left">level1</th>
      <th colspan="2" halign="left">level2</th>
    </tr>
    <tr>
      <th></th>
      <th>one</th>
      <th>two</th>
      <th>three</th>
      <th>four</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>0</td>
      <td>1</td>
      <td>5.0</td>
      <td>6.0</td>
    </tr>
    <tr>
      <th>b</th>
      <td>2</td>
      <td>3</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>c</th>
      <td>4</td>
      <td>5</td>
      <td>7.0</td>
      <td>8.0</td>
    </tr>
  </tbody>
</table>
</div>


리스트 대신 객체의 사전을 넘기면 사전의 키가 keys 옵션으로 사용된다.



```python
pd.concat({'level1': df1, 'level2': df2}, axis=1)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th colspan="2" halign="left">level1</th>
      <th colspan="2" halign="left">level2</th>
    </tr>
    <tr>
      <th></th>
      <th>one</th>
      <th>two</th>
      <th>three</th>
      <th>four</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>0</td>
      <td>1</td>
      <td>5.0</td>
      <td>6.0</td>
    </tr>
    <tr>
      <th>b</th>
      <td>2</td>
      <td>3</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>c</th>
      <td>4</td>
      <td>5</td>
      <td>7.0</td>
      <td>8.0</td>
    </tr>
  </tbody>
</table>
</div>


계층적 인덱스를 생성할 때 사용할 수 있는 몇 가지 추가적인 옵션은 밑의 표를 참조하자. 예를 들어 새로 생성된 계층의 이름은 names 인자로 지정할 수 있다.



```python
pd.concat([df1, df2], axis=1, keys=['level1', 'level2'], names=['upper', 'lower'])
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th>upper</th>
      <th colspan="2" halign="left">level1</th>
      <th colspan="2" halign="left">level2</th>
    </tr>
    <tr>
      <th>lower</th>
      <th>one</th>
      <th>two</th>
      <th>three</th>
      <th>four</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>0</td>
      <td>1</td>
      <td>5.0</td>
      <td>6.0</td>
    </tr>
    <tr>
      <th>b</th>
      <td>2</td>
      <td>3</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>c</th>
      <td>4</td>
      <td>5</td>
      <td>7.0</td>
      <td>8.0</td>
    </tr>
  </tbody>
</table>
</div>


마지막으로 데이터프레임의 로우 인덱스가 분석에 필요한 데이터를 포함하고 있지 않은 경우 어떻게 할 것인가?



```python
df1 = pd.DataFrame(np.random.randn(3, 4), columns=['a', 'b', 'c', 'd'])
df2 = pd.DataFrame(np.random.randn(2, 3), columns=['b', 'd', 'a'])

display(df1)
display(df2)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.082446</td>
      <td>-0.361550</td>
      <td>1.677819</td>
      <td>1.552201</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1.135325</td>
      <td>-1.519708</td>
      <td>0.201073</td>
      <td>-0.229441</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-0.421589</td>
      <td>1.990136</td>
      <td>0.800249</td>
      <td>-0.306256</td>
    </tr>
  </tbody>
</table>
</div>


<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>b</th>
      <th>d</th>
      <th>a</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1.633717</td>
      <td>0.630153</td>
      <td>-0.098665</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1.994450</td>
      <td>-0.548019</td>
      <td>0.007595</td>
    </tr>
  </tbody>
</table>
</div>


다음과 같이 인덱스가 0, 1, 2, 0, 1로 유용하지 않은 인덱스를 갖고 있다.



```python
pd.concat([df1, df2])
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.082446</td>
      <td>-0.361550</td>
      <td>1.677819</td>
      <td>1.552201</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1.135325</td>
      <td>-1.519708</td>
      <td>0.201073</td>
      <td>-0.229441</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-0.421589</td>
      <td>1.990136</td>
      <td>0.800249</td>
      <td>-0.306256</td>
    </tr>
    <tr>
      <th>0</th>
      <td>-0.098665</td>
      <td>1.633717</td>
      <td>NaN</td>
      <td>0.630153</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.007595</td>
      <td>1.994450</td>
      <td>NaN</td>
      <td>-0.548019</td>
    </tr>
  </tbody>
</table>
</div>


이 경우 ignore_index=True 옵션을 주면 된다.



```python
pd.concat([df1, df2], ignore_index=True)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.082446</td>
      <td>-0.361550</td>
      <td>1.677819</td>
      <td>1.552201</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1.135325</td>
      <td>-1.519708</td>
      <td>0.201073</td>
      <td>-0.229441</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-0.421589</td>
      <td>1.990136</td>
      <td>0.800249</td>
      <td>-0.306256</td>
    </tr>
    <tr>
      <th>3</th>
      <td>-0.098665</td>
      <td>1.633717</td>
      <td>NaN</td>
      <td>0.630153</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.007595</td>
      <td>1.994450</td>
      <td>NaN</td>
      <td>-0.548019</td>
    </tr>
  </tbody>
</table>
</div>


다음은 `concat()` 함수의 인자를 정리한 것이다.

<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-ehbx{background-color:#9698ed;border-color:inherit;font-weight:bold;text-align:left;vertical-align:top}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-ehbx">인자</th>
    <th class="tg-ehbx">설명</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0pky">objs</td>
    <td class="tg-0pky">이어붙일 판다스 객체의 사전이나 리스트. 필수 인자</td>
  </tr>
  <tr>
    <td class="tg-0pky">axis</td>
    <td class="tg-0pky">이어붙일 축 방향. 기본값은 0</td>
  </tr>
  <tr>
    <td class="tg-0pky">join</td>
    <td class="tg-0pky">조인 방식. 'inner'(내부 조인, 교집합)과 'outer'(외부 조인, 합집합)가 있으며 기본값은 'outer'</td>
  </tr>
  <tr>
    <td class="tg-0pky">keys</td>
    <td class="tg-0pky">이어붙일 객체나 이어붙인 축에 대한 계층 인덱스를 생성하는 데 연관된 값이다. 리스트나 임의의 값이 들어 있는 배열. 튜플의 배열 또는 배열의 리스트(levels 옵션에 다차원 배열이 넘오온 경우)가 있다.</td>
  </tr>
  <tr>
    <td class="tg-0pky">levels</td>
    <td class="tg-0pky">계층 인덱스 레벨로 사용할 인덱스를 지정한다. keys가 넘어온 경우 여러 개의 인덱스를 지정한다.</td>
  </tr>
  <tr>
    <td class="tg-0pky">names</td>
    <td class="tg-0pky">keys나 levels 혹은 둘 다 있을 경우 생성된 계층 레벨을 위한 이름</td>
  </tr>
  <tr>
    <td class="tg-0pky">verify_integrity</td>
    <td class="tg-0pky">이어붙인 객체에 중복되는 축이 있는지 검사하고 있다면 예외를 발생시킨다. 기본값은 False로, 중복을 허용한다.</td>
  </tr>
  <tr>
    <td class="tg-0pky">ignore_index</td>
    <td class="tg-0pky">이어붙인 축의 인덱스를 유지하지 않고 range(total_length)로 새로운 인덱스를 생성한다.</td>
  </tr>
</tbody>
</table>


### 겹치는 데이터 합치기

데이터를 합칠 때 병합이나 이어붙이기로는 불가능한 상황이 있는데, 두 데이터셋의 인덱스가 일부 겹치거나 전체가 겹치는 경우가 그렇다. 벡터화된 if-else 구문을 표현하는 NumPy의 `where()` 함수로 자세히 알아보자.



```python
a = pd.Series([NA, 2.5, NA, 3.5, 4.5, NA],
              index=['f', 'e', 'd', 'c', 'b', 'a'])
b = pd.Series(np.arange(len(a), dtype=np.float64),
              index=['f', 'e', 'd', 'c', 'b', 'a'])
b[-1] = NA

display(a)
display(b)
```

<pre>
f    NaN
e    2.5
d    NaN
c    3.5
b    4.5
a    NaN
dtype: float64
</pre>
<pre>
f    0.0
e    1.0
d    2.0
c    3.0
b    4.0
a    NaN
dtype: float64
</pre>

```python
np.where(pd.isnull(a), b, a) # a 값이 null이면 b를, null이 아니면 a를 출력
```

<pre>
array([0. , 2.5, 2. , 3.5, 4.5, nan])
</pre>
시리즈 객체의 `conbine_first()` 메서드는 위와 동일한 연산을 제공하며 데이터 정렬 기능까지 제공한다.



```python
b[:-2].combine_first(a[2:])
```

<pre>
a    NaN
b    4.5
c    3.0
d    2.0
e    1.0
f    0.0
dtype: float64
</pre>

```python
b.combine_first(a)
```

<pre>
f    0.0
e    1.0
d    2.0
c    3.0
b    4.0
a    NaN
dtype: float64
</pre>
왜 인덱싱을 한 후 `combine_first()`를 진행했는지 이해가 가지 않는다. 인덱싱을 해야 데이터 정렬을 해주고, 하지 않으면 그대로 출력해준다. 이 부분에 대해서는 따로 알아봐야겠다.


데이터프레임에서 `combine_first()` 메서드는 칼럼에 대해 같은 동작을 한다. 그러므로 호출하는 객체에서 누락된 데이터를 인자로 넘긴 객체에 있는 값으로 채워 넣을 수 있다.



```python
df1 = pd.DataFrame({'a': [1., NA, 5., NA],
                    'b': [NA, 2., NA, 6.],
                    'c': range(2, 18, 4)},
                  index=[2, 3, 1, 0])
df2 = pd.DataFrame({'a': [5., 4., NA, 3., 7.],
                    'b': [NA, 3., 4. ,6., 8.]},
                   index=[3, 4, 2, 0, 1])

display(df1)
display(df2)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2</th>
      <td>1.0</td>
      <td>NaN</td>
      <td>2</td>
    </tr>
    <tr>
      <th>3</th>
      <td>NaN</td>
      <td>2.0</td>
      <td>6</td>
    </tr>
    <tr>
      <th>1</th>
      <td>5.0</td>
      <td>NaN</td>
      <td>10</td>
    </tr>
    <tr>
      <th>0</th>
      <td>NaN</td>
      <td>6.0</td>
      <td>14</td>
    </tr>
  </tbody>
</table>
</div>


<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>3</th>
      <td>5.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4.0</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>NaN</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>0</th>
      <td>3.0</td>
      <td>6.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>7.0</td>
      <td>8.0</td>
    </tr>
  </tbody>
</table>
</div>



```python
df1.combine_first(df2)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>3.0</td>
      <td>6.0</td>
      <td>14.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>5.0</td>
      <td>8.0</td>
      <td>10.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1.0</td>
      <td>4.0</td>
      <td>2.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>5.0</td>
      <td>2.0</td>
      <td>6.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4.0</td>
      <td>3.0</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>


데이터프레임을 대상으로 했을 때는 누락값을 채워줌과 동시에 인덱스 정렬까지 해주었다. 기준이 뭘까?


## 재형성과 피벗

표 형식의 데이터를 재배치하는 다양한 기본 연산이 존재한다. 이런 연산을 <strong>재형성</strong> 또는 <strong>피벗</strong> 연산이라고 한다.


### 계층적 인덱스로 재형성하기

계층적 인덱스는 데이터프레임의 데이터를 재배치하는 다음과 같은 방식을 제공한다.

- stack

    

    데이터의 칼럼을 로우로 피벗(또는 회전)시킨다.

    

- unstack



    로우를 칼럼으로 피벗시킨다.

    

몇 가지 예제를 통해 위 연산을 좀 더 알아보자. 문자열이 담긴 배열을 로우와 칼럼의 인덱스로 하는 작은 데이터프레임이 있다.



```python
data = pd.DataFrame(np.arange(6).reshape((2, 3)),
                    index=pd.Index(['Ohio', 'Colorado'], name='state'),
                    columns=pd.Index(['one', 'two', 'three'],
                    name='number'))

data
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>number</th>
      <th>one</th>
      <th>two</th>
      <th>three</th>
    </tr>
    <tr>
      <th>state</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Ohio</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>Colorado</th>
      <td>3</td>
      <td>4</td>
      <td>5</td>
    </tr>
  </tbody>
</table>
</div>


`stack()` 메서드를 사용하면 칼럼이 로우로 피벗되어서 다음과 같은 시리즈 객체를 반환한다.



```python
result = data.stack()

result
```

<pre>
state     number
Ohio      one       0
          two       1
          three     2
Colorado  one       3
          two       4
          three     5
dtype: int32
</pre>
`unstack()` 메서드를 사용하면 위 계층적 인덱스를 가진 시리즈로부터 다시 데이터프레임을 얻을 수 있다.



```python
result.unstack()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>number</th>
      <th>one</th>
      <th>two</th>
      <th>three</th>
    </tr>
    <tr>
      <th>state</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Ohio</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>Colorado</th>
      <td>3</td>
      <td>4</td>
      <td>5</td>
    </tr>
  </tbody>
</table>
</div>


기본적으로 가장 안쪽에 있는 레벨(가장 큰 레벨)부터 끄집어내는데(`stack()`도 마찬가지다), 레벨 숫자나 이름을 전달해서 끄집어낼 단계를 지정할 수 있다.



```python
result.unstack(0)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>state</th>
      <th>Ohio</th>
      <th>Colorado</th>
    </tr>
    <tr>
      <th>number</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>one</th>
      <td>0</td>
      <td>3</td>
    </tr>
    <tr>
      <th>two</th>
      <td>1</td>
      <td>4</td>
    </tr>
    <tr>
      <th>three</th>
      <td>2</td>
      <td>5</td>
    </tr>
  </tbody>
</table>
</div>



```python
result.unstack('state')
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>state</th>
      <th>Ohio</th>
      <th>Colorado</th>
    </tr>
    <tr>
      <th>number</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>one</th>
      <td>0</td>
      <td>3</td>
    </tr>
    <tr>
      <th>two</th>
      <td>1</td>
      <td>4</td>
    </tr>
    <tr>
      <th>three</th>
      <td>2</td>
      <td>5</td>
    </tr>
  </tbody>
</table>
</div>


해당 레벨에 있는 모든 값이 하위그룹에 속하지 않을 경우 `unstack()`을 하게 되면 누락된 데이터가 생길 수 있다.



```python
s1 = pd.Series([0, 1, 2, 3], index=['a', 'b', 'c', 'd'])
s2 = pd.Series([4, 5, 6], index=['c', 'd', 'e'])

data2 = pd.concat([s1, s2], keys=['one', 'two'])

data2
```

<pre>
one  a    0
     b    1
     c    2
     d    3
two  c    4
     d    5
     e    6
dtype: int64
</pre>

```python
data2.unstack()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>one</th>
      <td>0.0</td>
      <td>1.0</td>
      <td>2.0</td>
      <td>3.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>two</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>4.0</td>
      <td>5.0</td>
      <td>6.0</td>
    </tr>
  </tbody>
</table>
</div>



```python
data2.unstack(0)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>one</th>
      <th>two</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>0.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>b</th>
      <td>1.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>c</th>
      <td>2.0</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>d</th>
      <td>3.0</td>
      <td>5.0</td>
    </tr>
    <tr>
      <th>e</th>
      <td>NaN</td>
      <td>6.0</td>
    </tr>
  </tbody>
</table>
</div>


`stack()` 메서드는 누락된 데이터를 자동으로 걸러내기 때문에 연산을 쉽게 원상 복구할 수 있다.



```python
data2.unstack()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>one</th>
      <td>0.0</td>
      <td>1.0</td>
      <td>2.0</td>
      <td>3.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>two</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>4.0</td>
      <td>5.0</td>
      <td>6.0</td>
    </tr>
  </tbody>
</table>
</div>



```python
data2.unstack().stack()
```

<pre>
one  a    0.0
     b    1.0
     c    2.0
     d    3.0
two  c    4.0
     d    5.0
     e    6.0
dtype: float64
</pre>

```python
data2.unstack().stack(dropna=False)
```

<pre>
one  a    0.0
     b    1.0
     c    2.0
     d    3.0
     e    NaN
two  a    NaN
     b    NaN
     c    4.0
     d    5.0
     e    6.0
dtype: float64
</pre>
데이터프레임을 `unstack()`할 때 unstack 레벨은 결과에서 가장 낮은 단계가 된다.



```python
df = pd.DataFrame({'left': result, 'right': result + 5},
                  columns=pd.Index(['left', 'right'], name='side'))

df
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>side</th>
      <th>left</th>
      <th>right</th>
    </tr>
    <tr>
      <th>state</th>
      <th>number</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="3" valign="top">Ohio</th>
      <th>one</th>
      <td>0</td>
      <td>5</td>
    </tr>
    <tr>
      <th>two</th>
      <td>1</td>
      <td>6</td>
    </tr>
    <tr>
      <th>three</th>
      <td>2</td>
      <td>7</td>
    </tr>
    <tr>
      <th rowspan="3" valign="top">Colorado</th>
      <th>one</th>
      <td>3</td>
      <td>8</td>
    </tr>
    <tr>
      <th>two</th>
      <td>4</td>
      <td>9</td>
    </tr>
    <tr>
      <th>three</th>
      <td>5</td>
      <td>10</td>
    </tr>
  </tbody>
</table>
</div>



```python
df.unstack()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th>side</th>
      <th colspan="3" halign="left">left</th>
      <th colspan="3" halign="left">right</th>
    </tr>
    <tr>
      <th>number</th>
      <th>one</th>
      <th>two</th>
      <th>three</th>
      <th>one</th>
      <th>two</th>
      <th>three</th>
    </tr>
    <tr>
      <th>state</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Ohio</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
    </tr>
    <tr>
      <th>Colorado</th>
      <td>3</td>
      <td>4</td>
      <td>5</td>
      <td>8</td>
      <td>9</td>
      <td>10</td>
    </tr>
  </tbody>
</table>
</div>



```python
df.unstack('state')
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th>side</th>
      <th colspan="2" halign="left">left</th>
      <th colspan="2" halign="left">right</th>
    </tr>
    <tr>
      <th>state</th>
      <th>Ohio</th>
      <th>Colorado</th>
      <th>Ohio</th>
      <th>Colorado</th>
    </tr>
    <tr>
      <th>number</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>one</th>
      <td>0</td>
      <td>3</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th>two</th>
      <td>1</td>
      <td>4</td>
      <td>6</td>
      <td>9</td>
    </tr>
    <tr>
      <th>three</th>
      <td>2</td>
      <td>5</td>
      <td>7</td>
      <td>10</td>
    </tr>
  </tbody>
</table>
</div>


`stack()`을 호출할 때 쌓을 축의 이름을 지정할 수 있다.



```python
df.unstack('state').stack('side')
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>state</th>
      <th>Colorado</th>
      <th>Ohio</th>
    </tr>
    <tr>
      <th>number</th>
      <th>side</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">one</th>
      <th>left</th>
      <td>3</td>
      <td>0</td>
    </tr>
    <tr>
      <th>right</th>
      <td>8</td>
      <td>5</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">two</th>
      <th>left</th>
      <td>4</td>
      <td>1</td>
    </tr>
    <tr>
      <th>right</th>
      <td>9</td>
      <td>6</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">three</th>
      <th>left</th>
      <td>5</td>
      <td>2</td>
    </tr>
    <tr>
      <th>right</th>
      <td>10</td>
      <td>7</td>
    </tr>
  </tbody>
</table>
</div>


### 긴 형식에서 넓은 형식으로 피벗하기

데이터베이스나 CSV 파일에 여러 개의 시계열 데이터를 저장하는 일반적인 방법은 시간 순서대로 나열하는 것이다. 예제 데이터를 읽어서 시계열 데이터를 다뤄보자.



```python
data = pd.read_csv('examples/macrodata.csv')

data.head()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>year</th>
      <th>quarter</th>
      <th>realgdp</th>
      <th>realcons</th>
      <th>realinv</th>
      <th>realgovt</th>
      <th>realdpi</th>
      <th>cpi</th>
      <th>m1</th>
      <th>tbilrate</th>
      <th>unemp</th>
      <th>pop</th>
      <th>infl</th>
      <th>realint</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1959.0</td>
      <td>1.0</td>
      <td>2710.349</td>
      <td>1707.4</td>
      <td>286.898</td>
      <td>470.045</td>
      <td>1886.9</td>
      <td>28.98</td>
      <td>139.7</td>
      <td>2.82</td>
      <td>5.8</td>
      <td>177.146</td>
      <td>0.00</td>
      <td>0.00</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1959.0</td>
      <td>2.0</td>
      <td>2778.801</td>
      <td>1733.7</td>
      <td>310.859</td>
      <td>481.301</td>
      <td>1919.7</td>
      <td>29.15</td>
      <td>141.7</td>
      <td>3.08</td>
      <td>5.1</td>
      <td>177.830</td>
      <td>2.34</td>
      <td>0.74</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1959.0</td>
      <td>3.0</td>
      <td>2775.488</td>
      <td>1751.8</td>
      <td>289.226</td>
      <td>491.260</td>
      <td>1916.4</td>
      <td>29.35</td>
      <td>140.5</td>
      <td>3.82</td>
      <td>5.3</td>
      <td>178.657</td>
      <td>2.74</td>
      <td>1.09</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1959.0</td>
      <td>4.0</td>
      <td>2785.204</td>
      <td>1753.7</td>
      <td>299.356</td>
      <td>484.052</td>
      <td>1931.3</td>
      <td>29.37</td>
      <td>140.0</td>
      <td>4.33</td>
      <td>5.6</td>
      <td>179.386</td>
      <td>0.27</td>
      <td>4.06</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1960.0</td>
      <td>1.0</td>
      <td>2847.699</td>
      <td>1770.5</td>
      <td>331.722</td>
      <td>462.199</td>
      <td>1955.5</td>
      <td>29.54</td>
      <td>139.6</td>
      <td>3.50</td>
      <td>5.2</td>
      <td>180.007</td>
      <td>2.31</td>
      <td>1.19</td>
    </tr>
  </tbody>
</table>
</div>



```python
periods = pd.PeriodIndex(year=data.year, quarter=data.quarter,
                         name='date')

periods
```

<pre>
PeriodIndex(['1959Q1', '1959Q2', '1959Q3', '1959Q4', '1960Q1', '1960Q2',
             '1960Q3', '1960Q4', '1961Q1', '1961Q2',
             ...
             '2007Q2', '2007Q3', '2007Q4', '2008Q1', '2008Q2', '2008Q3',
             '2008Q4', '2009Q1', '2009Q2', '2009Q3'],
            dtype='period[Q-DEC]', name='date', length=203)
</pre>

```python
columns = pd.Index(['realgdp', 'infl', 'unemp'], name='item')

columns
```

<pre>
Index(['realgdp', 'infl', 'unemp'], dtype='object', name='item')
</pre>

```python
data = data.reindex(columns=columns)

data
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>item</th>
      <th>realgdp</th>
      <th>infl</th>
      <th>unemp</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2710.349</td>
      <td>0.00</td>
      <td>5.8</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2778.801</td>
      <td>2.34</td>
      <td>5.1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2775.488</td>
      <td>2.74</td>
      <td>5.3</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2785.204</td>
      <td>0.27</td>
      <td>5.6</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2847.699</td>
      <td>2.31</td>
      <td>5.2</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>198</th>
      <td>13324.600</td>
      <td>-3.16</td>
      <td>6.0</td>
    </tr>
    <tr>
      <th>199</th>
      <td>13141.920</td>
      <td>-8.79</td>
      <td>6.9</td>
    </tr>
    <tr>
      <th>200</th>
      <td>12925.410</td>
      <td>0.94</td>
      <td>8.1</td>
    </tr>
    <tr>
      <th>201</th>
      <td>12901.504</td>
      <td>3.37</td>
      <td>9.2</td>
    </tr>
    <tr>
      <th>202</th>
      <td>12990.341</td>
      <td>3.56</td>
      <td>9.6</td>
    </tr>
  </tbody>
</table>
<p>203 rows × 3 columns</p>
</div>



```python
data.index = periods.to_timestamp('D', 'end')

data
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>item</th>
      <th>realgdp</th>
      <th>infl</th>
      <th>unemp</th>
    </tr>
    <tr>
      <th>date</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1959-03-31 23:59:59.999999999</th>
      <td>2710.349</td>
      <td>0.00</td>
      <td>5.8</td>
    </tr>
    <tr>
      <th>1959-06-30 23:59:59.999999999</th>
      <td>2778.801</td>
      <td>2.34</td>
      <td>5.1</td>
    </tr>
    <tr>
      <th>1959-09-30 23:59:59.999999999</th>
      <td>2775.488</td>
      <td>2.74</td>
      <td>5.3</td>
    </tr>
    <tr>
      <th>1959-12-31 23:59:59.999999999</th>
      <td>2785.204</td>
      <td>0.27</td>
      <td>5.6</td>
    </tr>
    <tr>
      <th>1960-03-31 23:59:59.999999999</th>
      <td>2847.699</td>
      <td>2.31</td>
      <td>5.2</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>2008-09-30 23:59:59.999999999</th>
      <td>13324.600</td>
      <td>-3.16</td>
      <td>6.0</td>
    </tr>
    <tr>
      <th>2008-12-31 23:59:59.999999999</th>
      <td>13141.920</td>
      <td>-8.79</td>
      <td>6.9</td>
    </tr>
    <tr>
      <th>2009-03-31 23:59:59.999999999</th>
      <td>12925.410</td>
      <td>0.94</td>
      <td>8.1</td>
    </tr>
    <tr>
      <th>2009-06-30 23:59:59.999999999</th>
      <td>12901.504</td>
      <td>3.37</td>
      <td>9.2</td>
    </tr>
    <tr>
      <th>2009-09-30 23:59:59.999999999</th>
      <td>12990.341</td>
      <td>3.56</td>
      <td>9.6</td>
    </tr>
  </tbody>
</table>
<p>203 rows × 3 columns</p>
</div>



```python
ldata = data.stack().reset_index().rename(columns={0: 'value'})

ldata
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>date</th>
      <th>item</th>
      <th>value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1959-03-31 23:59:59.999999999</td>
      <td>realgdp</td>
      <td>2710.349</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1959-03-31 23:59:59.999999999</td>
      <td>infl</td>
      <td>0.000</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1959-03-31 23:59:59.999999999</td>
      <td>unemp</td>
      <td>5.800</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1959-06-30 23:59:59.999999999</td>
      <td>realgdp</td>
      <td>2778.801</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1959-06-30 23:59:59.999999999</td>
      <td>infl</td>
      <td>2.340</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>604</th>
      <td>2009-06-30 23:59:59.999999999</td>
      <td>infl</td>
      <td>3.370</td>
    </tr>
    <tr>
      <th>605</th>
      <td>2009-06-30 23:59:59.999999999</td>
      <td>unemp</td>
      <td>9.200</td>
    </tr>
    <tr>
      <th>606</th>
      <td>2009-09-30 23:59:59.999999999</td>
      <td>realgdp</td>
      <td>12990.341</td>
    </tr>
    <tr>
      <th>607</th>
      <td>2009-09-30 23:59:59.999999999</td>
      <td>infl</td>
      <td>3.560</td>
    </tr>
    <tr>
      <th>608</th>
      <td>2009-09-30 23:59:59.999999999</td>
      <td>unemp</td>
      <td>9.600</td>
    </tr>
  </tbody>
</table>
<p>609 rows × 3 columns</p>
</div>


PeriodIndex는 후에 제대로 알아보겠지만 간단히 설명하면 시간 간격을 나타내기 위한 자료형으로, 연도(year)와 분기(quarter) 칼럼을 합친다.


ldata와 같은 형식을 <strong>긴</strong> 형식이라고 부르며, 여러 시계열이나 둘 이상의 키(예제에서는 data와 item)를 가지고 있는 다른 관측 데이터에서 사용한다. 각 로우는 단일 관측치를 나타낸다.<br><br>

MySQL 같은 관계형 데이터베이스는 테이블에 데이터가 추가되거나 삭제되면 item 칼럼에 별개의 값을 넣거나 빼는 방식으로 고정된 스키마(칼럼 이름과 데이터형)에 데이터를 저장한다. 위 예에서 data와 item은 관계형 데이터베이스 관점에서 얘기하자면 기본키<sup>primary key</sup>가 되어 관계 무결성을 제공하며 쉬운 조인 연산과 프로그램에 의한 질의를 가능하게 해준다. 물론 단점도 있는데, 길이가 긴 형식으로는 작업이 용이하지 않을 수 있어서 하나의 데이터프레임에 date 칼럼의 시간값으로 인덱스된 개별 item을 칼럼으로 포함시키는 것을 선호할지도 모른다.<br>

데이터프레임의 `pivot()` 메서드가 바로 이런 변형을 지원한다.



```python
pivoted = ldata.pivot('date', 'item', 'value')

pivoted
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>item</th>
      <th>infl</th>
      <th>realgdp</th>
      <th>unemp</th>
    </tr>
    <tr>
      <th>date</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1959-03-31 23:59:59.999999999</th>
      <td>0.00</td>
      <td>2710.349</td>
      <td>5.8</td>
    </tr>
    <tr>
      <th>1959-06-30 23:59:59.999999999</th>
      <td>2.34</td>
      <td>2778.801</td>
      <td>5.1</td>
    </tr>
    <tr>
      <th>1959-09-30 23:59:59.999999999</th>
      <td>2.74</td>
      <td>2775.488</td>
      <td>5.3</td>
    </tr>
    <tr>
      <th>1959-12-31 23:59:59.999999999</th>
      <td>0.27</td>
      <td>2785.204</td>
      <td>5.6</td>
    </tr>
    <tr>
      <th>1960-03-31 23:59:59.999999999</th>
      <td>2.31</td>
      <td>2847.699</td>
      <td>5.2</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>2008-09-30 23:59:59.999999999</th>
      <td>-3.16</td>
      <td>13324.600</td>
      <td>6.0</td>
    </tr>
    <tr>
      <th>2008-12-31 23:59:59.999999999</th>
      <td>-8.79</td>
      <td>13141.920</td>
      <td>6.9</td>
    </tr>
    <tr>
      <th>2009-03-31 23:59:59.999999999</th>
      <td>0.94</td>
      <td>12925.410</td>
      <td>8.1</td>
    </tr>
    <tr>
      <th>2009-06-30 23:59:59.999999999</th>
      <td>3.37</td>
      <td>12901.504</td>
      <td>9.2</td>
    </tr>
    <tr>
      <th>2009-09-30 23:59:59.999999999</th>
      <td>3.56</td>
      <td>12990.341</td>
      <td>9.6</td>
    </tr>
  </tbody>
</table>
<p>203 rows × 3 columns</p>
</div>


`pivot()` 메서드의 처음 두 인자는 로우와 칼럼 인덱스로 사용될 칼럼 이름이고 마지막 인자는 데이터프레임에 채워 넣을 값을 담고 있는 칼럼 이름이다. 한 번에 두 개의 칼럼을 동시에 변형한다고 하자.



```python
ldata['value2'] = np.random.randn(len(ldata))

ldata[:10]
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>date</th>
      <th>item</th>
      <th>value</th>
      <th>value2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1959-03-31 23:59:59.999999999</td>
      <td>realgdp</td>
      <td>2710.349</td>
      <td>-0.574210</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1959-03-31 23:59:59.999999999</td>
      <td>infl</td>
      <td>0.000</td>
      <td>-0.092744</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1959-03-31 23:59:59.999999999</td>
      <td>unemp</td>
      <td>5.800</td>
      <td>0.060117</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1959-06-30 23:59:59.999999999</td>
      <td>realgdp</td>
      <td>2778.801</td>
      <td>-0.694223</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1959-06-30 23:59:59.999999999</td>
      <td>infl</td>
      <td>2.340</td>
      <td>-0.099797</td>
    </tr>
    <tr>
      <th>5</th>
      <td>1959-06-30 23:59:59.999999999</td>
      <td>unemp</td>
      <td>5.100</td>
      <td>0.788007</td>
    </tr>
    <tr>
      <th>6</th>
      <td>1959-09-30 23:59:59.999999999</td>
      <td>realgdp</td>
      <td>2775.488</td>
      <td>-0.481608</td>
    </tr>
    <tr>
      <th>7</th>
      <td>1959-09-30 23:59:59.999999999</td>
      <td>infl</td>
      <td>2.740</td>
      <td>-1.457328</td>
    </tr>
    <tr>
      <th>8</th>
      <td>1959-09-30 23:59:59.999999999</td>
      <td>unemp</td>
      <td>5.300</td>
      <td>-0.607005</td>
    </tr>
    <tr>
      <th>9</th>
      <td>1959-12-31 23:59:59.999999999</td>
      <td>realgdp</td>
      <td>2785.204</td>
      <td>0.455099</td>
    </tr>
  </tbody>
</table>
</div>


마지막 인자를 생략해서 계층적 칼럼을 가지는 데이터프레임을 얻을 수 있다.



```python
pivoted = ldata.pivot('date', 'item')

pivoted[:5]
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th colspan="3" halign="left">value</th>
      <th colspan="3" halign="left">value2</th>
    </tr>
    <tr>
      <th>item</th>
      <th>infl</th>
      <th>realgdp</th>
      <th>unemp</th>
      <th>infl</th>
      <th>realgdp</th>
      <th>unemp</th>
    </tr>
    <tr>
      <th>date</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1959-03-31 23:59:59.999999999</th>
      <td>0.00</td>
      <td>2710.349</td>
      <td>5.8</td>
      <td>-0.092744</td>
      <td>-0.574210</td>
      <td>0.060117</td>
    </tr>
    <tr>
      <th>1959-06-30 23:59:59.999999999</th>
      <td>2.34</td>
      <td>2778.801</td>
      <td>5.1</td>
      <td>-0.099797</td>
      <td>-0.694223</td>
      <td>0.788007</td>
    </tr>
    <tr>
      <th>1959-09-30 23:59:59.999999999</th>
      <td>2.74</td>
      <td>2775.488</td>
      <td>5.3</td>
      <td>-1.457328</td>
      <td>-0.481608</td>
      <td>-0.607005</td>
    </tr>
    <tr>
      <th>1959-12-31 23:59:59.999999999</th>
      <td>0.27</td>
      <td>2785.204</td>
      <td>5.6</td>
      <td>0.591787</td>
      <td>0.455099</td>
      <td>2.618562</td>
    </tr>
    <tr>
      <th>1960-03-31 23:59:59.999999999</th>
      <td>2.31</td>
      <td>2847.699</td>
      <td>5.2</td>
      <td>0.593470</td>
      <td>-0.412954</td>
      <td>1.592000</td>
    </tr>
  </tbody>
</table>
</div>



```python
pivoted['value'][:5]
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>item</th>
      <th>infl</th>
      <th>realgdp</th>
      <th>unemp</th>
    </tr>
    <tr>
      <th>date</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1959-03-31 23:59:59.999999999</th>
      <td>0.00</td>
      <td>2710.349</td>
      <td>5.8</td>
    </tr>
    <tr>
      <th>1959-06-30 23:59:59.999999999</th>
      <td>2.34</td>
      <td>2778.801</td>
      <td>5.1</td>
    </tr>
    <tr>
      <th>1959-09-30 23:59:59.999999999</th>
      <td>2.74</td>
      <td>2775.488</td>
      <td>5.3</td>
    </tr>
    <tr>
      <th>1959-12-31 23:59:59.999999999</th>
      <td>0.27</td>
      <td>2785.204</td>
      <td>5.6</td>
    </tr>
    <tr>
      <th>1960-03-31 23:59:59.999999999</th>
      <td>2.31</td>
      <td>2847.699</td>
      <td>5.2</td>
    </tr>
  </tbody>
</table>
</div>


`pivot()`은 단지 `set_index()`를 사용해서 계층적 인덱스를 만들고 `unstack()` 메서드를 이용해서 형태를 변경하는 단축키 같은 메서드다.



```python
unstacked = ldata.set_index(['date', 'item']).unstack('item')

unstacked
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th colspan="3" halign="left">value</th>
      <th colspan="3" halign="left">value2</th>
    </tr>
    <tr>
      <th>item</th>
      <th>infl</th>
      <th>realgdp</th>
      <th>unemp</th>
      <th>infl</th>
      <th>realgdp</th>
      <th>unemp</th>
    </tr>
    <tr>
      <th>date</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1959-03-31 23:59:59.999999999</th>
      <td>0.00</td>
      <td>2710.349</td>
      <td>5.8</td>
      <td>-0.092744</td>
      <td>-0.574210</td>
      <td>0.060117</td>
    </tr>
    <tr>
      <th>1959-06-30 23:59:59.999999999</th>
      <td>2.34</td>
      <td>2778.801</td>
      <td>5.1</td>
      <td>-0.099797</td>
      <td>-0.694223</td>
      <td>0.788007</td>
    </tr>
    <tr>
      <th>1959-09-30 23:59:59.999999999</th>
      <td>2.74</td>
      <td>2775.488</td>
      <td>5.3</td>
      <td>-1.457328</td>
      <td>-0.481608</td>
      <td>-0.607005</td>
    </tr>
    <tr>
      <th>1959-12-31 23:59:59.999999999</th>
      <td>0.27</td>
      <td>2785.204</td>
      <td>5.6</td>
      <td>0.591787</td>
      <td>0.455099</td>
      <td>2.618562</td>
    </tr>
    <tr>
      <th>1960-03-31 23:59:59.999999999</th>
      <td>2.31</td>
      <td>2847.699</td>
      <td>5.2</td>
      <td>0.593470</td>
      <td>-0.412954</td>
      <td>1.592000</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>2008-09-30 23:59:59.999999999</th>
      <td>-3.16</td>
      <td>13324.600</td>
      <td>6.0</td>
      <td>-2.149614</td>
      <td>-0.357146</td>
      <td>-0.272126</td>
    </tr>
    <tr>
      <th>2008-12-31 23:59:59.999999999</th>
      <td>-8.79</td>
      <td>13141.920</td>
      <td>6.9</td>
      <td>-0.140082</td>
      <td>1.517271</td>
      <td>0.659169</td>
    </tr>
    <tr>
      <th>2009-03-31 23:59:59.999999999</th>
      <td>0.94</td>
      <td>12925.410</td>
      <td>8.1</td>
      <td>-0.697002</td>
      <td>0.207336</td>
      <td>-1.582654</td>
    </tr>
    <tr>
      <th>2009-06-30 23:59:59.999999999</th>
      <td>3.37</td>
      <td>12901.504</td>
      <td>9.2</td>
      <td>1.269960</td>
      <td>-1.465134</td>
      <td>1.894946</td>
    </tr>
    <tr>
      <th>2009-09-30 23:59:59.999999999</th>
      <td>3.56</td>
      <td>12990.341</td>
      <td>9.6</td>
      <td>0.470281</td>
      <td>-0.663117</td>
      <td>0.677829</td>
    </tr>
  </tbody>
</table>
<p>203 rows × 6 columns</p>
</div>


### 넓은 형식에서 긴 형식으로 피벗하기

`pivot()`과 반대되는 연산은 `pandas.melt()`다. 하나의 칼럼을 여러 개의 새로운 데이터프레임으로 생성하기보다는 여러 칼럼을 하나로 병합하고 데이터프레임을 입력보다 긴 형태로 만들어낸다.



```python
df = pd.DataFrame({'key': ['foo', 'bar', 'baz'],
                   'A': [1, 2, 3],
                   'B': [4, 5, 6],
                   'C': [7, 8, 9]})

df
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key</th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>foo</td>
      <td>1</td>
      <td>4</td>
      <td>7</td>
    </tr>
    <tr>
      <th>1</th>
      <td>bar</td>
      <td>2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th>2</th>
      <td>baz</td>
      <td>3</td>
      <td>6</td>
      <td>9</td>
    </tr>
  </tbody>
</table>
</div>


'key' 칼럼을 그룹 구분자로 사용할 수 있고 다른 칼럼을 데이터값으로 사용할 수 있다. `pandas.melt()`를 사용할 때는 반드시 어떤 칼럼을 그룹 구분자로 사용할 것인지 지정해야 한다. 여기서는 'key'를 그룹 구분자로 지정하자.



```python
melted = pd.melt(df, ['key'])

melted
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key</th>
      <th>variable</th>
      <th>value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>foo</td>
      <td>A</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>bar</td>
      <td>A</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>baz</td>
      <td>A</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3</th>
      <td>foo</td>
      <td>B</td>
      <td>4</td>
    </tr>
    <tr>
      <th>4</th>
      <td>bar</td>
      <td>B</td>
      <td>5</td>
    </tr>
    <tr>
      <th>5</th>
      <td>baz</td>
      <td>B</td>
      <td>6</td>
    </tr>
    <tr>
      <th>6</th>
      <td>foo</td>
      <td>C</td>
      <td>7</td>
    </tr>
    <tr>
      <th>7</th>
      <td>bar</td>
      <td>C</td>
      <td>8</td>
    </tr>
    <tr>
      <th>8</th>
      <td>baz</td>
      <td>C</td>
      <td>9</td>
    </tr>
  </tbody>
</table>
</div>


`pivot()`을 사용해서 원래 모양으로 되돌릴 수 있다.



```python
reshaped = melted.pivot('key', 'variable', 'value')

reshaped
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>variable</th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
    </tr>
    <tr>
      <th>key</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>bar</th>
      <td>2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th>baz</th>
      <td>3</td>
      <td>6</td>
      <td>9</td>
    </tr>
    <tr>
      <th>foo</th>
      <td>1</td>
      <td>4</td>
      <td>7</td>
    </tr>
  </tbody>
</table>
</div>



```python
melted.set_index(['key', 'variable']).sort_index().unstack()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th colspan="3" halign="left">value</th>
    </tr>
    <tr>
      <th>variable</th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
    </tr>
    <tr>
      <th>key</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>bar</th>
      <td>2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th>baz</th>
      <td>3</td>
      <td>6</td>
      <td>9</td>
    </tr>
    <tr>
      <th>foo</th>
      <td>1</td>
      <td>4</td>
      <td>7</td>
    </tr>
  </tbody>
</table>
</div>


`pivot()`의 결과는 로우 라벨로 사용하던 칼럼에서 인덱스를 생성하므로 `reset_index()`를 이용해서 데이터를 다시 칼럼으로 돌려놓자.



```python
display(reshaped)
reshaped.index
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>variable</th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
    </tr>
    <tr>
      <th>key</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>bar</th>
      <td>2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th>baz</th>
      <td>3</td>
      <td>6</td>
      <td>9</td>
    </tr>
    <tr>
      <th>foo</th>
      <td>1</td>
      <td>4</td>
      <td>7</td>
    </tr>
  </tbody>
</table>
</div>


<pre>
Index(['bar', 'baz', 'foo'], dtype='object', name='key')
</pre>

```python
reshaped.reset_index()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>variable</th>
      <th>key</th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>bar</td>
      <td>2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th>1</th>
      <td>baz</td>
      <td>3</td>
      <td>6</td>
      <td>9</td>
    </tr>
    <tr>
      <th>2</th>
      <td>foo</td>
      <td>1</td>
      <td>4</td>
      <td>7</td>
    </tr>
  </tbody>
</table>
</div>


데이터값으로 사용할 칼럼들의 집합을 지정할 수도 있다.



```python
df
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key</th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>foo</td>
      <td>1</td>
      <td>4</td>
      <td>7</td>
    </tr>
    <tr>
      <th>1</th>
      <td>bar</td>
      <td>2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th>2</th>
      <td>baz</td>
      <td>3</td>
      <td>6</td>
      <td>9</td>
    </tr>
  </tbody>
</table>
</div>



```python
pd.melt(df, id_vars=['key'], value_vars=['A', 'B'])
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key</th>
      <th>variable</th>
      <th>value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>foo</td>
      <td>A</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>bar</td>
      <td>A</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>baz</td>
      <td>A</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3</th>
      <td>foo</td>
      <td>B</td>
      <td>4</td>
    </tr>
    <tr>
      <th>4</th>
      <td>bar</td>
      <td>B</td>
      <td>5</td>
    </tr>
    <tr>
      <th>5</th>
      <td>baz</td>
      <td>B</td>
      <td>6</td>
    </tr>
  </tbody>
</table>
</div>


`pandas.melt()`는 그룹 구분자(id_vars) 없이도 사용할 수 있다.



```python
pd.melt(df, value_vars=['A', 'B', 'C'])
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>variable</th>
      <th>value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>A</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>A</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>A</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3</th>
      <td>B</td>
      <td>4</td>
    </tr>
    <tr>
      <th>4</th>
      <td>B</td>
      <td>5</td>
    </tr>
    <tr>
      <th>5</th>
      <td>B</td>
      <td>6</td>
    </tr>
    <tr>
      <th>6</th>
      <td>C</td>
      <td>7</td>
    </tr>
    <tr>
      <th>7</th>
      <td>C</td>
      <td>8</td>
    </tr>
    <tr>
      <th>8</th>
      <td>C</td>
      <td>9</td>
    </tr>
  </tbody>
</table>
</div>



```python
pd.melt(df, value_vars=['key', 'A', 'B'])
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>variable</th>
      <th>value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>key</td>
      <td>foo</td>
    </tr>
    <tr>
      <th>1</th>
      <td>key</td>
      <td>bar</td>
    </tr>
    <tr>
      <th>2</th>
      <td>key</td>
      <td>baz</td>
    </tr>
    <tr>
      <th>3</th>
      <td>A</td>
      <td>1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>A</td>
      <td>2</td>
    </tr>
    <tr>
      <th>5</th>
      <td>A</td>
      <td>3</td>
    </tr>
    <tr>
      <th>6</th>
      <td>B</td>
      <td>4</td>
    </tr>
    <tr>
      <th>7</th>
      <td>B</td>
      <td>5</td>
    </tr>
    <tr>
      <th>8</th>
      <td>B</td>
      <td>6</td>
    </tr>
  </tbody>
</table>
</div>

