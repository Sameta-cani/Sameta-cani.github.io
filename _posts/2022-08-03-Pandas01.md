---
layout: single
title:  "Pandas01"
categories: pandas
tag: [python, pandas]
toc: true
author_profile: false
toc_sticky: true
---

<head>
  <style>
    table.dataframe {
      white-space: normal;
      width: 100%;
      height: 240px;
      display: block;
      overflow: auto;
      font-family: Arial, sans-serif;
      font-size: 0.9rem;
      line-height: 20px;
      text-align: center;
      border: 0px !important;
    }

    table.dataframe th {
      text-align: center;
      font-weight: bold;
      padding: 8px;
    }

    table.dataframe td {
      text-align: center;
      padding: 8px;
    }

    table.dataframe tr:hover {
      background: #b8d1f3; 
    }

    .output_prompt {
      overflow: auto;
      font-size: 0.9rem;
      line-height: 1.45;
      border-radius: 0.3rem;
      -webkit-overflow-scrolling: touch;
      padding: 0.8rem;
      margin-top: 0;
      margin-bottom: 15px;
      font: 1rem Consolas, "Liberation Mono", Menlo, Courier, monospace;
      color: $code-text-color;
      border: solid 1px $border-color;
      border-radius: 0.3rem;
      word-break: normal;
      white-space: pre;
    }

  .dataframe tbody tr th:only-of-type {
      vertical-align: middle;
  }

  .dataframe tbody tr th {
      vertical-align: top;
  }

  .dataframe thead th {
      text-align: center !important;
      padding: 8px;
  }

  .page__content p {
      margin: 0 0 0px !important;
  }

  .page__content p > strong {
    font-size: 0.8rem !important;
  }

  </style>
</head>


<center><h1><a href='https://pandas.pydata.org/' target='blank'>Pandas</a></h1></center>


월스트리트 금융회사의 분석 전문가인 웨스 매키니(Wes McKinney)는 회사에서 사용하는 분석용 데이터 핸들링 툴이 마음에 안 들어서 판다스를 개발했다고 한다. 그가 생각하는 대부분의 데이터 분석 애플리케이션에서의 중요한 기능은 다음과 같다.



- 벡터 배열 상에서 데이터 가공(데이터 먼징 또는 데이터 랭글링)[^1], 정제, 부분집합, 필터링, 변형 그리고 다른 여러 종류의 연산을 빠르게 수행

-  정렬, 유일 원소 찾기, 집합 연산 같은 일반적인 배열 처리 알고리즘

- 통계의 효과적인 표현과 데이터를 수집 요약하기

- 다양한 종류의 데이터를 병합하고 엮기 위한 데이터 정렬과 데이터 간의 관계 조작

- 내부에서 if-elif-else를 사용하는 반복문 대신 사용할 수 있는 조건절 표현을 허용하는 배열 처리

- 데이터 묶음 전체에 적용할 수 있는 수집, 변형, 함수 적용 같은 데이터 처리



[^1]: 원자료(raw data)를 보다 쉽게 접근하고 분석할 수 있도록 데이터를 통합하고 정리하는 과정



판다스는 파이썬에서 데이터 처리를 위해 존재하는 가장 인기 있는 라이브러리다. 일반적으로 대부분의 데이터 세트는 2차원 데이터이다. 즉, 행(Row) x 열(Column)로 구성돼 있다(RDBMS의 TABLE이나 엑셀의 시트를 떠올리면 된다). 행과 열의 2차원 데이터가 인기 있는 이유는 바로 인간이 가장 이해하기 쉬운 데이터 구조이면서도 효과적으로 데이터를 담을 수 있는 구조이기 때문이다. 판다스는 이처럼 행과 열로 이뤄진 2차원 데이터를 효과적으로 가공/처리할 수 있는 다양하고 훌륭한 기능을 제공한다.<br><br>

판다스는 고수준의 자료구조와 피어썬에서 빠르고 쉽게 사용할 수 있는 데이터 분석 도구를 포함하고 있다. 판다스는 다른 산술 계산 도구인 NumPy와 SciPy, 분석 라이브러리인 statsmodels와 scikit-learn, 시각화 도구인 matplotlib과 함께 사용하는 경우가 흔하다.<br><br>

판다스는 많은 부분이 넘파이 기반으로 작성됐지만 가장 큰 차이점은 판다스는 파이썬의 리스트, 컬렉션, 넘파이 등의 내부 데이터 뿐만 아니라 CSV 등의 파일을 쉽게 DataFrame으로 변경해 데이터의 가공/분석을 편리하게 수행할 수 있게 초점을 맞춰 설계했다는 것이다.<br><br>

이에 판다스 라이브러리는 데이터를 수집하고 정리하는 데 최적화된 도구라고 볼 수 있다. 오픈소스(open source)라서 무료라는 장점도 있다. 또한 가장 배우기 쉬운 파이썬을 기반으로 하기 때문에 컴퓨터과학이나 프로그래밍을 전공하지 않은 사람들도 쉽게 따라가며 배우는 것이 가능하다. 판다스를 배우면 데이터과학의 80~90% 업무를 처리할 수 있고, 데이터과학자에게 필요한 기본적이면서도 아주 중요한 도구를 갖추게 된다.<br><br>

판다스 라이브러리는 여러 종류의 클래스(class)와 다양한 내장 함수(built-in function)로 구성된다. 시리즈(Series)와 데이터프레임(DataFrame)은 데이터 구조를 표현하는 대표적인 클래스 객체다. 시리즈와 데이터프레임 클래스의 속성과 메소드를 잘 이해하면, 판다슬 자유자재로 다루는 데 어려움이 없을 것이다. 내장 함수로는 `Series()`, `DataFrame()`, `read_csv()`, `read_excel()` 등이 있다.


# Pandas data structure


판다스는 서로 다른 형식을 갖는 여러 종류의 데이터를 컴퓨터가 이해할 수 있도록 동일한 형식을 갖는 구조로 통합하기 위해 시리즈(Series)와 데이터프레임(DataFrame)이라는 구조화된 데이터 형식을 제공한다. 이는 파이썬 클래스로 만들어지는데, 서로 다른 종류의 데이터를 한곳에 담는 그릇(컨테이너)이 된다.<br><br>

판다스의 핵심 객체는 DataFrame으로 여러 개의 행과 열로 이뤄진 2차원 데이터를 담는 데이터 구조체이다. 판다스가 다루는 배부분의 영역은 DataFrame에 관련된 부분이다. DataFrame을 이해하기 전에 다른 중요 객체인 Index와 Series를 이해하는 것도 중요하다. Index는 RDMBS의 PK처럼 개별 데이터를 고유하게 식별하는 Key 값이다. Series와 DataFrame은 모두 Index를 key 값으로 가지고 있다. 이들의 가장 큰 차이는 Series는 칼럼이 하나 뿐인 데이터 구조체이고, DataFrame은 칼럼이 여러 개인 데이터 구조체라는 점이다.


컴퓨터에 설치된 판다스를 파이썬 파일(.py)에서 사용하려면, 판다스 라이브러리를 실행 환경으로 불러오는 박업이 필요하다. 이때 임포트(import) 명령을 사용한다. `as`로 패키지 약어를 지정해두면 함수를 사용할 때 패키지 이름 대신 약어를 활용해 코드를 짧게 줄일 수 있어 편리하다. 보통 패키지 개발자가 권하는 이름대로 다음과 같이 pandas의 import 관례<sup>convention</sup>를 사용한다.



```python
import pandas as pd
```

## Series

Series는 데이터가 순차적으로 나열된 1차원 배열의 형태를 갖는 자료구조다(어떤 NumPy 자료형이라도 담을 수 있다). 그리고 인덱스(index)라고 하는 데이터의 위치를 나타내는 이름(데이터 주소)을 갖고 있으며 데이터 값(value)과 일대일 대응이 된다. 이런 관점에서 키(k)와 값(v)이 '{k:v}' 형태로 짝을 이루는 파이썬 딕셔너리(dictionary)와 비슷한 구조를 갖는다고 볼 수 있다.<br><br>



### Series 만들기

딕셔너리와 시리즈의 구조가 비슷하기 때문에 딕셔너리를 시리즈로 변환하는 방법을 많이 사용한다. 또는 배열 데이터로부터 생성할 수도 있다. 판다스 내장 함수인 `Series()`를 이용하고, 배열이나 딕셔너리를 함수의 인자로 전달한다. 딕셔너리를 인자로 넘겨줄 경우 딕셔너리의 키(k)는 시리즈의 인덱스에 대응하고, 딕셔너리의 각 키에 매치되는 값(v)이 시리즈의 데이터 값으로 변환된다.



```python
# key:value 쌍으로 딕셔너리를 만들고, 변수 dict_data에 저장
dict_data = {'a': 1, 'b': 2, 'c': 3}

# 판다스 Series() 함수로 dictionary를 Series로 변환. 변수 sr에 저장
sr = pd.Series(dict_data)

# sr의 자료형과 객체 데이터 출력
print('sr의 자료형:', type(sr)) # type() 함수로 변수 sr에 저장된 객체의 자료형 확인
print(sr)
```

<pre>
sr의 자료형: <class 'pandas.core.series.Series'>
a    1
b    2
c    3
dtype: int64
</pre>
출력된 시리즈 객체 왼쪽의 'a', 'b', 'c'는 인덱스이고, 오른쪽의 '1', '2', '3'은 값으로 서로의 값에 대응된다. 마지막 줄의 출력을 보면 시리즈를 구성하는 데이터 값의 자료형(dtype)은 정수형(int64)이다.


### 인덱스 구조

판다스의 Index 객체는 RDMBS의 PK(Primary Key)와 유사하게 DataFrame, Series의 레코드를 유일하게 식별하는 객체로 자기와 짝을 이루는 데이터 값의 순서와 주소를 저장한다. 인덱스를 잘 활용하면 데이터 값의 탐색, 정렬, 선택, 결합 등 데이터 조작을 쉽게 할 수 있다.<br><br>

인덱스는 크게 정수형 위치 인덱스(integer position)와 인덱스 이름(index name) 또는 인덱스 라벨(index label)의 두 가지 종류이다. 아래의 예시에서는 정수형 위치 인덱스를 보여준다.<br><br>



```python
# 리스트를 시리즈로 변환하여 변수 sr에 저장
list_data = ['2022-08-02', 3.14, 'ABC', 100, True]
sr = pd.Series(list_data)
print(sr)
```

<pre>
0    2022-08-02
1          3.14
2           ABC
3           100
4          True
dtype: object
</pre>
시리즈의 데이터 값 배열과 인덱스 객체는 각각 시리즈 클래스의 `values`와 `index` 속성을 통해 얻을 수 있다.



```python
# 인덱스 배열은 변수 idx에 저장. 데이터 값 배열은 변수 val에 저장.
idx = sr.index # range(5)와 동일.
val = sr.values

print('index:', idx)
print('values:', val)
```

<pre>
index: RangeIndex(start=0, stop=5, step=1)
values: ['2022-08-02' 3.14 'ABC' 100 True]
</pre>
인덱스는 0 ~ 4 범위의 정수를 갖는 RangeIndex 객체로 표시된다. 즉, 데이터의 인덱스를 지정하지 않았으므로 기본 인덱스인 정수 0에서 N - 1(N은 데이터의 길이)까지의 숫자가 표시된다. 데이터의 값 배열은 원래 데이터인 list_data의 리스트 원소 배열이 순서를 유지한 상태로 입력된다. 


리스트 또는 튜플을 시리즈로 만들 때 정수형 위치 인덱스 대신 인덱스 이름을 지정할 수 있다. 각각의 데이터를 지칭하는 인덱스를 지정하여 Series 객체를 생성해야 할 때는 다음처럼 Series() 함수의 index 옵션에 인덱스 이름을 직접 전달한다. 또는, 딕셔너리 객체로 Series 객체를 생성할 때 인덱스의 순서를 직접 지정하고 싶다면 원하는 순서대로 인덱스를 직접 넘겨줄 때 사용한다.



```python
sr = pd.Series(list_data, index=['d', 'b', 'a', 'c', 'e'])

print(sr)
```

<pre>
d    2022-08-02
b          3.14
a           ABC
c           100
e          True
dtype: object
</pre>

```python
# 인덱스 배열은 변수 idx에 저장. 데이터 값 배열은 변수 val에 저장.
idx = sr.index
val = sr.values

print('index:', idx)
print('values:', val)
```

<pre>
index: Index(['d', 'b', 'a', 'c', 'e'], dtype='object')
values: ['2022-08-02' 3.14 'ABC' 100 True]
</pre>
### 원소 선택

원소의 위치를 나타내는 주소 역할을 하는 인덱스를 이용하여 시리즈의 원소를 선택한다. 하나의 원소를 선택할 수도 있고, 여러 원소를 한꺼번에 선택할 수도 있다. 파이썬 리스트 슬라이싱(slicing) 기법과 비슷하게 인덱스 범위를 지정하여 원소를 선택하는 방법도 있다.<br><br>

정수형 위치 인덱스는 대괄호([]) 안에 위치를 나타내는 숫자를 입력하는데 반해, 인덱스 이름(라벨)을 사용할 때는 대괄호([]) 안에 이름과 함께 따옴표를 입력한다.



```python
# 튜플을 시리즈로 변환(index 옵션 지정)
tup_data = ('영호', '2012-08-03', '남', True)
sr = pd.Series(tup_data, index=['이름', '생년월일', '성별', '학생여부'])
print(sr)
```

<pre>
이름              영호
생년월일    2012-08-03
성별               남
학생여부          True
dtype: object
</pre>

```python
# 원소를 1개 선택
print(sr[0]) # sr의 1번째 원소를 선택(정수형 위치 인덱스)
print(sr['이름']) # '이름' 라벨을 가진 원소를 선택(인덱스 이름)
```

<pre>
영호
영호
</pre>

```python
# 여러 개의 원소를 선택(인덱스 리스트 활용)
print(sr[[1, 2]])
print('\n')
print(sr[['생년월일', '성별']])
```

<pre>
생년월일    2012-08-03
성별               남
dtype: object


생년월일    2012-08-03
성별               남
dtype: object
</pre>

```python
# 여러 개의 원소를 선택(인덱스 범위 지정)
print(sr[1:2])
print('\n')
print(sr['생년월일':'성별'])
```

<pre>
생년월일    2012-08-03
dtype: object


생년월일    2012-08-03
성별               남
dtype: object
</pre>
정수형 위치 인덱스를 사용할 때는 범위의 끝(2: 성별)이 포함되지 않았지만 인덱스 이름을 사용한 슬라이싱에서는 범위의 끝(2: 성별)이 포함된다.


Series 객체와 Series의 인덱스는 모두 name 속성이 있는데 이 속성은 pandas의 핵심 기능과 밀접한 관련이 있다.



```python
sr.name = 'student' # Series 객체의 name
 
sr.index.name = 'info' # Series.index의 name

print(sr)
```

<pre>
info
이름              영호
생년월일    2012-08-03
성별               남
학생여부          True
Name: student, dtype: object
</pre>
## DataFrame

데이터프레임은 2차원 배열이다. 행과 열로 만들어지는 2차원 배열 구조는 마이크로소프트 엑셀(Excel)과 관계형 데이터베이스(RDBMS) 등 컴퓨터 관련 다양한 분야에서 사용된다. 판다스의 데이터프레임 자료구조는 대표적인 통계 패키지인 R의 데이터프레임에서 유래했다고 알려져 있다.<br><br>

데이터프레임은 여러 개의 칼럼이 있는데 각 칼럼은 서로 다른 종류의 값(숫자, 문자열, 불리언 등)을 담을 수 있다. 데이터프레임은 행과 열을 타나개이 위해 두 가지 종류의 주소를 사용한다. 각각 행 인덱스(row index)와 열 이름(column name 또는 column label)으로 구분한다.<br><br>

데이터프레임의 열은 공통의 속성을 갖는 일련의 데이터를 나타내고, 행은 개별 관측대상에 대한 다양한 속성 데이터들의 모음인 레코드(record)가 된다. 즉, 각 행은 하나의 관측값(observation)을 나타내고, 열은 공통의 속성이나 범주를 나타내는데, 보통 변수(variable)로 활용된다.



|row＼column|column0|column1|column2|
|:---:|:---:|:---:|:---:|
|row0|index(0, 0)|index(0, 1)|index(0, 2)|
|row1|index(1, 0)|index(1, 1)|index(1, 2)|
|row2|index(2, 0)|index(2, 1)|index(2, 2)|

다음은 DataFrame 생성을 위한 입력 데이터의 종류다.



|형|설명|
|:---|:---|
|2차원 ndarray|데이터를 담고 있는 행렬. 선택적으로 행(로우)와 열(칼럼)의 이름을 전달할 수 있다.|
|배열, 리스트, 튜플의 사전|사전의 모든 항목은 같은 길이를 가져야 하며, 각 항목의 내용이 DataFrame의 칼럼이 된다.|
|NumPy의 구조화 배열|배열의 사전과 같은 방식으로 취급된다.|
|Series의 사전|Series의 각 값이 칼럼이 된다. 명시적으로 인덱스를 넘겨주지 않으면 각 Series의 이니덱스가 하나로 합쳐져서 로우의 인덱스가 된다.|
|사전의 사전|내부에 있는 사전이 칼럼이 된다. 키 값은 'Series의 사전'과 마찬가지로 합쳐져서 로우의 인덱스가 된다.|
|사전이나 Series의 리스트|리스트의 각 항목이 DataFrame의 로우가 된다. 합쳐진 사전의 키 값이나 Series의 인덱스가 DataFrame의 칼럼 이름이 된다.|
|리스트나 튜플의 리스트|'2차원 ndarray'의 경우와 같은 방식으로 취급된다.|
|다른 DataFrame|인덱스를 따로 지정하지 않으면 DataFrame의 인덱스가 그대로 사용된다.|
|NumPy MaskedArray|'2차원 ndarray'의 경우와 같은 방식으로 취급되지만 마스크값은 반환되는 DataFrame에서 NA 값이 된다.|


### 데이터프레임 만들기

데이터프레임을 만들기 위해서는 같은 길이(원소의 개수가 동일한)의 1차원 배열 여러 개가 필요하다. 데이터프레임은 인덱스의 모양이 같은 여러 개의 시리즈(열, column) 객체를 담고 있는 파이썬 사전으로 생각하면 편하다. 데이터프레임을 만들 때는 판다스 `DataFrame()` 함수를 사용한다. 주로 여러 개의 리스트를 원소로 갖는 딕셔너리를 함수의 인자로 전달하는 방식이 활용된다. 이때 딕셔너리의 키(k)가 열 이름이 되고, 값(v)에 해당하는 각 리스트가 데이터프레임의 열이 된다. 행 인덱스에는 정수형 위치 인덱스가 자동 지정된다.



```python
# 열이름을 key로 하고, 리스트를 value로 갖는 딕셔너리 정의(2차원 배열)
dict_data = {'c0': [1, 2, 3], 'c1': [4, 5, 6], 'c2': [7, 8, 9], 'c3': [10, 11, 12], 'c4': [13, 14, 15]}

# 판다스 DataFrame() 함수로 딕셔너리를 데이터프레임으로 변환. 변수 df에 저장
df = pd.DataFrame(dict_data)

# df의 자료형과 데이터프레임 객체 출력
print(type(df))
print(df)
```

<pre>
<class 'pandas.core.frame.DataFrame'>
   c0  c1  c2  c3  c4
0   1   4   7  10  13
1   2   5   8  11  14
2   3   6   9  12  15
</pre>
### 행 인덱스/열 이름 설정

데이터프레임의 구조적 특성 때문에 2차원 배열 형태의 데이터(중첩 리스트 또는 중첩 튜플)을 데이터프레임으로 변환하기 쉽다.<br><br>

2차원 배열을 `DataFrame()` 함수 인자로 전달하여 데이터프레임으로 변환할 때 행 인덱스와 열 이름 속성을 사용자가 직접 지정할 수도 있다.



```python
# 행 인덱스/열 이름 지정하여 데이터프레임 만들기
df = pd.DataFrame([[22, '남', '가우스대'], [20, '여', '르쿤대']],
                  index=['희준', '지은'],
                  columns=['나이', '성별', '학교'])

# 행 인덱스, 열 이름 확인하기
print(df) # 데이터프레임
print('index:', df.index) # 행 인덱스
print('columns:', df.columns) # 열 이름
```

<pre>
    나이 성별    학교
희준  22  남  가우스대
지은  20  여   르쿤대
index: Index(['희준', '지은'], dtype='object')
columns: Index(['나이', '성별', '학교'], dtype='object')
</pre>
2.2.1에서 예제에서는 딕셔너리의 원소인 리스트가 열이 됐지만, 이번 예제에서는 하나의 리스트가 행으로 변환되는 점에 유의한다.


데이터프레임 df의 행 인덱스와 열 이름 객체를 나타내는 `df.index`와 `df.column`의 속성에 새로운 배열을 할당하는 방식으로 행 인덱스와 열 이름을 변경할 수 있다.



```python
df.index = ['학생1', '학생2']
df.columns = ['연령', '남녀', '소속']
print(df)
print('index:', df.index)
print('columns:', df.columns)
```

<pre>
     연령 남녀    소속
학생1  22  남  가우스대
학생2  20  여   르쿤대
index: Index(['학생1', '학생2'], dtype='object')
columns: Index(['연령', '남녀', '소속'], dtype='object')
</pre>
데이터프레임에 `rename()` 메서드를 적용하면 행 인덱스 또는 열 이름의 일부를 선택하여 변경할 수 있다. 단, 원본 객체를 직접 수정하는 것이 아니라 새로운 데이터프레임 객체를 반환한다. 원본 객체를 직접 변경하려면 inplace=True 옵션을 사용한다.



```python
print('변경 전')
print(df) # 현재 df의 행 인덱스와 열 이름 확인

# 열 이름 바꾸기
df.rename(columns={'연령': '나이', '남녀': '성별', '소속': '학교'}, inplace=True)

# df의 행 인덱스 바꾸기
df.rename(index={'학생1': '희준', '학생2': '지은'}, inplace=True)

# df 출력(변경 후)
print('\n변경 후')
print(df)
```

<pre>
변경 전
     연령 남녀    소속
학생1  22  남  가우스대
학생2  20  여   르쿤대

변경 후
    나이 성별    학교
희준  22  남  가우스대
지은  20  여   르쿤대
</pre>
### 행/열 삭제

데이터프레임의 행 또는 열을 삭제하는 명령으로 `drop()` 메서드가 있다. 행을 삭제할 때는 축(axis) 옵션으로 axis=0(default)을 입력하고 열을 삭제할 때는 axis=1을 입력하여 삭제한다. 동시에 여러 개의 행 또는 열을 삭제하려면 리스트 형태로 입력한다.<br><br>

한편 `drop()` 메서드는 기존 객체를 변경하지 않고 새로운 객체를 반환하므로 원본 객체를 직접 변경하기 위해서는 inplace=True 옵션을 추가한다. inplace 옵션을 False로 설정하면 새로운 객체가 생성되고, 원 객체는 변경 없이 그대로 유지된다.



```python
# DataFrame() 함수로 데이터프레임 변환. 변수 df에 저장
exam_data = {'수학': [90, 80, 70], '영어': [98, 89, 95],
             '음악': [85, 95, 100], '체육': [100, 90, 90]}

df = pd.DataFrame(exam_data, index=['서준', '우현', '인아'])
print(df)
print('\n')

# 데이터프레임 df를 복제하여 변수 df2에 저장. df2의 1개 행(row) 삭제
df2 = df.copy()
df2.drop('우현', inplace=True)
print(df2)
print('\n')

# 데이터프레임 df를 복제하여 변수 df3에 저장. df3의 2개 행(row) 삭제
df3 = df.copy()
df3.drop(['우현', '인아'], axis=0, inplace=True)
print(df3)
```

<pre>
    수학  영어   음악   체육
서준  90  98   85  100
우현  80  89   95   90
인아  70  95  100   90


    수학  영어   음악   체육
서준  90  98   85  100
인아  70  95  100   90


    수학  영어  음악   체육
서준  90  98  85  100
</pre>

```python
print(df)
print('\n')

# 데이터프레임 df를 복제하여 변수 df4에 저장. df4의 1개 열(column) 삭제
df4 = df.copy()
df4.drop('수학', axis=1, inplace=True)
print(df4)
print('\n')

# 데이터프레임 df를 복제하여 변수 df5에 저장. df5의 2개 열(column) 삭제
df5 = df.copy()
df5.drop(['영어', '음악'], axis=1, inplace=True)
print(df5)
```

<pre>
    수학  영어   음악   체육
서준  90  98   85  100
우현  80  89   95   90
인아  70  95  100   90


    영어   음악   체육
서준  98   85  100
우현  89   95   90
인아  95  100   90


    수학   체육
서준  90  100
우현  80   90
인아  70   90
</pre>
참고로 `del` 예약어를 이용해서 칼럼을 삭제할 수도 있다. 



```python
print(df5)
print('\n')

del df5['체육']

print(df5)
```

<pre>
    수학   체육
서준  90  100
우현  80   90
인아  70   90


    수학
서준  90
우현  80
인아  70
</pre>
<strong>drop() 메서드 정리</strong>



- <strong>axis</strong>: DataFrame의 로우를 삭제할 때는 axis=0, 칼럼을 삭제할 때는 axis=1로 설정.

- 원본 DataFrame은 유지하고 드롭된 DataFrame을 새롭게 객체 변수로 받고 싶다면 inplace=False로 설정(디폴트 값이 False).

- 원본 DataFrame에 드롭된 결과를 적용할 경우에는 inplace=True를 적용.

- 원본 DataFrame에서 드롭된 DataFrame을 다시 원본 DataFrame 객체 변수로 할당하면 원본 DataFrame에서 드롭된 결과를 적용할 경우와 같음(단, 기존 원본 DataFrame 객체 변수는 메모리에서 추후 제거됨).


### 행 선택

데이터프레임의 행 데이터를 선택하기 위해서는 `loc`과 `iloc` 인덱서를 사용한다. 인덱스 이름을 기준으로 행을 선택할 때는 `loc`을 이용하고, 정수형 위치 인덱스를 사용할 때는 `iloc`을 이용한다.<br><br>

`iloc[]`는 위치 기반 인덱싱만 허용하기 때문에 행과 열 값으로 integer 또는 integer형의 슬라이싱, 팬시 리스트 값을 입력해줘야 한다(불링 인덱싱은 조건을 기술하므로 이에 제약받지 않는다). `iloc[]`는 슬라이싱과 팬시 인덱싱은 제공하나 명확한 위치 기반 인덱싱이 사용되어야 하는 제약으로 인해 불린 인덱싱은 제공하지 않는다.<br><br>

`loc[]`는 명칭 기반으로 데이터를 추출한다. 따라서 행 위치에는 DataFrame index 값을, 그리고 열 위치에는 칼럼 명을 입력해 준다. 단, `loc[]`에 슬라이싱 기호를 적용하면 종료 값-1이 아니라 종료 값까지 포함된다. 이는 명칭 기반 인덱싱의 특성 때문이다.



|구분|loc|iloc|
|:---:|:---|:---|
|탐색 대상|인덱스 이름(index label)|정수형 위치 인덱스(integer position)|
|범위 지정|가능(범위의 끝 포함)<br>ex) ['a':'c]->'a', 'b', 'c'|가능(범위의 끝 제외)<br>ex)[3:7]->3, 4, 5, 6(* 7 제외)|


다음은 단일 행 인덱스를 이용하는 예시다.



```python
print(df)
print('\n')

# 행 인덱스를 사용하여 행 1개 선택
label1 = df.loc['서준']
position1 = df.iloc[0]
print("df.loc['서준']:\n", label1)
print('\n')
print("df.iloc[0]:\n", position1)
```

<pre>
    수학  영어   음악   체육
서준  90  98   85  100
우현  80  89   95   90
인아  70  95  100   90


df.loc['서준']:
 수학     90
영어     98
음악     85
체육    100
Name: 서준, dtype: int64


df.iloc[0]:
 수학     90
영어     98
음악     85
체육    100
Name: 서준, dtype: int64
</pre>
`loc` 인덱서와 `iloc` 인덱서의 결과값에 차이가 없다.


다음은 2개 이상의 행 인덱스를 리스트 형태로 입력하는 예시로 매칭되는 모든 행 데이터를 동시에 추출한다.



```python
# 행 인덱스를 사용하여 2개 이상의 행 선택
label2 = df.loc[['서준', '우현']]
position2 = df.iloc[[0, 1]]
print("df.loc[['서준', '우현']]:\n", label2)
print('\n')
print("df.iloc[[0, 1]]:\n", position2)
```

<pre>
df.loc[['서준', '우현']]:
     수학  영어  음악   체육
서준  90  98  85  100
우현  80  89  95   90


df.iloc[[0, 1]]:
     수학  영어  음악   체육
서준  90  98  85  100
우현  80  89  95   90
</pre>
다음은 행 인덱스의 범위를 지정하여 여러 개의 행을 동시에 선택하는 예시다.



```python
# 행 인덱스의 범위를 지정하여 행 선택
label3 = df.loc['서준':'우현']
position3 = df.iloc[0:1]
print("df.loc['서준':'우현']:\n", label3)
print('\n')
print("df.iloc[0:1]:\n", position3)
```

<pre>
df.loc['서준':'우현']:
     수학  영어  음악   체육
서준  90  98  85  100
우현  80  89  95   90


df.iloc[0:1]:
     수학  영어  음악   체육
서준  90  98  85  100
</pre>
인덱스의 이름을 범위로 지정한 label3의 경우에는 범위의 마지막 값인 '우현'이 포함되지만, 정수형 위치 인덱스를 사용한 position3에는 범위의 마지막 값인 '우현'이 제외된다.


다음은 다양한 DataFrame의 값을 선택하는 예시다.



|방식|설명|
|:---|:---|
|df[val]|DataFrame에서 하나의 칼럼 또는 여러 칼럼을 선택한다. 편의를 위해 불리언 배열, 슬라이스, 불리언 DataFrame(어떤 기준에 근거해서 값을 대입해야 할 때)을 사용할 수 있다.|
|df.loc[val]|DataFrame에서 라벨값으로 로우의 부분집합을 선택한다.|
|df.loc[:, val]|DataFrame에서 라벨값으로 칼럼의 부분집합을 선택한다.|
|df.loc[val1, val2]|DataFrame에서 라벨값으로 로우와 칼럼의 부분집합을 선택한다.|
|df.iloc[where]|DataFrame에서 정수 인덱스로 로우의 부분집합을 선택한다.|
|df.iloc[:, where]|DataFrame에서 정수 인덱스로 칼럼의 부분집합을 선택한다.|
|df.iloc[where_i, where_j]|DataFrame에서 정수 인덱스로 로우와 칼럼의 부분집합을 선택한다.|
|df.at[label_i, label_j]|로우와 칼럼의 라벨로 단일 값을 선택한다.|
|df.iat[i, j]|로우와 칼럼의 정수 인덱스로 단일 값을 선택한다.|
|reindex 메서드|하나 이상의 축을 새로운 색인으로 맞춘다.|
|_get_value, _set_value 메서드|로우와 칼럼 이름으로 DataFrame의 값을 선택한다.|


<strong>`iloc`, `loc`의 문제점과 주의할 점 정리</strong>

1. 가장 중요한 것은 명칭 기반 인덱싱과 위치 기반 인덱싱의 차이를 이해하는 것이다. DataFrame의 인덱스나 칼럼명으로 데이터에 접근하는 것은 명칭 기반 인덱싱이다. 0부터 시작하는 행, 열의 위치 좌표에만 의존하는 것이 위치 기반 인덱싱이다.

2. `iloc[]`는 위치 기반 인덱싱만 가능하다. 따라서 행과 열 위치 값으로 정수형 값을 지정해 원하는 데이터를 반환한다.

3. `loc[]`는 명칭 기반 인덱싱만 가능하다. 따라서 행 위치에 DataFrame 인덱스가 오며, 열 위치에는 칼럼 명을 지정해 원하는 데이터를 반환한다.

4. 명칭 기반 인덱싱에서 슬라이싱을 '시작점:종료점'으로 지정할 때 시작점에서 종료점을 포함한 위치에 있는 데이터를 반환한다.


### 열 선택

데이터프레임의 열 데이터를 1개만 선택할 때는, 대괄호([]) 안에 열 이름을 따옴표와 함께 입력하거나 도트(.)다음에 열 이름을 입력하는 두 가지 방식을 사용한다. 단, 두 번째 방법은 반드시 열 이름이 문자열이고 파이썬에서 사용 가능한 변수 이름 형식일 경우에만 가능하다. 이처럼 열 1개를 선택하면 시리즈 객체가 반환된다.<br><br>

대괄호 안에 열 이름의 리스트를 입력하면 리스트의 원소인 열을 모두 선택하여 데이터프레임으로 반환한다. 또한 리스트의 원소로 열 이름 한 개만 있는 경우에도, 2중 대괄호([[]])를 사용하는 것이 되어 반환되는 객체는 시리즈가 아니라 데이터프레임이 된다.



```python
# DataFrame() 함수로 데이터프레임 변환. 변수 df에 저장
exam_data = {'이름': ['서준', '우현', '인아'],
             '수학': [90, 80, 70],
             '영어': [98, 89, 95],
             '음악': [85, 95, 100],
             '체육': [100, 90, 90]}
df = pd.DataFrame(exam_data)
print(df)
print(type(df))
print('\n')

# '수학' 점수 데이터만 선택. 변수 math에 저장
math = df['수학']
print(math)
print(type(math))
print('\n')

# '영어' 점수 데이터만 선택. 변수 english에 저장
english = df.영어
print(english)
print(type(english))
```

<pre>
   이름  수학  영어   음악   체육
0  서준  90  98   85  100
1  우현  80  89   95   90
2  인아  70  95  100   90
<class 'pandas.core.frame.DataFrame'>


0    90
1    80
2    70
Name: 수학, dtype: int64
<class 'pandas.core.series.Series'>


0    98
1    89
2    95
Name: 영어, dtype: int64
<class 'pandas.core.series.Series'>
</pre>

```python
# '음악', '체육' 점수 데이터를 선택. 변수 music_gym에 저장
music_gym = df[['음악', '체육']]
print(music_gym)
print(type(music_gym))
print('\n')

# '수학' 점수 데이터만 선택. 변수 math에 저장.
math = df[['수학']]
print(math)
print(type(math))
```

<pre>
    음악   체육
0   85  100
1   95   90
2  100   90
<class 'pandas.core.frame.DataFrame'>


   수학
0  90
1  80
2  70
<class 'pandas.core.frame.DataFrame'>
</pre>
### 원소 선택

데이터프레임의 행 인덱스와 열 이름을 [행, 열] 형식의 2차원 좌표로 입력하여 원소 위치를 지정하는 방법이다. 원소가 위치하는 행과 열의 좌표를 입력하면 해당 위치의 원소가 반환된다. 1개의 행과 2개 이상의 열을 선택하거나 반대로 2개 이상의 열과 1개의 열을 선택하는 경우 시리즈 객체가 반환된다. 2개 이상의 행과 2개 이상의 열을 선택하면, 데이터프레임 객체를 반환한다.



```python
# '이름' 열을 새로운 인덱스로 지정하고, df 객체에 변경 사항 반영
df.set_index('이름', inplace=True)
print(df)
```

<pre>
    수학  영어   음악   체육
이름                  
서준  90  98   85  100
우현  80  89   95   90
인아  70  95  100   90
</pre>

```python
# 데이터프레임 df의 특정 원소 1개 선택('서준'의 '음악' 점수)
a = df.loc['서준', '음악']
print(a)
b = df.iloc[0, 2]
print(b)
```

<pre>
85
85
</pre>

```python
# 데이터프레임 df의 특정 원소 2개 이상 선택('서준'의 '음악', '체육' 점수)
c = df.loc['서준', ['음악', '체육']]
print(c)
d = df.iloc[0, [2, 3]]
print(d)
e = df.loc['서준', '음악':'체육']
print(e)
f = df.iloc[0, 2:]
```

<pre>
음악     85
체육    100
Name: 서준, dtype: int64
음악     85
체육    100
Name: 서준, dtype: int64
음악     85
체육    100
Name: 서준, dtype: int64
</pre>

```python
# df 2개 이상의 행과 열에 속하는 원소들 선택('서준', '우현'의 '음악', '체육' 점수)
g = df.loc[['서준', '우현'], ['음악', '체육']]
print(g)
h = df.iloc[[0, 1], [2, 3]]
print(h)
i = df.loc['서준':'우현', '음악':'체육']
print(i)
j = df.iloc[0:2, 2:]
print(j)
```

<pre>
    음악   체육
이름         
서준  85  100
우현  95   90
    음악   체육
이름         
서준  85  100
우현  95   90
    음악   체육
이름         
서준  85  100
우현  95   90
    음악   체육
이름         
서준  85  100
우현  95   90
</pre>
### 열 추가

데이터프레임에 열을 추가하는 방법이다. "DataFrame 객체['추가하는 열 이름'] = 데이터 값" 이런 식으로 추가하려는 열 이름과 데이터 값을 입력한다. 데이터프레임의 마지막 열에 덧붙이듯 새로운 열을 추가한다. 이때 모든 행에 동일한 값이 적용된다.



```python
print(df)
print('\n')

# 데이터프레임 df에 '국어' 점수 열(column) 추가. 데이터 값은 80 지정
df['국어'] = 80
print(df)
```

<pre>
    수학  영어   음악   체육
이름                  
서준  90  98   85  100
우현  80  89   95   90
인아  70  95  100   90


    수학  영어   음악   체육  국어
이름                      
서준  90  98   85  100  80
우현  80  89   95   90  80
인아  70  95  100   90  80
</pre>
리스트나 배열을 칼럼에 대입할 때는 대입하려는 값의 길이가 DataFrame의 크기와 동일해야 한다. Series를 대입하면 DataFrame의 색인에 따라 값이 대입되며 존재하지 않는 색인에는 결측치가 대입된다.


### 행 추가

데이터프레임에 행을 추가하는 방법이다. 추가하려는 행 이름과 데이터 값을 `loc` 인덱서를 사용하여 입력한다. 하나의 데이터 값을 입력하거나, 열의 개수에 맞게 배열 형태로 여러 개의 값을 입력할 수 있다. 전자의 경우 행의 모든 원소에 같은 값이 추가된다(브로드캐스팅). 후자의 경우 배열의 순서대로 열 위치에 값이 하나씩 추가된다. 또한 행 벡터 자체가 배열이므로, 기존 행을 복사해서 새로운 행에 그대로 추가할 수도 있다.<br><br>

데이터프레임에 새로운 행을 추가할 때는 기존 행 인덱스와 겹치지 않는 새로운 인덱스를 사용한다. 기존 인덱스와 중복되는 경우 새로운 행을 추가하지 않고 개존 행의 원소값을 변경한다.



```python
print(df)
print('\n')

# 새로운 행(row) 추가 - 같은 원소 값 입력
df.loc[3] = 0
print(df)
print('\n')

# 새로운 행(row) 추가 - 원소 값 여러 개의 배열 입력
df.loc[4] = ['동규', 90, 80, 70, 60]
print(df)
print('\n')

# 새로운 행(row) 추가 - 기존 행 복사
df.loc['행5'] = df.loc[3]
print(df)
```

<pre>
    수학  영어   음악   체육  국어
이름                      
서준  90  98   85  100  80
우현  80  89   95   90  80
인아  70  95  100   90  80


    수학  영어   음악   체육  국어
이름                      
서준  90  98   85  100  80
우현  80  89   95   90  80
인아  70  95  100   90  80
3    0   0    0    0   0


    수학  영어   음악   체육  국어
이름                      
서준  90  98   85  100  80
우현  80  89   95   90  80
인아  70  95  100   90  80
3    0   0    0    0   0
4   동규  90   80   70  60


    수학  영어   음악   체육  국어
이름                      
서준  90  98   85  100  80
우현  80  89   95   90  80
인아  70  95  100   90  80
3    0   0    0    0   0
4   동규  90   80   70  60
행5   0   0    0    0   0
</pre>
### 원소 값 변경

데이터프레임의 특정 원소를 선택하고 새로운 데이터 값을 지정해주면 원소 값이 변경된다. 원소 1개를 선택하여 변경할 수도 있고, 여러 개의 원소를 선택하여 한꺼번에 값을 바꿀 수도 있다. 변경할 원소를 선택할 때 데이터프레임 인덱싱과 슬라이싱 기법을 사용한다.



```python
print(df)
print('\n')

# 데이터프레임 df의 특정 원소를 변경하는 방법: '서준'의 '체육' 점수
df.iloc[0][3] = 80
print(df)
print('\n')

df.loc['서준']['체육'] = 90
print(df)
print('\n')

df.loc['서준', '체육'] = 100
print(df)
```

<pre>
    수학  영어   음악   체육
이름                  
서준  90  98   85  100
우현  80  89   95   90
인아  70  95  100   90


    수학  영어   음악  체육
이름                 
서준  90  98   85  80
우현  80  89   95  90
인아  70  95  100  90


    수학  영어   음악  체육
이름                 
서준  90  98   85  90
우현  80  89   95  90
인아  70  95  100  90


    수학  영어   음악   체육
이름                  
서준  90  98   85  100
우현  80  89   95   90
인아  70  95  100   90
</pre>
여러 개의 원소를 선택하여 새로운 값을 할당하면, 모든 원소를 한꺼번에 같은 값으로 변경할 수 있다. 또한 선택한 원소의 개수에 맞춰 각기 다른 값을 배열 형태로 입력할 수도 있다.



```python
# 데이터프레임 df의 원소 여러 개를 변경하는 방법: '서준'의 '음악', '체육' 점수
df.loc['서준', ['음악', '체육']] = 50
print(df)
print('\n')

df.loc['서준', ['음악', '체육']] = 100, 50
print(df)
```

<pre>
    수학  영어   음악  체육
이름                 
서준  90  98   50  50
우현  80  89   95  90
인아  70  95  100  90


    수학  영어   음악  체육
이름                 
서준  90  98  100  50
우현  80  89   95  90
인아  70  95  100  90
</pre>
### 행, 열의 위치 바꾸기

데이터프레임의 행과 열을 서로 맞바꾸는 방법이다. 선형대수학의 전치행렬과 같은 개념으로 NumPy에서 유래한 행렬 전치 메소드와 속성을 사용한다.<br><br>

전치의 결과로 새로운 객체를 반환하므로, 기존 객체를 변경하기 위해서는 기존 객체에 새로운 객체를 할당해주는 과정이 필요하다.



```python
print(df)
print('\n')

# 데이터프레임 df를 전치하기(메서드 활용)
df = df.transpose()
print(df)
print('\n')

# 데이터프레임 df를 다시 전치하기(클래스 속성 활용)
df = df.T
print(df)
```

<pre>
   이름  수학  영어   음악   체육
0  서준  90  98   85  100
1  우현  80  89   95   90
2  인아  70  95  100   90


      0   1    2
이름   서준  우현   인아
수학   90  80   70
영어   98  89   95
음악   85  95  100
체육  100  90   90


   이름  수학  영어   음악   체육
0  서준  90  98   85  100
1  우현  80  89   95   90
2  인아  70  95  100   90
</pre>