---
layout: single
title:  "CodeUp 기초 5-3(2차원 배열)"
categories: CodeUp
tag: [python, CodeUp]
toc: true
author_profile: false
toc_sticky: true
---

<head>
  <style>
    table.dataframe {
      white-space: normal;
      width: 100%;
      height: 240px;
      display: block;
      overflow: auto;
      font-family: Arial, sans-serif;
      font-size: 0.9rem;
      line-height: 20px;
      text-align: center;
      border: 0px !important;
    }

    table.dataframe th {
      text-align: center;
      font-weight: bold;
      padding: 8px;
    }

    table.dataframe td {
      text-align: center;
      padding: 8px;
    }

    table.dataframe tr:hover {
      background: #b8d1f3; 
    }

    .output_prompt {
      overflow: auto;
      font-size: 0.9rem;
      line-height: 1.45;
      border-radius: 0.3rem;
      -webkit-overflow-scrolling: touch;
      padding: 0.8rem;
      margin-top: 0;
      margin-bottom: 15px;
      font: 1rem Consolas, "Liberation Mono", Menlo, Courier, monospace;
      color: $code-text-color;
      border: solid 1px $border-color;
      border-radius: 0.3rem;
      word-break: normal;
      white-space: pre;
    }

  .dataframe tbody tr th:only-of-type {
      vertical-align: middle;
  }

  .dataframe tbody tr th {
      vertical-align: top;
  }

  .dataframe thead th {
      text-align: center !important;
      padding: 8px;
  }

  .page__content p {
      margin: 0 0 0px !important;
  }

  .page__content p > strong {
    font-size: 0.8rem !important;
  }

  </style>
</head>

# 2차원 배열 순서대로 채우기

<p style="color: red;"><strong>2차원 배열을 패턴에 맞춰 채우는 문제는 먼저 틀을 잡아두고 경우를 나눠서 패턴을 찾고 하나씩 맞춰보자.</strong></p><br>


<strong>1460 : [기초-배열연습] 2차원 배열 순서대로 채우기 1-1</strong><br>

다음과 같은 n\*n 배열 구조를 출력해보자.



입력이 3인 경우 다음과 같이 출력한다.<br>

1 2 3<br>

4 5 6<br>

7 8 9<br>



입력이 5인 경우는 다음과 같이 출력한다.<br>

1 2 3 4 5<br>

6 7 8 9 10<br>

11 12 13 14 15<br>

16 17 18 19 20<br>

21 22 23 24 25



입력이 n인 경우의 2차원 배열을 출력해보자.



```python
# Sol1
n = int(input())

arr = [[n * r + c for c in range(1, n+1)] for r in range(n)]

for i in range(n):
    print(*arr[i])
```

<pre>
4
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16
</pre>

```python
# Sol2
n = int(input())

cnt = 1
arr = [[0] * n for _ in range(n)]

for i in range(n):
    for j in range(n):
        arr[i][j] = cnt
        cnt += 1

for i in range(n):
    print(*arr[i])
```

<pre>
3
1 2 3
4 5 6
7 8 9
</pre>
<strong>1461 : [기초-배열연습] 2차원 배열 순서대로 채우기 1-2</strong><br>

다음과 같은 n\*n 배열 구조를 출력해보자.



입력이 3인 경우 다음과 같이 출력한다.<br>

3 2 1<br>

6 5 4<br>

9 8 7<br>



입력이 5인 경우는 다음과 같이 출력한다.<br>

5 4 3 2 1<br>

10 9 8 7 6<br>

15 14 13 12 11<br>

20 19 18 17 16<br>

25 24 23 22 21<br>



입력이 n인 경우의 2차원 배열을 출력해보자.



```python
# Sol1
n = int(input())

arr = [[n * r + c for c in range(n, 0, -1)] for r in range(n)]

for i in range(n):
    print(*arr[i])
```

<pre>
3
3 2 1
6 5 4
9 8 7
</pre>

```python
# Sol2
n = int(input())

cnt = 1
arr = [[0] * n for _ in range(n)]

for i in range(n):
    for j in range(n-1, -1, -1):
        arr[i][j] = cnt
        cnt += 1

for i in range(n):
    print(*arr[i])
```

<pre>
3
3 2 1
6 5 4
9 8 7
</pre>
<strong>1462 : [기초-배열연습] 2차원 배열 순서대로 채우기 1-3</strong><br>

다음과 같은 n\*n 배열 구조를 출력해보자.



입력이 3인 경우 다음과 같이 출력한다.<br>

1 4 7<br>

2 5 8<br>

3 6 9<br>



입력이 5인 경우는 다음과 같이 출력한다.<br>

1 6 11 16 21<br>

2 7 12 17 22<br>

3 8 13 18 23<br>

4 9 14 19 24<br>

5 10 15 20 25



입력이 n인 경우의 2차원 배열을 출력해보자.



```python
# Sol1
n = int(input())

arr = [[n * c + r for c in range(n)] for r in range(1, n+1)]

for i in range(n):
    print(*arr[i])
```

<pre>
3
1 4 7
2 5 8
3 6 9
</pre>

```python
# Sol2
n = int(input())

cnt = 1
arr = [[0] * n for _ in range(n)]

for i in range(n):
    for j in range(n):
        arr[j][i] = cnt
        cnt += 1
        
for i in range(n):
    print(*arr[i])
```

<pre>
3
1 4 7
2 5 8
3 6 9
</pre>
<strong>1463 : [기초-배열연습] 2차원 배열 순서대로 채우기 1-4</strong><br>

다음과 같은 n\*n 배열 구조를 출력해보자.



입력이 3인 경우 다음과 같이 출력한다.<br>

3 6 9<br>

2 5 8<br>

1 4 7<br>



입력이 5인 경우는 다음과 같이 출력한다.<br>

5 10 15 20 25<br>

4 9 14 19 24<br>

3 8 13 18 23<br>

2 7 12 17 22<br>

1 6 11 16 21



입력이 n인 경우의 2차원 배열을 출력해보자.



```python
# Sol1
n = int(input())

arr = [[n * c - r for c in range(1, n+1)] for r in range(n)]

for i in range(n):
    print(*arr[i])
```

<pre>
3
3 6 9
2 5 8
1 4 7
</pre>

```python
# Sol2
n = int(input())

cnt = 1
for i in range(n):
    for j in range(n-1, -1, -1):
        arr[j][i] = cnt
        cnt += 1

for i in range(n):
    print(*arr[i])
```

<pre>
3
3 6 9
2 5 8
1 4 7
</pre>
<strong>1464 : [기초-배열연습] 2차원 배열 순서대로 채우기 1-5</strong><br>

다음과 같은 n\*m 배열 구조를 출력해보자.



입력이 3 4인 경우 다음과 같이 출력한다.<br>

12 11 10 9<br>

8 7 6 5<br>

4 3 2 1<br>



입력이 4 5인 경우는 다음과 같이 출력한다.<br>

20 19 18 17 16<br>

15 14 13 12 11<br>

10 9 8 7 6<br>

5 4 3 2 1



입력이 n m인 경우의 2차원 배열을 출력해보자.



```python
# Sol1
n, m = map(int, input().split())

arr = [[m*r - c for c in range(m)] for r in range(n, 0, -1)]

for i in range(n):
    print(*arr[i])
```

<pre>
3 4
12 11 10 9
8 7 6 5
4 3 2 1
</pre>

```python
# Sol2
n, m = map(int, input().split())

cnt = 1
arr = [[0] * m for _ in range(n)]

for i in range(n-1, -1, -1):
    for j in range(m-1, -1, -1):
        arr[i][j] = cnt
        cnt += 1

for i in range(n):
    print(*arr[i])
```

<pre>
3 4
12 11 10 9
8 7 6 5
4 3 2 1
</pre>
<strong>1465 : [기초-배열연습] 2차원 배열 순서대로 채우기 1-6</strong><br>

다음과 같은 n\*m 배열 구조를 출력해보자.



입력이 3 4인 경우 다음과 같이 출력한다.<br>

9 10 11 12<br>

5 6 7 8<br>

1 2 3 4<br>



입력이 4 5인 경우는 다음과 같이 출력한다.<br>

16 17 18 19 20<br>

11 12 13 14 15<br>

6 7 8 9 10<br>

1 2 3 4 5



입력이 n m인 경우의 2차원 배열을 출력해보자.



```python
# Sol1
n, m = map(int, input().split())

arr = [[r * m + c for c in range(1, m+1)] for r in range(n-1, -1, -1)]

for i in range(n):
    print(*arr[i])
```

<pre>
3 4
9 10 11 12
5 6 7 8
1 2 3 4
</pre>

```python
# Sol2
n, m = map(int, input().split())

cnt = 1
arr = [[0] * m for _ in range(n)]

for i in range(n-1, -1, -1):
    for j in range(m):
        arr[i][j] = cnt
        cnt += 1

for i in range(n):
    print(*arr[i])
```

<pre>
3 4
9 10 11 12
5 6 7 8
1 2 3 4
</pre>
<strong>1466 : [기초-배열연습] 2차원 배열 순서대로 채우기 1-7</strong><br>

다음과 같은 n\*m 배열 구조를 출력해보자.



입력이 3 4인 경우 다음과 같이 출력한다.<br>

12 9 6 3<br>

11 8 5 2<br>

10 7 4 1<br>



입력이 4 5인 경우는 다음과 같이 출력한다.<br>

20 16 12 8 4<br>

19 15 11 7 3<br>

18 14 10 6 2<br>

17 13 9 5 1



입력이 n m인 경우의 2차원 배열을 출력해보자.



```python
# Sol1
n, m = map(int, input().split())

arr = [[n * c - r for c in range(m, 0, -1)] for r in range(n)]

for i in range(n):
    print(*arr[i])
```

<pre>
3 4
12 9 6 3
11 8 5 2
10 7 4 1
</pre>

```python
# Sol2
n, m = map(int, input().split())

cnt = 1
arr = [[0] * m for _ in range(n)]

for i in range(m-1, -1, -1):
    for j in range(n-1, -1, -1):
        arr[j][i] = cnt
        cnt += 1

for i in range(n):
    print(*arr[i])
```

<pre>
4 5
20 16 12 8 4
19 15 11 7 3
18 14 10 6 2
17 13 9 5 1
</pre>
<strong>1467 : [기초-배열연습] 2차원 배열 순서대로 채우기 1-8</strong><br>

다음과 같은 n\*m 배열 구조를 출력해보자.



입력이 3 4인 경우 다음과 같이 출력한다.<br>

10 7 4 1<br>

11 8 5 2<br>

12 9 6 3



입력이 4 5인 경우는 다음과 같이 출력한다.<br>

17 13 9 5 1<br>

18 14 10 6 2<br>

19 15 11 7 3<br>

20 16 12 8 4



입력이 n m인 경우의 2차원 배열을 출력해보자.



```python
# Sol1
n, m = map(int, input().split())

arr = [[c*n + r for c in range(m-1, -1, -1)] for r in range(1, n+1)]

for i in range(n):
    print(*arr[i])
```

<pre>
3 4
10 7 4 1
11 8 5 2
12 9 6 3
</pre>

```python
# Sol2
n, m = map(int, input().split())

cnt = 1
arr = [[0] * m for _ in range(n)]

for i in range(m-1, -1, -1):
    for j in range(n):
        arr[j][i] = cnt
        cnt += 1
        
for i in range(n):
    print(*arr[i])
```

<pre>
3 4
10 7 4 1
11 8 5 2
12 9 6 3
</pre>

# 2차원 배열 지그재그 채우기

<strong>1468 : [기초-배열연습] 2차원 배열 지그재그 채우기 2-1</strong><br>

다음과 같은 n\*n 배열 구조를 출력해보자.



입력이 3인 경우 다음과 같이 출력한다.<br>

1 2 3<br>

6 5 4<br>

7 8 9



입력이 5인 경우는 다음과 같이 출력한다.<br>

1 2 3 4 5<br>

10 9 8 7 6<br>

11 12 13 14 15<br>

20 19 18 17 16<br>

21 22 23 24 25



입력이 n인 경우의 2차원 배열을 출력해보자.



```python
# Sol1
n = int(input())

# 만약 짝수번 줄이면 정방향
# 홀수번 줄이면 역방향 진행
arr = [[(n * r + c + 1) if r % 2 == 0 else ((r+1) * n - c) for c in range(n)]for r in range(n)]

for i in range(n):
    print(*arr[i])
```

<pre>
5
1 2 3 4 5
10 9 8 7 6
11 12 13 14 15
20 19 18 17 16
21 22 23 24 25
</pre>

```python
# Sol2
n = int(input())

cnt = 1
arr = [[0] * n for _ in range(n)]

for i in range(n):
    for j in range(n):
        if i % 2 == 0:
            arr[i][j] = cnt
        else:
            arr[i][n-j-1] = cnt
        
        cnt += 1

for i in range(n):
    print(*arr[i])
```

<pre>
3
1 2 3
6 5 4
7 8 9
</pre>
<strong>1469 : [기초-배열연습] 2차원 배열 지그재그 채우기 2-2</strong><br>

다음과 같은 n\*n 배열 구조를 출력해보자.



입력이 3인 경우 다음과 같이 출력한다.<br>

3 2 1<br>

4 5 6<br>

9 8 7



입력이 5인 경우는 다음과 같이 출력한다.<br>

5 4 3 2 1<br>

6 7 8 9 10<br>

15 14 13 12 11<br>

16 17 18 19 20<br>

25 24 23 22 21



입력이 n인 경우의 2차원 배열을 출력해보자.



```python
# Sol1
n = int(input())

# 짝수 줄이면 역방향 진행
# 홀수 줄이면 정방향 진행
arr = [[(n*(r+1) - c) if r % 2 == 0 else (n*r + (c+1)) for c in range(n)] for r in range(n)]

for i in range(n):
    print(*arr[i])
```

<pre>
4
4 3 2 1
5 6 7 8
12 11 10 9
13 14 15 16
</pre>

```python
# Sol2
n = int(input())

cnt = 1
arr = [[0] * n for _ in range(n)]

for i in range(n):
    for j in range(n):
        if i % 2 == 0:
            arr[i][n-j-1] = cnt
        else:
            arr[i][j] = cnt
            
        cnt += 1

for i in range(n):
    print(*arr[i])
```

<pre>
5
5 4 3 2 1
6 7 8 9 10
15 14 13 12 11
16 17 18 19 20
25 24 23 22 21
</pre>
<strong>1470 : [기초-배열연습] 2차원 배열 지그재그 채우기 2-3</strong><br>

다음과 같은 n\*n 배열 구조를 출력해보자.



입력이 3인 경우 다음과 같이 출력한다.<br>

1 6 7<br>

2 5 8<br>

3 4 9



입력이 5인 경우는 다음과 같이 출력한다.<br>

1 10 11 20 21<br>

2 9 12 19 22<br>

3 8 13 18 23<br>

4 7 14 17 24<br>

5 6 15 16 25



입력이 n인 경우의 2차원 배열을 출력해보자.



```python
# Sol1
n = int(input())

# 짝수 열이면 정방향으로 내려감
# 홀수 열이면 역방향으로 내려감
arr = [[(n*c + (r+1)) if c % 2 == 0 else ((c+1)*n - r) for c in range(n)] for r in range(n)]

for i in range(n):
    print(*arr[i])
```

<pre>
5
1 10 11 20 21
2 9 12 19 22
3 8 13 18 23
4 7 14 17 24
5 6 15 16 25
</pre>

```python
# Sol2
n = int(input())

cnt = 1
arr = [[0] * n for _ in range(n)]

for i in range(n):
    for j in range(n):
        if i % 2 == 0:
            arr[j][i] = cnt
        else:
            arr[n-j-1][i] = cnt
        
        cnt += 1

for i in range(n):
    print(*arr[i])
```

<pre>
5
1 10 11 20 21
2 9 12 19 22
3 8 13 18 23
4 7 14 17 24
5 6 15 16 25
</pre>
<strong>1471 : [기초-배열연습] 2차원 배열 지그재그 채우기 2-4</strong><br>

다음과 같은 n\*n 배열 구조를 출력해보자.



입력이 3인 경우 다음과 같이 출력한다.<br>

3 4 9<br>

2 5 8<br>

1 6 7



입력이 5인 경우는 다음과 같이 출력한다.<br>

5 6 15 16 25<br>

4 7 14 17 24<br>

3 8 13 18 23<br>

2 9 12 19 22<br>

1 10 11 20 21



입력이 n인 경우의 2차원 배열을 출력해보자.



```python
# Sol1
n = int(input())

# 짝수 열이면 역방향으로 내려감
# 홀수 열이면 정방향으로 내려감
arr = [[((c+1)*n-r) if c % 2 == 0 else (c*n + (r+1)) for c in range(n)] for r in range(n)]

for i in range(n):
    print(*arr[i])
```

<pre>
5
5 6 15 16 25
4 7 14 17 24
3 8 13 18 23
2 9 12 19 22
1 10 11 20 21
</pre>

```python
# Sol2
n = int(input())

cnt = 1
arr = [[0] * n for _ in range(n)]

for i in range(n):
    for j in range(n):
        if i % 2 != 0:
            arr[j][i] = cnt
        else:
            arr[n-j-1][i] = cnt
            
        cnt += 1

for i in range(n):
    print(*arr[i])
```

<pre>
5
5 6 15 16 25
4 7 14 17 24
3 8 13 18 23
2 9 12 19 22
1 10 11 20 21
</pre>
<strong>1472 : [기초-배열연습] 2차원 배열 지그재그 채우기 2-5</strong><br>

다음과 같은 n\*m 배열 구조를 출력해보자.



입력이 3 4인 경우 다음과 같이 출력한다.<br>

12 11 10 9<br>

5 6 7 8<br>

4 3 2 1



입력이 4 5인 경우는 다음과 같이 출력한다.<br>

16 17 18 19 20<br>

15 14 13 12 11<br>

6 7 8 9 10<br>

5 4 3 2 1



입력이 n m인 경우의 2차원 배열을 출력해보자.



```python
# Sol1
n, m = map(int, input().split())

# 행의 개수(n)이 짝수인 경우와 홀수인 경우로 나눔
# (n이 짝수이고 짝수인 줄)과 (n이 홀수이고 홀수인 줄)은 정방향 진행
# (n이 짝수이고 홀수인 줄)과 (n이 홀수이고 짝수인 줄)은 역방향 진행
arr = [[(((n-1-r)*m+(c+1)) if r % 2 == 0 else ((n-r)*m-c)) if n % 2 == 0 else ((n-r)*m-c) if r % 2 == 0 else (((n-1-r)*m+(c+1))) for c in range(m)] for r in range(n)]

for i in range(n):
    print(*arr[i])
```

<pre>
4 5
16 17 18 19 20
15 14 13 12 11
6 7 8 9 10
5 4 3 2 1
</pre>

```python
# Sol2
n, m = map(int, input().split())

cnt = 1
arr = [[0] * m for _ in range(n)]

for i in range(n):
    for j in range(m):
        if i % 2 == 0:
            arr[n-i-1][m-j-1] = cnt
        else:
            arr[n-i-1][j] = cnt
        
        cnt += 1
    
for i in range(n):
    print(*arr[i])
```

<pre>
4 5
16 17 18 19 20
15 14 13 12 11
6 7 8 9 10
5 4 3 2 1
</pre>
<strong>1473 : [기초-배열연습] 2차원 배열 지그재그 채우기 2-6</strong><br>

다음과 같은 n\*m 배열 구조를 출력해보자.



입력이 3 4인 경우 다음과 같이 출력한다.<br>

9 10 11 12<br>

8 7 6 5<br>

1 2 3 4



입력이 4 5인 경우는 다음과 같이 출력한다.<br>

20 19 18 17 16<br>

11 12 13 14 15<br>

10 9 8 7 6<br>

1 2 3 4 5



입력이 n m인 경우의 2차원 배열을 출력해보자.



```python
# Sol1
n, m = map(int, input().split())

# 행의 개수(n)이 짝수인 경우와 홀수인 경우로 나눔
# (n이 짝수이고 짝수인 줄)과 (n이 홀수이고 홀수인 줄)은 역방향 진행
# (n이 짝수이고 홀수인 줄)과 (n이 홀수이고 짝수인 줄)은 정방향 진행
arr = [[(((n-r)*m-c) if r % 2 == 0 else ((n-1-r)*m+(c+1))) if n % 2 == 0 else (((n-1-r)*m+(c+1)) if r % 2 == 0 else ((n-r)*m-c)) for c in range(m)] for r in range(n)]

for i in range(n):
    print(*arr[i])
```

<pre>
3 4
9 10 11 12
8 7 6 5
1 2 3 4
</pre>

```python
# Sol2
n, m = map(int, input().split())

cnt = 1
arr = [[0] * m for _ in range(n)]

for i in range(n):
    for j in range(m):
        if i % 2 == 0:
            arr[n-i-1][j] = cnt
        else:
            arr[n-i-1][m-j-1] = cnt
            
        cnt += 1

for i in range(n):
    print(*arr[i])
```

<pre>
4 5
20 19 18 17 16
11 12 13 14 15
10 9 8 7 6
1 2 3 4 5
</pre>
<strong>1474 : [기초-배열연습] 2차원 배열 지그재그 채우기 2-7</strong><br>

다음과 같은 n\*m 배열 구조를 출력해보자.<br>



입력이 3 4인 경우 다음과 같이 출력한다.<br>

10 9 4 3<br>

11 8 5 2<br>

12 7 6 1



입력이 4 5인 경우는 다음과 같이 출력한다.<br>

20 13 12 5 4<br>

19 14 11 6 3<br>

18 15 10 7 2<br>

17 16 9 8 1



입력이 n m인 경우의 2차원 배열을 출력해보자.



```python
# Sol1
n, m = map(int, input().split())

arr = [[(((m-(c+1))*n+r+1) if c % 2 == 0 else ((m-c)*n-r)) if m % 2 == 0 else (((m-c)*n-r))if c % 2 == 0 else (((m-(c+1))*n+r+1)) for c in range(m)] for r in range(n)]

for i in range(n):
    print(*arr[i])
```

<pre>
7 5
35 22 21 8 7
34 23 20 9 6
33 24 19 10 5
32 25 18 11 4
31 26 17 12 3
30 27 16 13 2
29 28 15 14 1
</pre>

```python
# Sol2
n, m = map(int, input().split())

cnt = 1
arr = [[0] * m for _ in range(n)]


for i in range(m):
    for j in range(n):
        if i % 2 != 0:
            arr[j][m-i-1] = cnt
        else:
            arr[n-j-1][m-i-1] = cnt
            
        cnt += 1
    
for i in range(n):
    print(*arr[i])
```

<pre>
4 5
20 13 12 5 4
19 14 11 6 3
18 15 10 7 2
17 16 9 8 1
</pre>
<strong>1475 : [기초-배열연습] 2차원 배열 지그재그 채우기 2-8</strong><br>

다음과 같은 n\*m 배열 구조를 출력해보자.<br>



입력이 3 4인 경우 다음과 같이 출력한다.<br>

12 7 6 1<br>

11 8 5 2<br>

10 9 4 3



입력이 4 5인 경우는 다음과 같이 출력한다.<br>

17 16 9 8 1<br>

18 15 10 7 2<br>

19 14 11 6 3<br>

20 13 12 5 4



입력이 n m인 경우의 2차원 배열을 출력해보자.



```python
# Sol1
n, m = map(int, input().split())

arr = [[(((m-c)*n-r) if c % 2 == 0 else ((m-1-c)*n+r+1)) if m % 2 == 0 else (((m-1-c)*n+r+1) if c % 2 == 0 else ((m-c)*n-r)) for c in range(m)] for r in range(n)]

for i in range(n):
    print(*arr[i])
```

<pre>
4 5
17 16 9 8 1
18 15 10 7 2
19 14 11 6 3
20 13 12 5 4
</pre>

```python
# Sol2
n, m = map(int, input().split())

cnt = 1
arr = [[0] * m for _ in range(n)]

for i in range(m):
    for j in range(n):
        if i % 2 == 0:
            arr[j][m-i-1] = cnt
        else:
            arr[n-j-1][m-i-1] = cnt
            
        cnt += 1

for i in range(n):
    print(*arr[i])
```

<pre>
4 5
17 16 9 8 1
18 15 10 7 2
19 14 11 6 3
20 13 12 5 4
</pre>

# 2차원 배열 빗금 채우기

<strong>1476 : [기초-배열연습] 2차원 배열 빗금 채우기 3-1</strong><br>

다음과 같은 n\*m 배열 구조를 출력해보자.



입력이 3 4인 경우 다음과 같이 출력한다.<br>

1 3 6 9<br>

2 5 8 11<br>

4 7 10 12



입력이 4 5인 경우는 다음과 같이 출력한다.<br>

1 3 6 10 14<br>

2 5 9 13 17<br>

4 8 12 16 19<br>

7 11 15 18 20



입력이 n m인 경우의 2차원 배열을 출력해보자.



```python
n, m = map(int, input().split())

cnt = 1
arr = [[0] * m for _ in range(n)]

for i in range(n+m):
    for j in range(m):
        for k in range(n):
            if j + k == i:
                arr[k][j] = cnt
                cnt += 1

for i in range(n):
    print(*arr[i])
```

<pre>
3 4
1 3 6 9
2 5 8 11
4 7 10 12
</pre>
<strong>1477 : [기초-배열연습] 2차원 배열 빗금 채우기 3-2</strong><br>

다음과 같은 n\*m 배열 구조를 출력해보자.



입력이 3 4인 경우 다음과 같이 출력한다.<br>

1 2 4 7<br>

3 5 8 10<br>

6 9 11 12



입력이 4 5인 경우는 다음과 같이 출력한다.<br>

1 2 4 7 11<br>

3 5 8 12 15<br>

6 9 13 16 18<br>

10 14 17 19 20



입력이 n m인 경우의 2차원 배열을 출력해보자.



```python
n, m = map(int, input().split())

cnt = 1
arr = [[0] * m for _ in range(n)]

for i in range(n+m):
    for j in range(n):
        for k in range(m):
            if j + k == i:
                arr[j][k] = cnt
                cnt += 1
                
for i in range(n):
    print(*arr[i])
```

<pre>
4 5
1 2 4 7 11
3 5 8 12 15
6 9 13 16 18
10 14 17 19 20
</pre>
<strong>1478 : [기초-배열연습] 2차원 배열 빗금 채우기 3-3</strong><br>

다음과 같은 n\*m 배열 구조를 출력해보자.



입력이 3 4인 경우 다음과 같이 출력한다.<br>

7 4 2 1<br>

10 8 5 3<br>

12 11 9 6



입력이 4 5인 경우는 다음과 같이 출력한다.<br>

11 7 4 2 1<br>

15 12 8 5 3<br>

18 16 13 9 6<br>

20 19 17 14 10



입력이 n m인 경우의 2차원 배열을 출력해보자.



```python
n, m = map(int, input().split())

cnt = 1
arr = [[0] * m for _ in range(n)]

for i in range(n+m):
    for j in range(n):
        for k in range(m):
            if j + k == i:
                arr[j][m-k-1] = cnt
                cnt += 1
                
for i in range(n):
    print(*arr[i])
```

<pre>
3 4
7 4 2 1
10 8 5 3
12 11 9 6
</pre>
<strong>1479 : [기초-배열연습] 2차원 배열 빗금 채우기 3-4</strong><br>

다음과 같은 n\*m 배열 구조를 출력해보자.



입력이 3 4인 경우 다음과 같이 출력한다.<br>

9 6 3 1<br>

11 8 5 2<br>

12 10 7 4



입력이 4 5인 경우는 다음과 같이 출력한다.<br>

14 10 6 3 1<br>

17 13 9 5 2<br>

19 16 12 8 4<br>

20 18 15 11 7



입력이 n m인 경우의 2차원 배열을 출력해보자.



```python
n, m = map(int, input().split())

cnt = 1
arr = [[0] * m for _ in range(n)]

for i in range(n+m):
    for j in range(m):
        for k in range(n):
            if j + k == i:
                arr[k][m-j-1] = cnt
                cnt += 1
                
for i in range(n):
    print(*arr[i])
```

<pre>
3 4
9 6 3 1
11 8 5 2
12 10 7 4
</pre>
<strong>1480 : [기초-배열연습] 2차원 배열 빗금 채우기 3-5</strong><br>

다음과 같은 n\*m 배열 구조를 출력해보자.



입력이 3 4인 경우 다음과 같이 출력한다.<br>

12 10 7 4<br>

11 8 5 2<br>

9 6 3 1



입력이 4 5인 경우는 다음과 같이 출력한다.<br>

20 18 15 11 7<br>

19 16 12 8 4<br>

17 13 9 5 2<br>

14 10 6 3 1



입력이 n m인 경우의 2차원 배열을 출력해보자.



```python
n, m = map(int, input().split())

cnt = 1
arr = [[0] * m for _ in range(n)]

for i in range(n+m):
    for j in range(m):
        for k in range(n):
            if j + k == i:
                arr[n-k-1][m-j-1] = cnt
                cnt += 1
                
for i in range(n):
    print(*arr[i])
```

<pre>
3 4
12 10 7 4
11 8 5 2
9 6 3 1
</pre>
<strong>1481 : [기초-배열연습] 2차원 배열 빗금 채우기 3-6</strong><br>

다음과 같은 n\*m 배열 구조를 출력해보자.



입력이 3 4인 경우 다음과 같이 출력한다.<br>

12 11 9 6<br>

10 8 5 3<br>

7 4 2 1



입력이 4 5인 경우는 다음과 같이 출력한다.<br>

20 19 17 14 10<br>

18 16 13 9 6<br>

15 12 8 5 3<br>

11 7 4 2 1



입력이 n m인 경우의 2차원 배열을 출력해보자.



```python
n, m = map(int, input().split())

cnt = 1
arr = [[0] * m for _ in range(n)]

for i in range(n+m):
    for j in range(n):
        for k in range(m):
            if j + k == i:
                arr[n-j-1][m-k-1] = cnt
                cnt += 1
            
for i in range(n):
    print(*arr[i])
```

<pre>
4 5
20 19 17 14 10
18 16 13 9 6
15 12 8 5 3
11 7 4 2 1
</pre>
<strong>1482 : [기초-배열연습] 2차원 배열 빗금 채우기 3-7</strong><br>

다음과 같은 n\*m 배열 구조를 출력해보자.



입력이 3 4인 경우 다음과 같이 출력한다.<br>

6 9 11 12<br>

3 5 8 10<br>

1 2 4 7



입력이 4 5인 경우는 다음과 같이 출력한다.<br>

10 14 17 19 20<br>

6 9 13 16 18<br>

3 5 8 12 15<br>

1 2 4 7 11



입력이 n m인 경우의 2차원 배열을 출력해보자.



```python
n, m = map(int, input().split())

cnt = 1
arr = [[0] * m for _ in range(n)]

for i in range(n+m):
    for j in range(n):
        for k in range(m):
            if j + k == i:
                arr[n-j-1][k] = cnt
                cnt += 1
                
for i in range(n):
    print(*arr[i])
```

<pre>
3 4
6 9 11 12
3 5 8 10
1 2 4 7
</pre>
<strong>1483 : [기초-배열연습] 2차원 배열 빗금 채우기 3-8</strong><br>

다음과 같은 n\*m 배열 구조를 출력해보자.



입력이 3 4인 경우 다음과 같이 출력한다.<br>

4 7 10 12<br>

2 5 8 11<br>

1 3 6 9



입력이 4 5인 경우는 다음과 같이 출력한다.<br>

7 11 15 18 20<br>

4 8 12 16 19<br>

2 5 9 13 17<br>

1 3 6 10 14



입력이 n m인 경우의 2차원 배열을 출력해보자.



```python
n, m = map(int, input().split())

cnt = 1
arr = [[0] * m for _ in range(n)]

for i in range(n+m):
    for j in range(m):
        for k in range(n):
            if j + k == i:
                arr[n-k-1][j] = cnt
                cnt += 1
                
for i in range(n):
    print(*arr[i])
```

<pre>
4 5
7 11 15 18 20
4 8 12 16 19
2 5 9 13 17
1 3 6 10 14
</pre>

# 2차원 배열 달팽이 채우기

<strong>달팽이 채우기는 시작인 1의 위치와 끝인 n\*m의 위치를 확인 후 방향(step), 값(cnt), 시작 위치(row, column)을 정한다.</strong> 


<strong>1484 : [기초-배열연습] 2차원 배열 달팽이 채우기 4-1</strong><br>

다음과 같은 n\*m 배열 구조를 출력해보자.



입력이 3 4인 경우 다음과 같이 출력한다.<br>

1 2 3 4<br>

10 11 12 5<br>

9 8 7 6



입력이 4 5인 경우는 다음과 같이 출력한다.<br>

1 2 3 4 5<br>

14 15 16 17 6<br>

13 20 19 18 7<br>

12 11 10 9 8



입력이 n m인 경우의 2차원 배열을 출력해보자.



```python
n, m = map(int, input().split())

arr = [[0] * m for _ in range(n)]
row, column, cnt = 0, -1, 0
row_size, column_size = n, m
step = 1

while row_size and column_size:
    for _ in range(column_size):
        cnt += 1
        column += step
        arr[row][column] = cnt
        
    row_size -= 1
    
    for _ in range(row_size):
        cnt += 1
        row += step
        arr[row][column] = cnt
        
    column_size -= 1
    step = -step
    
for i in range(n):
    print(*arr[i])
```

<pre>
3 4
1 2 3 4
10 11 12 5
9 8 7 6
</pre>
<strong>1485 : [기초-배열연습] 2차원 배열 달팽이 채우기 4-2</strong><br>

다음과 같은 n\*m 배열 구조를 출력해보자.



입력이 3 4인 경우 다음과 같이 출력한다.<br>

12 11 10 9<br>

3 2 1 8<br>

4 5 6 7



입력이 4 5인 경우는 다음과 같이 출력한다.<br>

20 19 18 17 16<br>

7 6 5 4 15<br>

8 1 2 3 14<br>

9 10 11 12 13



입력이 n m인 경우의 2차원 배열을 출력해보자.



```python
n, m = map(int, input().split())

arr = [[0] * m for _ in range(n)]
row, column, cnt = 0, -1, n*m+1
row_size, column_size = n, m
step = 1

while row_size and column_size:
    for _ in range(column_size):
        cnt -= 1
        column += step
        arr[row][column] = cnt
        
    row_size -= 1
    
    for _ in range(row_size):
        cnt -= 1
        row += step
        arr[row][column] = cnt
        
    column_size -= 1
    step = -step
    
for i in range(n):
    print(*arr[i])
```

<pre>
4 5
20 19 18 17 16
7 6 5 4 15
8 1 2 3 14
9 10 11 12 13
</pre>
<strong>1486 : [기초-배열연습] 2차원 배열 달팽이 채우기 4-3</strong><br>

다음과 같은 n\*m 배열 구조를 출력해보자.



입력이 3 4인 경우 다음과 같이 출력한다.<br>

8 9 10 1<br>

7 12 11 2<br>

6 5 4 3



입력이 4 5인 경우는 다음과 같이 출력한다.<br>

11 12 13 14 1<br>

10 19 20 15 2<br>

9 18 17 16 3<br>

8 7 6 5 4



입력이 n m인 경우의 2차원 배열을 출력해보자.



```python
n, m = map(int, input().split())

arr = [[0] * m for _ in range(n)]
row, column, cnt = -1, m-1, 0
row_size, column_size = n, m
step = 1

while row_size and column_size:
    for _ in range(row_size):
        cnt += 1
        row += step
        arr[row][column] = cnt
        
    step = -step
    column_size -= 1
    
    for _ in range(column_size):
        cnt += 1
        column += step
        arr[row][column] = cnt
        
    row_size -= 1
    
for i in range(n):
    print(*arr[i])
```

<pre>
3 4
8 9 10 1
7 12 11 2
6 5 4 3
</pre>
<strong>1487 : [기초-배열연습] 2차원 배열 달팽이 채우기 4-4</strong><br>

다음과 같은 n\*m 배열 구조를 출력해보자.



입력이 3 4인 경우 다음과 같이 출력한다.<br>

5 4 3 12<br>

6 1 2 11<br>

7 8 9 10



입력이 4 5인 경우는 다음과 같이 출력한다.<br>

10 9 8 7 20<br>

11 2 1 6 19<br>

12 3 4 5 18<br>

13 14 15 16 17



입력이 n m인 경우의 2차원 배열을 출력해보자.



```python
n, m = map(int, input().split())

arr = [[0] * m for _ in range(n)]
row, column, cnt = -1, m-1, n*m+1
row_size, column_size = n, m
step = 1

while row_size and column_size:
    for _ in range(row_size):
        cnt -= 1
        row += step
        arr[row][column] = cnt
        
    step = -step
    column_size -= 1
    
    for _ in range(column_size):
        cnt -= 1
        column += step
        arr[row][column] = cnt
        
    row_size -= 1
    
for i in range(n):
    print(*arr[i])
```

<pre>
3 4
5 4 3 12
6 1 2 11
7 8 9 10
</pre>
<strong>1488 : [기초-배열연습] 2차원 배열 달팽이 채우기 4-5</strong><br>

다음과 같은 n\*m 배열 구조를 출력해보자.



입력이 3 4인 경우 다음과 같이 출력한다.<br>

6 7 8 9<br>

5 12 11 10<br>

4 3 2 1



입력이 4 5인 경우는 다음과 같이 출력한다.<br>

8 9 10 11 12<br>

7 18 19 20 13<br>

6 17 16 15 14<br>

5 4 3 2 1



입력이 n m인 경우의 2차원 배열을 출력해보자.



```python
n, m = map(int, input().split())

arr = [[0] * m for _ in range(n)]
row, column, cnt = n-1, m, 0
row_size, column_size = n, m
step = -1

while row_size and column_size:
    for _ in range(column_size):
        cnt += 1
        column += step
        arr[row][column] = cnt
        
    row_size -= 1
    
    for _ in range(row_size):
        cnt += 1
        row += step
        arr[row][column] = cnt
    
    column_size -= 1
    step = -step
    
for i in range(n):
    print(*arr[i])
```

<pre>
4 5
8 9 10 11 12
7 18 19 20 13
6 17 16 15 14
5 4 3 2 1
</pre>
<strong>1489 : [기초-배열연습] 2차원 배열 달팽이 채우기 4-6</strong><br>

다음과 같은 n\*m 배열 구조를 출력해보자.



입력이 3 4인 경우 다음과 같이 출력한다.<br>

7 6 5 4<br>

8 1 2 3<br>

9 10 11 12



입력이 4 5인 경우는 다음과 같이 출력한다.<br>

13 12 11 10 9<br>

14 3 2 1 8<br>

15 4 5 6 7<br>

16 17 18 19 20



입력이 n m인 경우의 2차원 배열을 출력해보자.



```python
n, m = map(int, input().split())

arr = [[0] * m for _ in range(n)]
row, column, cnt = n-1, m, n*m+1
row_size, column_size = n, m
step = -1

while row_size and column_size:
    for _ in range(column_size):
        cnt -= 1
        column += step
        arr[row][column] = cnt
        
    row_size -= 1
    
    for _ in range(row_size):
        cnt -= 1
        row += step
        arr[row][column] = cnt
        
    column_size -= 1
    step = -step
    
for i in range(n):
    print(*arr[i])
```

<pre>
3 4
7 6 5 4
8 1 2 3
9 10 11 12
</pre>
<strong>1490 : [기초-배열연습] 2차원 배열 달팽이 채우기 4-7</strong><br>

다음과 같은 n\*m 배열 구조를 출력해보자.



입력이 3 4인 경우 다음과 같이 출력한다.<br>

3 4 5 6<br>

2 11 12 7<br>

1 10 9 8



입력이 4 5인 경우는 다음과 같이 출력한다.<br>

4 5 6 7 8<br>

3 16 17 18 9<br>

2 15 20 19 10<br>

1 14 13 12 11



입력이 n m인 경우의 2차원 배열을 출력해보자.



```python
n, m = map(int, input().split())

arr = [[0] * m for _ in range(n)]
row, column, cnt = n, 0, 0
row_size, column_size = n, m
step = -1

while row_size and column_size:
    for _ in range(row_size):
        cnt += 1
        row += step
        arr[row][column] = cnt
        
    step = -step
    column_size -= 1
    
    for _ in range(column_size):
        cnt += 1
        column += step
        arr[row][column] = cnt
        
    row_size -= 1
    
for i in range(n):
    print(*arr[i])
```

<pre>
3 4
3 4 5 6
2 11 12 7
1 10 9 8
</pre>
<strong>1491 : [기초-배열연습] 2차원 배열 달팽이 채우기 4-8</strong><br>

다음과 같은 n\*m 배열 구조를 출력해보자.



입력이 3 4인 경우 다음과 같이 출력한다.<br>

10 9 8 7<br>

11 2 1 6<br>

12 3 4 5



입력이 4 5인 경우는 다음과 같이 출력한다.<br>

17 16 15 14 13<br>

18 5 4 3 12<br>

19 6 1 2 11<br>

20 7 8 9 10



입력이 n m인 경우의 2차원 배열을 출력해보자.



```python
n, m = map(int, input().split())

arr = [[0] * m for _ in range(n)]
row, column, cnt = n, 0, n*m+1
row_size, column_size = n, m
step = -1

while row_size and column_size:
    for _ in range(row_size):
        cnt -= 1
        row += step
        arr[row][column] = cnt
        
    step = -step
    column_size -= 1
    
    for _ in range(column_size):
        cnt -= 1
        column += step
        arr[row][column] = cnt
        
    row_size -= 1
    
for i in range(n):
    print(*arr[i])
```

<pre>
4 5
17 16 15 14 13
18 5 4 3 12
19 6 1 2 11
20 7 8 9 10
</pre>

# 누적 합 배열 만들기

<strong>1492 : [기초-배열연습] 1차원 누적 합 배열 만들기 5-1</strong><br>

n개의 데이터를 배열에 입력 받은 후,



1번째 ~ n번째 데이터까지의 합 배열을 만들고 출력해보자.



5개의 데이터가 다음과 같이 입력되었을 때,



1 2 3 4 5



아래와 같이 출력하면 된다.



1 3 6 10 15





k번째 위치에 저장되어야 하는 값은 다음과 같이 표현할 수도 있다.<br>

s[k] = a[1] + a[2] + s[3]+ ... a[k-2] + a[k-1] + a[k]



같은 의미를 가지는 더 간단한 관계식을 사용할 수는 없을까?



```python
n = int(input())
arr = list(map(int, input().split()))

for i in range(1, n):
    arr[i] = arr[i-1] + arr[i]
    
print(*arr)
```

<pre>
5
1 2 3 4 5
1 3 6 10 15
</pre>
<strong>1493 : [기초-배열연습] 2차원 누적 합 배열 만들기 5-2</strong><br>

n\*m개의 데이터를 배열에 입력 받은 후,



(1, 1) 데이터 ~ (n, m) 영역의 누적 합 배열을 만들고 출력해보자.



3\*5개의 데이터가 다음과 같이 입력되었을 때,



1 2 3 4 5<br>

5 4 3 2 1<br>

1 5 2 4 3



아래와 같이 출력하면 된다.



1 3 6 10 15<br>

6 12 18 24 30<br>

7 18 26 36 45



k번째 위치에 저장되어야 하는 값의 관계식은 어떻게 표현할 수 있을까?

s[i][j] = ?



```python
n, m = map(int, input().split())
arr = [list(map(int, input().split())) for _ in range(n)]

for i in range(1, n):
    for j in range(m):
        arr[i][j] = arr[i-1][j] + arr[i][j]
        
for i in range(n):
    for j in range(1, m):
        arr[i][j] = arr[i][j-1] + arr[i][j]
        
for i in range(n):
    print(*arr[i])
```

<pre>
3 5
1 2 3 4 5
5 4 3 2 1
1 5 2 4 3
1 3 6 10 15
6 12 18 24 30
7 18 26 36 45
</pre>

# 차이 배열 만들기

<strong>1494 : [기초-배열연습] 1차원 차이 배열 만들기 5-3</strong><br>

크기가 n인 1차원 배열 d[]에 대해



k개의 구간 [s, e]와 u를 입력 받아,



d[s] = d[s]+u;<br>

d[e+1] = d[e+1]-u;



를 수행한 후, 누적 합을 만들어 출력해보자.



크기가 7이고,



4개의 구간 데이터

1 2 1<br>

2 3 1<br>

3 4 1<br>

4 5 1



가 입력되면



1차원 배열의 상태는<br> 

1 1 0 0 –1 –1 0<br>

가 되며



그 누적합을 계산하면 아래와 같다.<br>

1 2 2 2 1 0 0



```python
n, k = map(int, input().split())
d = [0] * 100

for i in range(k):
    s, e, u = map(int, input().split())
    d[s-1] = d[s-1] + u
    d[e] = d[e]-u

for i in range(n):
    print(d[i], end=' ')
print()

result = 0
for i in range(n):
    result += d[i]
    print(result, end=' ')
```

<pre>
7 4
1 2 1
2 3 1
3 4 1
4 5 1
1 1 0 0 -1 -1 0 
1 2 2 2 1 0 0 
</pre>
<strong>1495 : [기초-배열연습] 2차원 차이 배열 만들기 5-4</strong><br>

크기가 n*m인 2차원 배열 d[][]에 대해



k개의 구간 [(x1, y1), (x2, y2)] 과 u를 입력 받아,



d[x1][y1] = d[x1][y1]+u;

d[x2+1][y2+1] = d[x2+1][y2+1]+u;



d[x1][y2+1] = d[x1][y2+1]-u;

d[x2+1][y1] = d[x2+1][y1]-u;



를 수행한 후, 누적 합을 만들어 출력해보자.



크기가 7\*7이고,



4개의 구간 데이터<br>

1 1 2 2 1<br>

2 2 3 3 1<br>

3 3 4 4 1<br>

4 4 5 5 1



가 입력되면



2차원 배열의 상태는<br>

0 0 0 0 0 0 0<br>

0 1 0 –1 0 0 0<br>

0 0 1 0 –1 0 0<br>

0 –1 0 2 0 –1 0<br>

0 0 –1 0 2 0 -1<br>

0 0 0 -1 0 1 0<br>

0 0 0 0 -1 0 1



가 되며 그 누적합을 계산하면 아래와 같다.



0 0 0 0 0 0 0<br>

0 1 1 0 0 0 0<br>

0 1 2 1 0 0 0<br>

0 0 1 2 1 0 0<br>

0 0 0 1 2 1 0<br>

0 0 0 0 1 1 0<br>

0 0 0 0 0 0 0



```python
n, m, k = map(int, input().split())
d = [[0] * 1001 for _ in range(1001)]

# 배열 생성
for i in range(k):
    x1, y1, x2, y2, u = map(int, input().split())
    
    d[x1][y1] = d[x1][y1] + u
    d[x2+1][y2+1] = d[x2+1][y2+1] + u
    
    d[x1][y2+1] = d[x1][y2+1] - u
    d[x2+1][y1] = d[x2+1][y1] - u

# 배열 출력
for i in range(n):
    for j in range(m):
        print(d[i][j], end=' ')
    print()
print()

# 누적합 구하기
result = 0
for i in range(1000):
    for j in range(1000):
        result += d[i][j]
        d[i][j] = result
    result = 0
        
result = 0
for j in range(1000):
    for i in range(1000):
        result += d[i][j]
        d[i][j] = result
    result = 0
        
# 배열 출력
for i in range(n):
    for j in range(m):
        print(d[i][j], end=' ')
    print()
```

<pre>
7 7 4
1 1 2 2 1
2 2 3 3 1
3 3 4 4 1
4 4 5 5 1
0 0 0 0 0 0 0 
0 1 0 -1 0 0 0 
0 0 1 0 -1 0 0 
0 -1 0 2 0 -1 0 
0 0 -1 0 2 0 -1 
0 0 0 -1 0 1 0 
0 0 0 0 -1 0 1 

0 0 0 0 0 0 0 
0 1 1 0 0 0 0 
0 1 2 1 0 0 0 
0 0 1 2 1 0 0 
0 0 0 1 2 1 0 
0 0 0 0 1 1 0 
0 0 0 0 0 0 0 
</pre>
이게 무슨 억지인지 모르겠는데 정답이긴 하다.. 메모리와 시간 전부 잡아먹는 풀이인데 다른 방법을 찾아보던가 해야겠다.

# 묶은 후 연산하는 배열 만들기

<strong>1496 : [기초-배열연습] 두 개씩 묶어 작은 값 골라 배열 만들기 5-5</strong><br>

n개의 데이터를 배열에 입력 받은 후,



두 개씩 묶어 비교한 후, 작은 값만 들어간 배열을 만들고 출력해보자.



6개의 데이터가 다음과 같이 입력되었을 때,<br>

1 2 3 4 5 6



아래와 같이 출력하면 된다.



1 3 5



k번째 위치에 저장되어야 하는 값은 다음과 같이 표현할 수도 있다.<br>

m[k] = min(m[2\*k], m[2\*k+1]); //k >= 0



```python
n = int(input())
m = list(map(int, input().split()))

for i in range(0, n, 2):
    print(min(m[i], m[i+1]), end=' ')
```

<pre>
6
1 3 5 6 4 2
1 5 2 
</pre>
<strong>1497 : [기초-배열연습] 두 개씩 묶어 큰 값 골라 배열 만들기 5-6</strong><br>

n개의 데이터를 배열에 입력 받은 후,



두 개씩 묶어 비교한 후, 큰 값만 들어간 배열을 만들고 출력해보자.



6개의 데이터가 다음과 같이 입력되었을 때,<br>

1 2 3 4 5 6



아래와 같이 출력하면 된다.



2 4 6



k번째 위치에 저장되어야 하는 값은 다음과 같이 표현할 수도 있다.<br>

m[k] = max(m[2\*k], m[2\*k+1]); //k >= 0



```python
n = int(input())
m = list(map(int ,input().split()))

for i in range(0, n, 2):
    print(max(m[i], m[i+1]), end=' ')
```

<pre>
6
1 3 5 6 4 2
3 6 4 
</pre>
<strong>1498 : [기초-배열연습] 여러 개씩 묶어 작은 값 골라 배열 만들기 5-7</strong><br>

n개의 데이터를 배열에 입력 받은 후,



g개씩 묶어 비교한 후, 작은 값만 들어간 배열을 만들고 출력해보자.



6개의 데이터가 다음과 같이 입력되었을 때,<br>

1 2 3 4 5 6



3개씩 묶어 비교한 후, 작은 값만 들어간 배열을 만들어<br>

아래와 같이 출력하면 된다.



1 4



```python
n, g = map(int, input().split())
m = list(map(int, input().split()))
d = n // g    # n개의 데이터가 g번씩 몇 번 묶이는지?
c = n % g    # 묶고 남은 개수: 나머지

for i in range(d):
    print(min(m[g*i:g*i+g]), end=' ')
if c != 0: # 만약 묶고 남은 개수가 있다면 출력
    print(min(m[-c:]))
```

<pre>
8 3
479 520 -602 154 -535 -733 555 696
-602 -733 555
</pre>
<strong>1499 : [기초-배열연습] 여러 개씩 묶어 큰 값 골라 배열 만들기 5-8</strong><br>

n개의 데이터를 배열에 입력 받은 후,



g개씩 묶어 비교한 후, 큰 값만 들어간 배열을 만들고 출력해보자.



6개의 데이터가 다음과 같이 입력되었을 때,<br>

1 2 3 4 5 6



3개씩 묶어 비교한 후, 큰 값만 들어간 배열을 만들어<br>

아래와 같이 출력하면 된다.



3 6



```python
n, g = map(int, input().split())
m = list(map(int, input().split()))
d = n // g    # n개의 데이터가 g번씩 몇 번 묶이는지?
c = n % g    # 묶고 남은 개수: 나머지

for i in range(d):
    print(max(m[g*i:g*i+g]), end=' ')
if c != 0:    # 만약 묶고 남은 개수가 있다면 출력
    print(max(m[-c:]))
```

<pre>
5 3
1 3 5 4 2
5 4
</pre>

# 복습 문제

<strong>1501 : 2차원 배열 채우기 1</strong><br>

n이 입력되면 크기가 n인 다음과 같은 2차원 배열을 출력하시오.



입력 예)<br>

3<br>

출력 예)<br>

1 2 3<br>

4 5 6<br>

7 8 9



```python
n = int(input())
cnt = 0
arr = [[0] * n for _ in range(n)]

for i in range(n):
    for j in range(n):
        cnt += 1
        arr[i][j] = cnt

for i in range(n):
    print(*arr[i])
```

<pre>
2
1 2
3 4
</pre>
<strong>1502 : 2차원 배열 채우기 2</strong><br>

n이 입력되면 크기가 n인 다음과 같은 2차원 배열을 출력하시오.



입력 예)<br>

3<br>

출력 예)<br>

1 4 7<br>

2 5 8<br>

3 6 9



```python
n = int(input())
cnt = 0
arr = [[0] * n for _ in range(n)]

for j in range(n):
    for i in range(n):
        cnt += 1
        arr[i][j] = cnt
        
for i in range(n):
    print(*arr[i])
```

<pre>
2
1 3
2 4
</pre>
<strong>1503 : 지그재그 입력(2차원 배열)</strong><br>

하나의 정수N을 입력받아 다음과 같이 작성하시오.



지그재그로 출력하시오.



N이 5라면 다음과 같이 출력한다.



1 2 3 4 5



10 9 8 7 6



11 12 13 14 15



20 19 18 17 16



21 22 23 24 25



```python
N = int(input())
cnt = 0
arr = [[0] * N for _ in range(N)]

for i in range(N):
    for j in range(N):
        cnt += 1
        if i % 2 == 0:
            arr[i][j] = cnt
        else:
            arr[i][N-j-1] = cnt

for i in range(N):
    print(*arr[i])
```

<pre>
3
1 2 3
6 5 4
7 8 9
</pre>
<strong>1504 : 지그재그 배열 2</strong><br>

하나의 정수 N을 입력받아 다음과 같이 지그재그로 출력하시오.



N이 3이라면,



1 6 7



2 5 8



3 4 9



```python
n = int(input())
cnt = 0
arr = [[0] * n for _ in range(n)]

for i in range(n):
    for j in range(n):
        cnt += 1
        if i % 2 == 0:
            arr[j][i] = cnt
        else:
            arr[n-j-1][i] = cnt
            
for i in range(n):
    print(*arr[i])
```

<pre>
5
1 10 11 20 21
2 9 12 19 22
3 8 13 18 23
4 7 14 17 24
5 6 15 16 25
</pre>
<strong>1505 : 2차원 배열 채우기 3(달팽이 배열)</strong><br>

n이 입력되면 크기가 n인 다음과 같은 2차원 배열을 출력하시오.



입력 예)<br>

3<br>

출력 예)<br>

1 2 3<br>

8 9 4<br>

7 6 5



```python
n = int(input())
arr = [[0] * n for _ in range(n)]
row, column, cnt = 0, -1, 0
row_size, column_size = n, n
step = 1

while row_size and column_size:
    for _ in range(column_size):
        cnt += 1
        column += step
        arr[row][column] = cnt
        
    row_size -= 1
    
    for _ in range(row_size):
        cnt += 1
        row += step
        arr[row][column] = cnt
        
    column_size -= 1
    step = -step
    
for i in range(n):
    print(*arr[i])
```

<pre>
3
1 2 3
8 9 4
7 6 5
</pre>
<strong>1506 : 2차원 배열 채우기 4(역달팽이 배열)</strong><br>

평소 호기심이 많은 남호는 정보고 사이트에 있는 달팽이 배열 문제를 다르게 만들고 싶었다.



입력 예시와 출력 예시를 참고 하여 n을 입력 받아 출력하는 프로그램을 작성하시오.



```python
n = int(input())
arr = [[0] * n for _ in range(n)]
row, column, cnt = -1, 0, 0
row_size, column_size = n, n
step = 1

while row_size and column_size:
    for _ in range(row_size):
        cnt += 1
        row += step
        arr[row][column] = cnt
    
    column_size -= 1
    
    for _ in range(column_size):
        cnt += 1
        column += step
        arr[row][column] = cnt
        
    row_size -= 1
    step = -step
    
for i in range(n):
    print(*arr[i])
```

<pre>
5
1 16 15 14 13
2 17 24 23 12
3 18 25 22 11
4 19 20 21 10
5 6 7 8 9
</pre>

# 기타 실행활 적용 구현 문제

<strong>1507 : 4개의 직사각형 넓이</strong><br>

평면에 네 개의 직사각형이 놓여 있는데 그 밑변은 모두 가로축에 평행하다.



이 네 개의 직사각형들은 서로 떨어져 있을 수도 있고, 겹쳐 있을 수도 있고, 하나가 다른 하나를 포함할 수도 있으며, 변이나 꼭지점이 겹칠 수도 있다.



이 직사각형들이 차지하는 면적을 구하는 프로그램을 작성하시오. 



```python
arr = [[0] * 100 for _ in range(100)]
for _ in range(4):
    x1, y1, x2, y2 = map(int, input().split())
    for x in range(x1, x2):
        for y in range(y1, y2):
            arr[x][y] = 1
            
result = 0
for i in range(100):
    cnt = arr[i].count(1)
    result += cnt
    
print(result)
```

<pre>
1 2 3 4
2 3 5 7
3 1 6 5
7 3 8 6
26
</pre>
오늘 뉴스기사에 다음과 같은 기사가 났다.



![image1](../../images/2022_09_02_image/image1.png)



?에 들어갈 숫자가 무엇인지 알면 IQ 150이라는 문제이다.



원리는 조금만 생각해보면 쉽게 알 수 있다. 따라서 우리는 충분히 IQ 150이라는...



이 상황을 좀 더 일반화하여 각 행의 제일 첫 번째 숫자들만 주어지면 N크기의 모든 격자판 정보를 출력하는 프로그램을 작성하시오.



```python
N = int(input())
arr = [[0] * 20 for _ in range(20)]

for i in range(N):
    arr[i][0] = int(input())
    if i > 0:
        for j in range(i):
            arr[i][j+1] = arr[i][j] - arr[i-1][j]

for i in range(N):
    for j in range(i+1):
        print(arr[i][j], end=' ')
    print()
```

<pre>
4
4
6
9
19
4 
6 2 
9 3 1 
19 10 7 6 
</pre>
<strong>1509 : 진격 후 결과</strong><br>

10*10 크기의 보드판이 있다.



각 말들은 제일 아래쪽에서 위쪽 방향으로 진격한다.



장애물은 0이 아닌 숫자로 나타내며, 0보다 크면 블럭 장애물, 0보다 작으면 구덩이 장애물, 0이면 평지이다.



10\*10 보드판의 정보가 입력되고, 각 세로줄 아래에 말이 있으면 1, 없으면 0이 입력될 때 각 말의 생존여부를 구하는 프로그램을 구현하시오.



```python
# 보드판의 정보 입력
board = [list(map(int, input().split())) for _ in range(10)]
# 각 말의 위치 여부 입력
option = list(map(int, input().split()))

# 10번 반복하며
for i in range(len(option)):
    if option[i] == 1:    # 만약 말이 있으면(1)
        for j in range(9, -1, -1):    # 그 말이 있는 위치의 세로줄을 아래에서부터 위로 올라가며
            if board[j][i] > 0:    # 양수(블럭 장애물)이 있으면 출력 후 탈출
                print(i + 1, 'crash')
                break
            if board[j][i] < 0:    # 음수(구덩이)가 있으면 출력 후 탈출
                print(i + 1, 'fall')
                break
            if j == 0:    # break문으로 탈출 없이 0까지(가장 위까지) 도달할 경우 'safe' 출력
                print(i + 1, 'safe')
```

<pre>
0 0 0 0 0 0 0 0 0 0
0 2 0 0 0 0 0 0 0 0 
0 0 -1 0 0 0 0 0 2 0
0 0 0 0 0 0 0 6 0 0 
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 -4 2 0 0 0 
0 0 2 0 0 0 0 0 0 0 
0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 
1 1 0 0 1 1 0 1 0 1
1 safe
2 crash
5 crash
6 fall
8 crash
10 safe
</pre>
<strong>1510 : 홀수 마방진</strong><br>

마방진(magic square)이란 가로, 세로, 대각선의 합이 같은 사각형을 말한다.



홀수 n을 입력으로 받아 n*n 홀수 마방진을 만들어 보자.



만드는 방법은 여러가지 방법이 있지만, 아래와 같은 방법을 이용하여 구현해보자.



구현 방법:



1. 시작은 첫 행, 한 가운데 열에 1을 둔다.



2. 행을 감소, 열을 증가하면서 순차적으로 수를 넣어간다.



3. 행은 감소하므로 첫 행보다 작아지는 경우에는 마지막 행으로 넘어간다.



4. 열은 증가하므로 마지막 열보다 커지는 경우에는 첫 열로 넘어간다.



5. 넣은 수가 n의 배수이면 행만 증가한다. 열은 변화없음.



```python
# 홀수 n을 입력
n = int(input())
val = 1
row, column = 0, n // 2
# n x n 마방진을 0으로 초기화
ms = [[0] * n for _ in range(n)]
# 1. 시작은 첫 행, 한 가운데 열에 1을 둔다.
ms[row][column] = val

# val이 n*n보다 같거나 커지기 전까지 반복
while val < n * n:
    if val % n != 0: 
        row = (row - 1 + n) % n # 2. 행을 감소, 3. 행은 감소하므로 첫 행보다 작아지는 경우에는 마지막 행으로 넘어간다.
        column = (column + 1) % n # 2. 열을 증가, 4. 열은 증가하므로 마지막 열보다 커지는 경우에는 첫 열로 넘어간다.
    else:    # 5. 넣은 수가 n의 배수이면 행만 증가한다. 열은 변화없음.
        row += 1
        
    # 2. 순차적으로 수를 넣어간다.
    val += 1 
    ms[row][column] = val
    
for i in range(n):
    print(*ms[i])
```

<pre>
5
17 24 1 8 15
23 5 7 14 16
4 6 13 20 22
10 12 19 21 3
11 18 25 2 9
</pre>
<strong>1511 : 테두리의 합</strong><br>

정수 N을 입력받아 1~N*N까지 2차원 배열에 저장한 후 사각 테두리에 있는 배열값들만 합하여 출력하시오.



예를 들어) 3을 입력한다면



1 2 3



4 5 6



7 8 9 와 같이 배열에 저장한 후 테두리의 값인 1+2+3+6+9+8+7+4 = 40을 출력하는 프로그램을 작성하시오.



```python
# Sol1
N = int(input())
result = 0
arr = [[i * N + j + 1 for j in range(N)] for i in range(N)]
for j in range(N):
    result += (arr[0][j] + arr[N-1][j])
for j in range(1, N-1):
    result += (arr[j][0] + arr[j][N-1])
print(result)
```

<pre>
3
40
</pre>

```python
# Sol2
N = int(input())
result = 0
num = 1
for i in range(N):
    for j in range(N):
        # 첫 행이거나 첫 열이거나 마지막 행이거나 마지막 열이면
        if i == 0 or j == 0 or i == N-1 or j == N-1:
            # 합에 그 숫자를 더해라
            result += num
        num += 1
        
print(result)
```

<pre>
3
40
</pre>
<strong>1512 : 숫자 등고선</strong><br>

어느날 등산을하다가 길을 찾기 위해 지도를 보다가 땅의 높낮이를 표시되어 있는 등고선을 보면서 문득 2차원 배열로 숫자등고선을 만드는 문제가 생각났다.



여러분들은 배열크기 N과 시작위치 X , Y를 입력받아 숫자등고선을 만드시오.



예를 들어 배열크기가 5이고 시작위치가 3 , 4 라면 3, 4로 시작하는 다음과같은 숫자등고선을 만들수 있다.



6 5 4 3 4



5 4 3 2 3



4 3 2 1 2



5 4 3 2 3



6 5 4 3 4



```python
# Sol1
N = int(input())
X, Y = map(int, input().split())
arr = [[1] * N for _ in range(N)]
arr[X-1][Y-1] = 1    # 중심 설정

# 중심으로부터 아래 채우기
count = 1    
for x in range(X, N):
    for y in range(N):
        arr[x][y] += count
    count += 1

# 중심으로부터 위 채우기
count = 0
for x in range(X-1, -1, -1):
    for y in range(N):
        arr[x][y] += count
    count += 1
    
# 중심으로부터 오른쪽 채우기
for x in range(N):
    count = 1
    for y in range(Y, N):
        arr[x][y] += count
        count += 1

# 중심으로부터 왼쪽 채우기
for x in range(N):
    count = 1
    for y in range(Y-2, -1, -1):
        arr[x][y] += count
        count += 1

for i in range(N):
    print(*arr[i])
```

<pre>
5
3 4
6 5 4 3 4
5 4 3 2 3
4 3 2 1 2
5 4 3 2 3
6 5 4 3 4
</pre>

```python
# Sol2
# x와 y로부터의 맨해튼 거리
# 뒤의 +1은 중심이 1이므로 추가
def distance(a, b):
    return abs(a-x) + abs(b-y) + 1

n = int(input())
x, y = map(int, input().split())

for i in range(1, n+1):
    for j in range(1, n+1):
        print(distance(i, j), end=' ')
    print()
```

<pre>
5
3 4
6 5 4 3 4 
5 4 3 2 3 
4 3 2 1 2 
5 4 3 2 3 
6 5 4 3 4 
</pre>
<strong>1513 : 지그재그 배열 3</strong><br>

하나의 정수 n을 입력받아 n*n사각형에서 다음과 같은 삼각형 모양으로 지그재그로 출력하시오.



예를 들어, n이 5이면,



0 0 0 0 5<br>

0 0 0 4 6<br>

0 0 3 7 12<br>

0 2 8 11 13<br>

1 9 10 14 15<br>

를 출력한다.



```python
n = int(input())
r = n
row, column, cnt = n, -1, 0
arr = [[0] * n for _ in range(n)]
'''
4, 0 -> 3, 1 -> 2, 2 -> 1, 3 -> 0, 4 ->
1, 4 -> 2. 3 -> 3, 2 -> 4, 1 ->
4, 2 -> 3. 3 -> 2, 4 ->
3, 4 -> 4, 3 -> 
4, 4
'''
while r > 0:
    # 오른쪽 대각선으로 올라가기
    for _ in range(r):
        cnt += 1
        row -= 1
        column += 1
        arr[row][column] = cnt
    
    column += 1    # 다음을 위한 설정
    r -= 1    # 반복 횟수 줄이기
    
    # 왼쪽 대각선으로 내려가기
    for _ in range(r):
        cnt += 1
        row += 1
        column -=1
        arr[row][column] = cnt
        
    row += 1    # 다음을 위한 설정
    r -= 1

for i in range(n):
    print(*arr[i])
```

<pre>
6
0 0 0 0 0 6
0 0 0 0 5 7
0 0 0 4 8 15
0 0 3 9 14 16
0 2 10 13 17 20
1 11 12 18 19 21
</pre>
문제 중 달팽이 채우기가 많은 도움이 되었다.


<strong>1515 : 생명 게임 1</strong><br>

생명 게임은 25×25 격자에서 하는 게임이다.



각 칸에는 최대 1마리의 생명이 존재 할 수 있으며, 한 "세대"가 지날때 마다 생명이 탄생하거나 죽는다.



생명이 탄생하거나 죽는 조건은 다음과 같다:



1. 생명이 없는 칸의 주위 8칸에 정확히 3마리의 생명이 존재하는 경우 다음 세대에 그 칸에서 생명이 탄생한다.



2. 생명이 있는 칸의 주위 8칸에 4마리 이상 또는 1마리 이하의 생명이 존재하는 경우 다음 세대에 그 칸의 생명은 죽는다.



3. 생명이 있는 칸의 주위 8칸에 2마리 또는 3마리의 생명이 존재하는 경우 다음 세대에 그 칸의 생명은 생존한다.



25×25 격자의 생명의 위치가 주어질 때, 다음 세대의 모습을 출력하시오.



```python
# 25x25 격자의 생명의 위치 입력
brr = [list(map(int, input().split())) for _ in range(25)]

# 다뤄야 하는 크기는 27x27 격자이므로 0으로 초기화한 후 중간을 brr의 값으로 채워넣고 테두리에는 0을 유지
# zero padding
arr = [[0] * 27 for _ in range(27)]
for i in range(1, 26):
    for j in range(1, 26):
        arr[i][j] = brr[i-1][j-1]

# 테두리를 제외한 원소를 반복하며 주어진 조건에 따른 출력 실행
for i in range(1, 26):
    for j in range(1, 26):
        # 진행 중인 칸 주위 8칸의 합
        life = sum(arr[i-1][j-1:j+2]) + sum(arr[i+1][j-1:j+2]) + arr[i][j-1] + arr[i][j+1]
        if arr[i][j]:
            if life >= 4 or life <= 1:
                print(0, end=' ')
            elif life == 2 or life == 3:
                print(1, end=' ')
        else:
            if life == 3:
                print(1, end=' ')
            else:
                print(0, end=' ')
    print()
```

<pre>
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 1 0 0 
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 1 0 1 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 1 1 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 
0 0 1 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1 1 1 0 0 0 0 0 
0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 1 1 1 0 0 0 0 0 0 
0 0 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 

0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 1 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 1 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 1 1 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 
0 0 1 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 1 0 0 1 0 0 0 0 0 
0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 1 0 0 1 0 0 0 0 0 
0 0 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 1 0 0 0 0 0 0 0 
0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
</pre>
가독성을 위해 입력과 결과 사이 줄바꿈을 한 칸 추가했다.<br>
<strong>1520 : 생명 게임 2</strong><br>

생명 게임을 일반화 시켜보자.



이번에는 격자판의 크기 a * b가 주어지고,



생명이 태어나기 위한 조건(x), 생명을 유지하기 위한 최소 조건(y), 생명이 죽는 최소 조건(z)이 입력으로 주어진다.



룰은 아래 링크를 따라 생명게임 1을 참고하고(생명게임 1에서 조건들을 일반화 시킴),



k세대가 지난 후의 모습을 출력하시오. 



```python
# 격자판의 크기 a x b 입력
a, b = map(int, input().split())
# 생명이 태어나기 위한 조건(x), 생명을 유지하기 위한 최소 조건(y), 생명이 죽는 최소 조건(z) 입력
x, y, z = map(int, input().split())

# a x b 격자판에 생명의 위치 입력
crr = [list(map(int, input().split())) for _ in range(a)]
# 주어진 조건에서 격자판의 크기는 최대 170이므로 zero padding을 고려하여 172 x 172 격자판 생성
arr = [[0] * 172 for _ in range(172)]

# 172 x 172 격자판에 생명의 위치 입력
for i in range(1, a+1):
    for j in range(1, b+1):
        arr[i][j] = crr[i-1][j-1]

# 다음 세대의 격자판 상태
brr = [[0] * 172 for _ in range(172)]
# k 세대 입력
k = int(input())

# k 세대만큼 반복
for _ in range(k):
    # 입력받은 행과 열을 반복하며 참조
    for i in range(1, a+1):
        for j in range(1, b+1):
            # 주위 8칸 생명의 합을 해당 칸에 입력
            brr[i][j] = sum(arr[i-1][j-1:j+2]) + sum(arr[i+1][j-1:j+2]) + arr[i][j-1] + arr[i][j+1]
            # 만약 현재 세대의 칸에 생명이 없다면
            if arr[i][j] == 0:
                # 주위 생명의 합이 x와 같다면 다음 세대의 칸에 1을, 그렇지 않다면 0
                brr[i][j] = 1 if brr[i][j] == x else 0
            # 만약 현재 세대의 칸에 생명이 있다면
            else:
                # 주위 생명의 합이 y보다 크거나 같고 z보다 작으면 1, 그렇지 않으면 0
                brr[i][j] = 1 if y <= brr[i][j] < z else 0
    
    # 현재 세대에 다음 세대의 상태를 입력(k세대만큼 반복하기 위해서)
    for i in range(1, a+1):
        for j in range(1, b+1):
            arr[i][j] = brr[i][j]

# 출력
for i in range(1, a+1):
    for j in range(1, b+1):
        print(brr[i][j], end=' ')
    print()
```

<pre>
5 5
2 1 5
1 1 1 0 0
0 1 0 1 1
0 0 1 1 0
0 1 0 1 0
0 0 1 1 1
1

1 1 1 0 1 
0 1 0 1 1 
1 0 0 1 0 
0 1 0 0 0 
0 1 1 1 1 
</pre>
가독성을 위해 입력과 결과 사이에 줄 바꿈을 하나 추가했다.
아무리 찾아도 이 문제는 파이썬으로 시간문제의 벽을 넘을 수 없는 것 같다.


<strong>1524 : 지뢰 찾기 1</strong><br>

지뢰 찾기 게임은 윈도우 기본 게임으로 많이 알고 있을 것이다.



지뢰 찾기 1번 문제로 9 * 9 의 초급용 지뢰 맵이 있다고 하자.



좌표 값은 왼쪽 위에서 부터 (행, 열)의 순서이다.



만약 지뢰 맵이 다음과 같이 셋팅되어 있다고 가정하면,



0	1	1	0	0	0	0	0	0<br>

1	1	0	0	0	0	0	0	0<br>

0	0	0	0	0	0	0	1	0<br>

0	0	0	0	0	0	0	0	0<br>

0	0	0	1	1	0	1	0	1<br>

0	0	0	1	0	0	0	0	0<br>

0	0	0	0	0	0	0	0	0<br>

0	0	0	0	0	0	0	1	0<br>

1	0	1	0	0	0	1	1	0<br>

여기서 1은 지뢰, 0은 빈 칸을 의미한다.



지뢰 찾기에서 어떤 칸을 선택하면 그 칸 주변의 8방향의 칸에 지뢰가 있는 개수를 화면에 표시해준다.



예를 들어 (2, 3)의 좌표를 클릭하는 경우 주변의 지뢰가 3개 있으므로 3을 출력한다.( (1,2), (1,3), (2,2) )



만약 지뢰가 있는 칸을 선택한 경우 -1을 출력하고, 지뢰가 없으면 0을 출력한다.



지뢰 찾기 맵의 정보가 주어졌을 때 위와 같은 정보를 출력하는 프로그램을 작성하시오.



```python
# 지뢰 찾기 맵의 정보 입력
brr = [list(map(int, input().split())) for _ in range(9)]
# 9 x 9 지뢰 찾기 맵에 zero padding 까지 전체 11 x 11 맵 생성
arr = [[0] * 11 for _ in range(11)]

# zero padding 맵에 맵의 정보 입력
for i in range(1, 10):
    for j in range(1, 10):
        arr[i][j] = brr[i-1][j-1]
        
# 선택할 칸의 행(r)과 열(c)을 입력
r, c = map(int, input().split())

# 만약 선택한 자리가 지뢰가 있는 자리이면 -1을 출력
if arr[r][c] == 1:
    print(-1)
# 지뢰가 없는 자리이면
else:
    # 주변의 지뢰 개수를 출력
    count = sum(arr[r-1][c-1:c+2]) + sum(arr[r+1][c-1:c+2]) + arr[r][c-1] + arr[r][c+1]
    print(count)
```

<pre>
1 0 1 0 0 0 0 0 0 
1 0 0 0 1 0 0 0 0 
1 0 0 0 1 0 0 1 0 
1 0 1 1 1 0 0 0 0 
1 0 1 0 1 0 0 0 0 
1 0 1 1 1 0 0 1 0 
1 0 0 0 1 0 0 0 0 
1 0 0 0 1 0 0 1 0 
1 0 0 0 1 0 0 0 0 
5 4
8
</pre>
<strong>1525 : 크레이지 아케이드</strong><br>

게임 "크레이지 아케이드"를 구현해보자.



![image2](../../images/2022_09_02_image/image2.png)



10*10 크레이지 아케이드 게임 현황이 주어진다.



0은 빈공간을 뜻한다.



1 이상의 수는 물풍선으로, 물풍선은 자신의 숫자만큼 상하좌우로 터진다.



-1은 장애물로, 물풍선이 터질때 물줄기가 여기 닿으면 멈춘다.



그 후 플레이어의 수 n이 입력되고, n개의 플레이어의 행,열이 주어진다.



이 때, 플레이어는 장애물에 위치하지 않는다.



물풍선이 모두 터질 때의 정보를 출력하는 프로그램을 작성하라.



그 방법은 다음과 같다.



1. 보드판을 출력한다.(0은 빈공간, -1은 장애물, -2는 물풍선, 플레이어는 입력된 순서+1로 표현한다.)



2. 플레이어의 생존 유무를 출력한다.



```python
# 10 x 10 의 보드판 입력
arr = [list(map(int, input().split())) for _ in range(10)]
# 물풍선이 터진 후의 상태를 입력할 10 x 10 보드판
board = [[0] * 10 for _ in range(10)]

# 플레이어의 수(n) 입력
n = int(input())
# 플레이어의 위치(행, 열) 입력
pos = [list(map(int, input().split())) for _ in range(n)]

# 보드판의 각 원소를 하나씩 확인하며
for i in range(10):
    for j in range(10):
        # 만약 양수(물풍선)이라면
        if arr[i][j] > 0:
            # 해당 자리를 물줄기로 바꾸고
            board[i][j] = -2
            # 물풍선의 세기
            size = arr[i][j]
            # 왼쪽, 오른쪽, 위, 아래 참조
            l, r = j, j
            u, d = i, i
            # 왼쪽
            for k in range(l-1, l-size-1, -1):
                # 보드판의 왼쪽 끝을 넘어가거나 장애물을 만나면 물줄기를 멈춤
                if k < 0 or arr[i][k] == -1:
                    break
                else:
                    # 중심으로부터 왼쪽으로 물줄기를 진행
                    board[i][k] = -2
            # 오른쪽
            for k in range(r+1, r+size+1):
                # 보드판의 오른쪽 끝을 넘어가거나 장애물을 만나면 물줄기를 멈춤
                if k > 9 or arr[i][k] == -1:
                    break
                else:
                    # 중심으로부터 오른쪽으로 물줄기를 진행
                    board[i][k] = -2
            # 위쪽
            for k in range(u-1, u-size-1, -1):
                # 보드판의 위쪽 끝을 넘어가거나 장애물을 만나면 물줄기를 멈춤
                if k < 0 or arr[k][j] == -1:
                    break
                else:
                    # 중심으로부터 위쪽으로 물줄기를 진행
                    board[k][j] = -2
            # 아래쪽
            for k in range(d+1, d+size+1):
                # 보드판의 아래쪽 끝을 넘어가거나 장애물을 만나면 물줄기를 멈춤
                if k > 9 or arr[k][j] == -1:
                    break
                else:
                    # 중심으로부터 아래쪽으로 물줄기를 진행
                    board[k][j] = -2
        
        # 해당 자리가 장애물이라면
        elif arr[i][j] == -1:
            # 보드판의 자리에 -1(장애물)을 입력
            board[i][j] = -1

# 플레이어의 수만큼 반복
for i in range(n):
    # 보드판에서의 플레이어의 위치(p)
    p = board[pos[i][0]-1][pos[i][1]-1]
    # 만약 p가 0(물줄기가 아닌 빈공간)이라면
    if p == 0:
        # 보드판에서의 플레이어의 위치에 플레이어를 기록(입력된 순서+1)
        board[pos[i][0]-1][pos[i][0]-1] = i+1

# 최종 보드판의 상태 출력
for i in range(10):
    for j in range(10):
        print(board[i][j], end=' ')
    print()

# 플레이어의 생존 유무 출력
print('Character Information')
for i in range(n):
    p = board[pos[i][0]-1][pos[i][1]-1]
    if p == -2:
        print('player', i+1, 'dead')
    else:
        print('player', i+1, 'survive')
        board[pos[i][0]-1][pos[i][0]-1] = i+1
```

<pre>
0 0 0 -1 0 -1 -1 0 1 -1 
3 0 -1 0 -1 -1 1 0 0 0 
0 -1 3 -1 1 0 0 0 0 0
0 -1 -1 0 0 0 0 0 0 0 
-1 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 5 0 0 0 0 0 0
0 0 0 0 0 0 1 0 0 0 
0 0 0 0 0 0 0 0 0 0 
3
2 2
10 10
3 3

-2 0 0 -1 0 -1 -1 -2 -2 -1 
-2 -2 -1 0 -1 -1 -2 -2 -2 0 
-2 -1 -2 -1 -2 -2 -2 0 0 0 
-2 -1 -1 -2 -2 0 0 0 0 0 
-1 0 0 -2 0 0 0 0 0 0 
0 0 0 -2 0 0 0 0 0 0 
0 0 0 -2 0 0 0 0 0 0 
-2 -2 -2 -2 -2 -2 -2 -2 -2 0 
0 0 0 -2 0 -2 -2 -2 0 0 
0 0 0 -2 0 0 -2 0 0 2 
Character Information
player 1 dead
player 2 survive
player 3 dead
</pre>
가독성을 위해 입력과 출력 사이에 줄 바꿈 한 칸을 추가했다.<br>
<strong>4085 : 농사짓기 가장 좋은 땅 고르기</strong><br>

교원이는 전체 가로 m칸, 세로 n칸 크기의 땅에서 가장 비옥한 구역을 찾아 농사를 지으려고 한다. 비옥도(k)는 각 칸에 0~99 사이의 숫자로 표시되며, 교원이가 농사를 짓기 위해 골라야 하는 땅의 크기는 가로 x칸, 세로 y칸이다. 구역 비옥도(ka)를 각 칸 의 비옥도(k)의 합으로 결정한다면, 입력받은 땅 데이터에서 교원이가 찾을 수 있는 구 역 비옥도(ka)의 최댓값을 구하는 프로그램을 작성하시오.



 



예를 들어, 전체 가로 4칸, 세로 4칸 크기의 땅의 비옥도가 그림과 같이 주어져 있을 때, 교원 이가 농사를 짓기 위해 골라야 하는 땅의 크기가 가로 2칸, 세로 2칸이라고 한다면, 구역 비옥도(ka)의 최댓값은 색칠된 영역에 해당되는 수의 합이다. (3+4+1+7=15)



```python
# 가로 m칸, 세로 n칸, 땅의 크기 가로 x칸, 땅의 크기 세로 y칸 입력
m, n, x, y = map(int, input().split())
# m x n 의 각 칸의 비옥도(k) 입력
k = [list(map(int, input().split())) for _ in range(n)]
# 연산 후 구역 비옥도의 크기
pool = [[0] * (m-x+1) for _ in range(n-y+1)]
# 구역 비옥도의 각 줄마다의 최댓값
max_ka = [0] * (n-y+1)

# 구역 비옥도의 크기의 행 개수 만큼 반복
for i in range(len(pool)):
    # 해당 행부터 땅의 크기인 y값까지의 줄을 반복
    for j in k[i:i+y]:
        # 구역 비옥도의 크기의 열 개수 만큼 반복
        for q in range(len(pool[0])):
            # 구역 비옥도의 각 칸에 합 입력
            pool[i][q] += sum(j[q:q+x])
        # 각 줄마다의 최대값을 저장
        max_ka[i] = max(pool[i])

print(max(max_ka))
```

<pre>
10 3 2 2
10 15 11 24 55 21 10 19 14 10
10 12 19 19 44 39 24 15 14 11
10 77 66 50 50 50 40 35 25 15
183
</pre>