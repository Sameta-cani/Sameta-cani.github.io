---
layout: single
title:  "NumPy03"
categories: 
tag: [python]
toc: true
author_profile: false
toc_sticky: true
---

<head>
  <style>
    table.dataframe {
      white-space: normal;
      width: 100%;
      height: 240px;
      display: block;
      overflow: auto;
      font-family: Arial, sans-serif;
      font-size: 0.9rem;
      line-height: 20px;
      text-align: center;
      border: 0px !important;
    }

    table.dataframe th {
      text-align: center;
      font-weight: bold;
      padding: 8px;
    }

    table.dataframe td {
      text-align: center;
      padding: 8px;
    }

    table.dataframe tr:hover {
      background: #b8d1f3; 
    }

    .output_prompt {
      overflow: auto;
      font-size: 0.9rem;
      line-height: 1.45;
      border-radius: 0.3rem;
      -webkit-overflow-scrolling: touch;
      padding: 0.8rem;
      margin-top: 0;
      margin-bottom: 15px;
      font: 1rem Consolas, "Liberation Mono", Menlo, Courier, monospace;
      color: $code-text-color;
      border: solid 1px $border-color;
      border-radius: 0.3rem;
      word-break: normal;
      white-space: pre;
    }

  .dataframe tbody tr th:only-of-type {
      vertical-align: middle;
  }

  .dataframe tbody tr th {
      vertical-align: top;
  }

  .dataframe thead th {
      text-align: center !important;
      padding: 8px;
  }

  .page__content p {
      margin: 0 0 0px !important;
  }

  .page__content p > strong {
    font-size: 0.8rem !important;
  }

  </style>
</head>


# 유니버셜 함수: 배열의 각 원소를 빠르게 처리하는 함수

ufunc라고 불리기도 하는 유니버설 함수는 ndarray 안에 있는 데이터 <strong>원소별로 연산</strong>을 수행하는 함수다. 유니버설 함수는 하나 이상의 스칼라값을 받아서 하나 이상의 스칼라 결괏값을 반환하는 간단한 함수를 고속으로 수행할 수 있는 벡터화된 래퍼 함수라고 생각하면 된다.<br><br>


<ins>하나의 원소에 대응하여 값을 반환하는 유니버셜 함수를 <strong>단항</strong> 유니버셜 함수라고 한다. 또한, 2개의 인자를 취해서 단일 배열을 반환하는 함수는 <strong>이항</strong> 유니버셜 함수라고 한다.</ins><br><br>

여러 개의 배열을 반환하는 유니버셜 함수도 있다. 예를 들어 `modf`는 분수를 받아서 몫과 나머지를 함께 반환한다.<br><br>

유니버셜 함수는 선택적으로 out 인자를 취해 계산 결과를 따로 저장할 수도 있다.


다음은 사용가능한 단항 유니버셜 함수다.



|함수|설명|

|:---|:---|

|abs, fabs|각 원소(정수, 부동소수점수, 복소수)의 절댓값을 구한다. 복소수가 아닌 경우에는 빠른 연산을 위해서 fabs를 사용한다.|

|sqrt|각 원소의 제곱근을 계산한다. arr\*\*0.5와 동일하다.|

|square|각 원소의 제곱을 계산한다. arr\*\*2와 동일하다.|

|exp|각 원소에서 지수 e<sup>x</sup>을 계산한다.|

|log, log10, log2, log1p|각각 자연로그, 로그 10, 로그 2, 로그 (1+x)|

|sign|각 원소의 부호를 계산한다. 1(양수), 0(영), -1(음수)|

|ceil|각 원소의 소수자리를 올린다. 각 원소의 값보다 같거나 큰 정수 중 가장 작은 정수를 반환한다.|

|floor|각 원소의 소수자리를 내린다. 각 원소의 값보다 작거나 같은 정수 중 가장 작은 수를 반환한다.|

|rint|각 원소의 소수자리를 반올림한다. dtype은 유지된다.|

|modf|각 원소의 몫과 나머지를 각각의 배열로 반환한다.|

|isnan|각 원소가 숫자가 아닌지(Not a Number; NaN)를 나타내는 불리언 배열을 반환한다.|

|isfinite, isinf|각각 배열의 각 원소가 유한한지(non-inf, non-NaN) 무한한지 나타내는 불리언 배열을 반환한다.|

|cos, cosh, sin, sinh, tan, tanh|일반 삼각함수와 쌍곡삼각함수|

|arccos, arccosh, arcsin, arcsinh, arctan, arctanh|역삼각함수|

logical_not|각 원소의 논리 부정(not) 값을 계산한다. ~arr과 동일하다.|


다음은 사용가능한 이항 유니버셜 함수다.



|함수|설명|

|:---|:---|

|add|두 배열에서 같은 위치의 원소끼리 더한다.|

|subtract|첫 번째 배열의 원소에서 두 번째 배열의 원소를 뺀다.|

|multiply|배열의 원소끼리 곱한다.|

|divide, floor_divide|첫 번째 배열의 원소를 두 번째 배열의 원소로 나눈다. floor_divide는 몫만 취한다.|

|power|첫 번째 배열의 원소를 두 번째 배열의 원소만큼 제곱한다.|

|maximum, fmax|각 배열의 두 원소 중 큰 값을 반환한다. fmax는 NaN을 무시한다.|

|minimum, fmin|각 배열의 두 원소 중 작은 값을 반환한다. fmin은 NaN을 무시한다.|

|mod|첫 번째 배열의 원소를 두 번째 배열의 원소로 나눈 나머지를 구한다.|

|copysign|첫 번째 배열의 원소의 기호를 두 번째 배열의 원소의 기호로 바꾼다. 0은 양수 취급한다.|

|greater, greater_equal, less, less_equal, equal, not_equal|각각 두 원소 간의 >, >=, <, <=, ==, != 비교 연산 결과를 불리언 배열로 반환한다.|

|logical_and, logical_or, logical_xor|각각 두 원소 간의 &, \|, ^논리 연산 결과를 반환한다.|


# 배열을 이용한 배열지향 프로그래밍

NumPy 배열을 사용하면 반복문을 작성하지 않고 간결한 배열 연산을 사용해 많은 종류의 데이터 처리 작업을 할 수 있다. 배열 연산을 사용해서 반복문을 명시적으로 제거하는 기법을 흔히 벡터화라고 부르는데, 일반적으로 벡터화된 배열에 대한 산술 연산은 순수 파이썬 연산에 비해 2~3배에서 많게는 수십, 수백 배까지 빠르다.<br><br>

간단한 예로 값이 놓여 있는 그리드에서 $\sqrt{x^2 + y^2}$을 계산한다고 하자. `np.meshgrid` 함수는 두 개의 1차원 배열을 받아서 가능한 모든 (x, y) 짝을 만들 수 있는 2차원 배열 두 개를 반환한다.



```python
import numpy as np
```

잠깐 `np.meshgrid`에 대해 간단히 알아보자!



```python
points = np.arange(1, 6, 1) # 1부터 5까지 1씩 증가하는 값들의 배열
print(points)
```

<pre>
[1 2 3 4 5]
</pre>

```python
xs, ys = np.meshgrid(points, points)

print('xs:\n',xs) # x축 방향으로 points 나열
print('ys:\n',ys) # y축 방향으로 points 나열
```

<pre>
xs:
 [[1 2 3 4 5]
 [1 2 3 4 5]
 [1 2 3 4 5]
 [1 2 3 4 5]
 [1 2 3 4 5]]
ys:
 [[1 1 1 1 1]
 [2 2 2 2 2]
 [3 3 3 3 3]
 [4 4 4 4 4]
 [5 5 5 5 5]]
</pre>

```python
plt.scatter(xs, ys) # 각 위치에 맞게 점을 찍어 봄(1, 1), (2, 1), (3, 1), ..., (4, 5), (5, 5)
plt.show()
```

<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAXQAAAD4CAYAAAD8Zh1EAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjUuMSwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/YYfK9AAAACXBIWXMAAAsTAAALEwEAmpwYAAAUQElEQVR4nO3dX2hc553G8eepKraiSdGFh43/NWYhCDZhU4fBachSvKFUSWqaXOTChbYkNyYhgZTtquBepLSwF4ugJBtDjGlLa/rHlK0rQohXDbShyYVTRrZTt3W1lCUllsxaTZEdk6HYzm8v5jgej2c057WPZuS33w8Mmjnn1ZwfD9KTycyRjyNCAIAb34eGPQAAoBoUOgBkgkIHgExQ6ACQCQodADLx4WEdeN26dbFly5ZhHR4Abkhzc3N/johat31DK/QtW7ao0WgM6/AAcEOy/ade+3jLBQAyQaEDQCYodADIBIUOAJmg0AEgE6XOcrH9lqR3JV2UdCEi6h37Lek5SQ9Kek/SoxFxpNpRpZmjC5qendficlMbxsc0NTmhh7durPowWSGzNOSVhrzSrHZeKact/ktE/LnHvgck3Vbc7pb0QvG1MjNHF7T74HE1z1+UJC0sN7X74HFJ4geoBzJLQ15pyCvNIPKq6i2XhyTtj5bDksZtr6/ouSVJ07PzHwRxSfP8RU3Pzld5mKyQWRrySkNeaQaRV9lCD0k/tz1ne1eX/Rslvd32+GSx7Qq2d9lu2G4sLS0lDbq43EzaDjJLRV5pyCvNIPIqW+j3RsRdar218qTtT3Xsd5fvuerKGRGxLyLqEVGv1br+5WpPG8bHkraDzFKRVxrySjOIvEoVekQsFl9PS/qZpG0dS05K2tz2eJOkxSoGvGRqckJjoyNXbBsbHdHU5ESVh8kKmaUhrzTklWYQefX9UNT2RyV9KCLeLe5/RtI3O5a9KOkp2wfU+jD0TEScqmxKXf7QgE/UyyOzNOSVhrzSDCIv97umqO1/UOtVudT6D8CPIuLfbT8uSRGxtzhtcY+k+9U6bfGxiFjxX96q1+vBP84FAGlsz3WeOn5J31foEfG/ku7ssn1v2/2Q9OT1DAkAuD78pSgAZIJCB4BMUOgAkAkKHQAyQaEDQCYodADIBIUOAJmg0AEgExQ6AGSCQgeATFDoAJAJCh0AMkGhA0AmKHQAyASFDgCZoNABIBOlC932iO2jtl/qsm+77TO2jxW3Z6odEwDQT98rFrV5WtIJSR/rsf+1iNhx/SMBAK5FqVfotjdJ+qykb6/uOACAa1X2LZdnJX1V0vsrrLnH9pu2D9m+vdsC27tsN2w3lpaWEkcFAKykb6Hb3iHpdETMrbDsiKRbI+JOSc9Lmum2KCL2RUQ9Iuq1Wu1a5gUA9FDmFfq9kj5n+y1JByTdZ/sH7Qsi4mxEnCvuvyxp1Pa6qocFAPTWt9AjYndEbIqILZJ2SvpFRHyhfY3tW2y7uL+teN53VmFeAEAPKWe5XMH245IUEXslPSLpCdsXJDUl7YyIqGZEAEAZHlbv1uv1aDQaQzk2ANyobM9FRL3bPv5SFAAyQaEDQCYodADIBIUOAJmg0AEgExQ6AGSCQgeATFDoAJAJCh0AMkGhA0AmKHQAyASFDgCZoNABIBMUOgBkgkIHgExQ6ACQidJXLLI9IqkhaSEidnTss6TnJD0o6T1Jj0bEkSoHlaSZowuanp3X4nJTG8bHNDU5oYe3bqz6MFkhszTklYa80qx2XimXoHta0glJH+uy7wFJtxW3uyW9UHytzMzRBe0+eFzN8xclSQvLTe0+eFyS+AHqgczSkFca8koziLxKveVie5Okz0r6do8lD0naHy2HJY3bXl/JhIXp2fkPgrikef6ipmfnqzxMVsgsDXmlIa80g8ir7Hvoz0r6qqT3e+zfKOnttscni21XsL3LdsN2Y2lpKWVOLS43k7aDzFKRVxrySjOIvPoWuu0dkk5HxNxKy7psu+rq0xGxLyLqEVGv1WoJY0obxseStoPMUpFXGvJKM4i8yrxCv1fS52y/JemApPts/6BjzUlJm9seb5K0WMmEhanJCY2NjlyxbWx0RFOTE1UeJitkloa80pBXmkHk1fdD0YjYLWm3JNneLunfIuILHctelPSU7QNqfRh6JiJOVTalLn9owCfq5ZFZGvJKQ15pBpGXI656Z6T34suFvsP245IUEXuL0xb3SLpfrdMWH4uIxkrPVa/Xo9FYcQkAoIPtuYiod9uXctqiIuJVSa8W9/e2bQ9JT177iACA68VfigJAJih0AMgEhQ4AmaDQASATFDoAZIJCB4BMUOgAkAkKHQAyQaEDQCYodADIBIUOAJmg0AEgExQ6AGSCQgeATFDoAJCJMtcU/YjtX9t+0/bvbH+jy5rtts/YPlbcnlmdcQEAvZS5wMVfJd0XEedsj0p63fahiDjcse61iNhR/YgAgDLKXFM0JJ0rHo4Wt/LXrQMADESp99Btj9g+Jum0pFci4o0uy+4p3pY5ZPv2Hs+zy3bDdmNpaenapwYAXKVUoUfExYj4hKRNkrbZvqNjyRFJt0bEnZKelzTT43n2RUQ9Iuq1Wu3apwYAXCXpLJeIWFbrItH3d2w/GxHnivsvSxq1va6iGQEAJZQ5y6Vme7y4Pybp05L+0LHmFtsu7m8rnvedyqcFAPRU5iyX9ZK+b3tEraL+SUS8ZPtxSYqIvZIekfSE7QuSmpJ2Fh+mAgAGpMxZLr+RtLXL9r1t9/dI2lPtaACAFPylKABkgkIHgExQ6ACQCQodADJBoQNAJih0AMgEhQ4AmaDQASATFDoAZIJCB4BMUOgAkAkKHQAyQaEDQCYodADIBIUOAJmg0AEgE30vcGH7I5J+JenvivX/FRFf71hjSc9JelDSe5IejYgjVQ87c3RB07PzWlxuasP4mKYmJ/Tw1o1VHyYrZJaGvNKQV5rVzqvMJej+Kum+iDhne1TS67YPRcThtjUPSLqtuN0t6YXia2Vmji5o98Hjap6/KElaWG5q98HjksQPUA9kloa80pBXmkHk1fctl2g5VzwcLW6d1wt9SNL+Yu1hSeO211cyYWF6dv6DIC5pnr+o6dn5Kg+TFTJLQ15pyCvNIPIq9R667RHbxySdlvRKRLzRsWSjpLfbHp8stnU+zy7bDduNpaWlpEEXl5tJ20FmqcgrDXmlGURepQo9Ii5GxCckbZK0zfYdHUvc7du6PM++iKhHRL1WqyUNumF8LGk7yCwVeaUhrzSDyCvpLJeIWJb0qqT7O3adlLS57fEmSYvXM1inqckJjY2OXLFtbHREU5MTVR4mK2SWhrzSkFeaQeRV5iyXmqTzEbFse0zSpyX9R8eyFyU9ZfuAWh+GnomIU5VNqcsfGvCJenlkloa80pBXmkHk5Yir3hm5coH9T5K+L2lErVf0P4mIb9p+XJIiYm9x2uIetV65vyfpsYhorPS89Xo9Go0VlwAAOtiei4h6t319X6FHxG8kbe2yfW/b/ZD05PUMCQC4PvylKABkgkIHgExQ6ACQCQodADJBoQNAJih0AMgEhQ4AmaDQASATFDoAZIJCB4BMUOgAkAkKHQAyQaEDQCYodADIBIUOAJmg0AEgE30L3fZm27+0fcL272w/3WXNdttnbB8rbs+szrgAgF76XrFI0gVJX4mII7ZvljRn+5WI+H3HutciYkf1IwIAyuj7Cj0iTkXEkeL+u5JOSOIqsACwxiS9h257i1rXF32jy+57bL9p+5Dt23t8/y7bDduNpaWl9GkBAD2VLnTbN0n6qaQvR8TZjt1HJN0aEXdKel7STLfniIh9EVGPiHqtVrvGkQEA3ZQqdNujapX5DyPiYOf+iDgbEeeK+y9LGrW9rtJJAQArKnOWiyV9R9KJiPhWjzW3FOtke1vxvO9UOSgAYGVlznK5V9IXJR23fazY9jVJH5ekiNgr6RFJT9i+IKkpaWdERPXjAgB66VvoEfG6JPdZs0fSnqqGAgCk4y9FASATFDoAZIJCB4BMUOgAkAkKHQAyQaEDQCYodADIBIUOAJmg0AEgExQ6AGSCQgeATFDoAJAJCh0AMkGhA0AmKHQAyETffw/d9mZJ+yXdIul9Sfsi4rmONZb0nKQHJb0n6dGIOFL1sDNHFzQ9O6/F5aY2jI9panJCD2/dWPVhskJmacgrDXmlWe28ylyx6IKkr0TEEds3S5qz/UpE/L5tzQOSbitud0t6ofhamZmjC9p98Lia5y9KkhaWm9p98Lgk8QPUA5mlIa805JVmEHn1fcslIk5derUdEe9KOiGp8+gPSdofLYcljdteX8mEhenZ+Q+CuKR5/qKmZ+erPExWyCwNeaUhrzSDyCvpPXTbWyRtlfRGx66Nkt5ue3xSV5e+bO+y3bDdWFpaShp0cbmZtB1kloq80pBXmkHkVbrQbd8k6aeSvhwRZzt3d/mWqy4SHRH7IqIeEfVarZY06IbxsaTtILNU5JWGvNIMIq9ShW57VK0y/2FEHOyy5KSkzW2PN0lavP7xLpuanNDY6MgV28ZGRzQ1OVHlYbJCZmnIKw15pRlEXmXOcrGk70g6ERHf6rHsRUlP2T6g1oehZyLiVGVT6vKHBnyiXh6ZpSGvNOSVZhB5OeKqd0auXGD/s6TXJB1X67RFSfqapI9LUkTsLUp/j6T71Tpt8bGIaKz0vPV6PRqNFZcAADrYnouIerd9fV+hR8Tr6v4eefuakPTktY0HAKgCfykKAJmg0AEgExQ6AGSCQgeATFDoAJAJCh0AMkGhA0AmKHQAyASFDgCZoNABIBMUOgBkgkIHgExQ6ACQCQodADJBoQNAJih0AMhE30K3/V3bp23/tsf+7bbP2D5W3J6pfkwAQD99r1gk6XtqXV5u/wprXouIHZVMBAC4Jn1foUfEryT9ZQCzAACuQ1Xvod9j+03bh2zf3muR7V22G7YbS0tLFR0aACBVU+hHJN0aEXdKel7STK+FEbEvIuoRUa/VahUcGgBwyXUXekScjYhzxf2XJY3aXnfdkwEAklx3odu+xbaL+9uK53znep8XAJCm71kutn8sabukdbZPSvq6pFFJioi9kh6R9ITtC5KaknZGRKzaxACArvoWekR8vs/+PWqd1ggAGCL+UhQAMkGhA0AmKHQAyASFDgCZoNABIBMUOgBkgkIHgExQ6ACQCQodADJBoQNAJih0AMgEhQ4AmaDQASATFDoAZIJCB4BMUOgAkIkyVyz6rqQdkk5HxB1d9lvSc5IelPSepEcj4kjVg0rSzNEFTc/Oa3G5qQ3jY5qanNDDWzeuxqGyQWZpyCsNeaVZ7bz6Frqk76l1RaL9PfY/IOm24na3pBeKr5WaObqg3QePq3n+oiRpYbmp3QePSxI/QD2QWRrySkNeaQaRV9+3XCLiV5L+ssKShyTtj5bDksZtr69kujbTs/MfBHFJ8/xFTc/OV32obJBZGvJKQ15pBpFXFe+hb5T0dtvjk8W2q9jeZbthu7G0tJR0kMXlZtJ2kFkq8kpDXmkGkVcVhe4u26LbwojYFxH1iKjXarWkg2wYH0vaDjJLRV5pyCvNIPKqotBPStrc9niTpMUKnvcKU5MTGhsduWLb2OiIpiYnqj5UNsgsDXmlIa80g8irzIei/bwo6SnbB9T6MPRMRJyq4HmvcOlDAz5RL4/M0pBXGvJKM4i8HNH13ZHLC+wfS9ouaZ2k/5P0dUmjkhQRe4vTFvdIul+t0xYfi4hGvwPX6/VoNPouAwC0sT0XEfVu+/q+Qo+Iz/fZH5KevMbZAAAV4S9FASATFDoAZIJCB4BMUOgAkIm+Z7ms2oHtJUl/usZvXyfpzxWOU5W1Ope0dmdjrjTMlSbHuW6NiK5/mTm0Qr8ethu9TtsZprU6l7R2Z2OuNMyV5m9tLt5yAYBMUOgAkIkbtdD3DXuAHtbqXNLanY250jBXmr+puW7I99ABAFe7UV+hAwA6UOgAkIk1Xei2v2v7tO3f9thv2/9p+4+2f2P7rjUy13bbZ2wfK27PDGCmzbZ/afuE7d/ZfrrLmoHnVXKuYeT1Edu/tv1mMdc3uqwZRl5l5hp4Xm3HHrF91PZLXfYN5fexxFzDzOst28eL4171z8tWnllErNmbpE9JukvSb3vsf1DSIbWumvRJSW+skbm2S3ppwFmtl3RXcf9mSf8j6R+HnVfJuYaRlyXdVNwflfSGpE+ugbzKzDXwvNqO/a+SftTt+MP6fSwx1zDzekvSuhX2V5rZmn6FHmvkAtXXMNfARcSpiDhS3H9X0gldfW3XgedVcq6BKzI4VzwcLW6dZwgMI68ycw2F7U2SPivp2z2WDOX3scRca1mlma3pQi+h9AWqh+Ce4n+bD9m+fZAHtr1F0la1Xt21G2peK8wlDSGv4n/Tj0k6LemViFgTeZWYSxrOz9ezkr4q6f0e+4f18/WsVp5LGt7vY0j6ue0527u67K80sxu90EtfoHrAjqj17y3cKel5STODOrDtmyT9VNKXI+Js5+4u3zKQvPrMNZS8IuJiRHxCrevgbrN9R8eSoeRVYq6B52V7h6TTETG30rIu21Y1r5JzDe33UdK9EXGXpAckPWn7Ux37K83sRi/0gVygOlVEnL30v80R8bKkUdvrVvu4tkfVKs0fRsTBLkuGkle/uYaVV9vxlyW9qtZlFNsN9eer11xDyuteSZ+z/ZakA5Lus/2DjjXDyKvvXMP8+YqIxeLraUk/k7StY0mlmd3ohf6ipC8VnxR/Uqt0gepUtm+x7eL+NrVyfmeVj2lJ35F0IiK+1WPZwPMqM9eQ8qrZHi/uj0n6tKQ/dCwbRl595xpGXhGxOyI2RcQWSTsl/SIivtCxbOB5lZlrGHkVx/qo7Zsv3Zf0GUmdZ8ZVmlnfa4oOk9suUG37pDouUC3pZbU+Jf6jigtUr5G5HpH0hO0LkpqSdkbxkfYqulfSFyUdL95/laSvSfp421zDyKvMXMPIa72k79seUesX/CcR8ZLtx9vmGkZeZeYaRl5drYG8ysw1rLz+XtLPiv+WfFjSjyLiv1czM/70HwAycaO/5QIAKFDoAJAJCh0AMkGhA0AmKHQAyASFDgCZoNABIBP/DylbTGU+vnlLAAAAAElFTkSuQmCC"/>

`np.meshgrid`는 지정한 배열에 맞는 격자를 만들어 준다. 다시 원문으로 돌아와 $\sqrt{x^2 + y^2}$을 계산해 보겠다.



```python
points = np.arange(-5, 5, 0.01) # -5부터 4.99까지 0.01씩 증가하는 값들의 배열

xs, ys = np.meshgrid(points, points)

print('xs:\n', xs)
print('ys:\n', ys)
```

<pre>
xs:
 [[-5.   -4.99 -4.98 ...  4.97  4.98  4.99]
 [-5.   -4.99 -4.98 ...  4.97  4.98  4.99]
 [-5.   -4.99 -4.98 ...  4.97  4.98  4.99]
 ...
 [-5.   -4.99 -4.98 ...  4.97  4.98  4.99]
 [-5.   -4.99 -4.98 ...  4.97  4.98  4.99]
 [-5.   -4.99 -4.98 ...  4.97  4.98  4.99]]
ys:
 [[-5.   -5.   -5.   ... -5.   -5.   -5.  ]
 [-4.99 -4.99 -4.99 ... -4.99 -4.99 -4.99]
 [-4.98 -4.98 -4.98 ... -4.98 -4.98 -4.98]
 ...
 [ 4.97  4.97  4.97 ...  4.97  4.97  4.97]
 [ 4.98  4.98  4.98 ...  4.98  4.98  4.98]
 [ 4.99  4.99  4.99 ...  4.99  4.99  4.99]]
</pre>
이제 그리드 상의 두 포인트로 간단하게 계산을 적용할 수 있다.



```python
z = np.sqrt(xs ** 2 + ys ** 2) # sqrt(x^2 + y^2)

z
```

<pre>
array([[7.07106781, 7.06400028, 7.05693985, ..., 7.04988652, 7.05693985,
        7.06400028],
       [7.06400028, 7.05692568, 7.04985815, ..., 7.04279774, 7.04985815,
        7.05692568],
       [7.05693985, 7.04985815, 7.04278354, ..., 7.03571603, 7.04278354,
        7.04985815],
       ...,
       [7.04988652, 7.04279774, 7.03571603, ..., 7.0286414 , 7.03571603,
        7.04279774],
       [7.05693985, 7.04985815, 7.04278354, ..., 7.03571603, 7.04278354,
        7.04985815],
       [7.06400028, 7.05692568, 7.04985815, ..., 7.04279774, 7.04985815,
        7.05692568]])
</pre>
시각화를 해주는 matplotlib(맷플롯립)을 이용해서 이 2차원 배열을 시각화할 수 있다.



```python
import matplotlib.pyplot as plt

plt.imshow(z, cmap=plt.cm.gray); plt.colorbar()

plt.title("Image plot of $\sqrt{x^2 + y^2}$ for a grid of values")
plt.show()
```

<img src="data:image/png;base64,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"/>

## 배열 연산으로 조건절 표현하기

`numpy.where` 함수는 x if 조건 else y 같은 삼항식의 벡터화된 버전이다. 다음과 같은 불리언 배열 하나와 값이 들어 있는 두 개의 배열이 있다고 하자.



```python
xarr = np.array([1, 2, 3, 4, 5]) # 값이 들어 있는 배열
yarr = np.array([-1, -2, -3, -4, -5]) # 값이 들어 있는 배열
cond = np.array([True, False, True, True, False]) # 불리언 배열
```

cond의 값이 True일 때는 xarr의 값을 취하고 아니면 yarr의 값을 취하고 싶다면 리스트 표기법<sup>list comprehension</sup>을 이용해서 다음처럼 작성할 수 있다.



```python
result = [(x if c else y)
          for x, y, c in zip(xarr, yarr, cond)]

for c, v in zip(cond, result):
    print('{0}: {1}'.format(c, v)) # cond가 True일 때는 xarr, False일 때는 yarr
```

<pre>
True: 1
False: -2
True: 3
True: 4
False: -5
</pre>
이 방법은 순수 파이썬으로 수행되기 때문에 큰 배열을 빠르게 처리하지 못하고 다차원 배열에서는 사용할 수 없는 문제가 있다. 이를 대신해 `np.where`을 사용하면 아주 간결하게 사용할 수 있다.



```python
result = np.where(cond, xarr, yarr)

for c, v in zip(cond, result):
    print('{0}: {1}'.format(c, v)) # cond가 True일 때는 xarr, False일 때는 yarr
```

<pre>
True: 1
False: -2
True: 3
True: 4
False: -5
</pre>
`np.where`의 두 번째와 세 번째 인자는 배열이 아니어도 상관없다. 둘 중 하나 혹은 둘 다 스칼라값이어도 동작한다. 데이터 분석에서 일반적인 `where`의 사용은 다른 배열에 기반한 새로운 배열을 생성한다. 임의로 생성된 데이터가 들어 있는 행렬이 있고 양수는 모두 2로, 음수는 모두 -2로 바꾸려면 `np.where`를 사용해서 쉽게 처리할 수 있다.



```python
arr = np.random.randn(4, 4)

arr
```

<pre>
array([[-0.02976962, -0.01458426,  1.42759411, -0.88031711],
       [-1.19553913, -0.74505178, -0.3956748 ,  0.06363249],
       [ 0.71457475,  1.70660529, -0.15164689,  1.06711576],
       [-0.49864073, -0.17354365, -1.07199579, -0.17578479]])
</pre>

```python
arr > 0 # 0보다 큰 값에 대해서는 True, 작으면 False
```

<pre>
array([[False, False,  True, False],
       [False, False, False,  True],
       [ True,  True, False,  True],
       [False, False, False, False]])
</pre>

```python
np.where(arr > 0, 2, -2) # arr > 0의 조건절에 대해 True면 2, False면 -2를 대입 배열
```

<pre>
array([[-2, -2,  2, -2],
       [-2, -2, -2,  2],
       [ 2,  2, -2,  2],
       [-2, -2, -2, -2]])
</pre>
앞서 말한 대로 `np.where`는 스칼라값과 배열을 조합할 수 있다. 예를 들어 arr의 모든 양수를 2로 바꿀 수 있다.



```python
np.where(arr > 0, 2, arr) # 양수인 경우에만 2를 대입한다.
```

<pre>
array([[-0.02976962, -0.01458426,  2.        , -0.88031711],
       [-1.19553913, -0.74505178, -0.3956748 ,  2.        ],
       [ 2.        ,  2.        , -0.15164689,  2.        ],
       [-0.49864073, -0.17354365, -1.07199579, -0.17578479]])
</pre>
`np.where`로 넘기는 배열은 그냥 크기만 같은 배열이거나 스칼라값이 될 수 있다.


## 수학 메서드와 통계 메서드

배열 전체 혹은 배열에서 한 축을 따르는 자료에 대한 통계를 계산하는 수학 함수는 배열 메서드로 사용할 수 있다. 전체의 합(sum)이나 평균(mean), 표준편차(std)는 NumPy의 최상위 함수를 이요하거나 배열의 인스턴스 메서드를 사용해서 구할 수 있다.



```python
arr = np.random.randn(5, 4)

arr
```

<pre>
array([[-0.40803355, -1.44763423, -0.46975607,  1.13041391],
       [ 0.55472786,  2.51064512,  0.91108982,  0.34050927],
       [ 1.11245197,  2.13788859,  0.11894154, -1.43108026],
       [-0.80010396,  0.57906191,  0.07198797,  0.21484875],
       [ 0.22236126, -0.02624284, -1.46658882,  1.31371429]])
</pre>

```python
arr.mean() # 배열의 인스턴스 메서드
```

<pre>
0.25846012682626107
</pre>

```python
np.mean(arr) # NumPy의 최상위 함수
```

<pre>
0.25846012682626107
</pre>
`mean`이나 `sum` 같은 함수는 선택적으로 axis 인자를 받아서 해당 axis에 대한 통계를 계산하고 한 차수 낮은 배열을 반환한다.



```python
arr.mean(axis=1) # (5, 4) -> (5,)
```

<pre>
array([-0.29875248,  1.07924302,  0.48455046,  0.01644867,  0.01081097])
</pre>

```python
arr.sum(axis=0) # (5, 4) -> (4,)
```

<pre>
array([ 0.68140358,  3.75371854, -0.83432555,  1.56840597])
</pre>
axis=0 은 기준을 행(로우)로 잡으라는 의미이며, axis=1은 기준을 열(칼럼)으로 잡으라는 의미이다.


`cumsum`과 `cumprod` 메서드는 중간 계산값을 담고 있는 배열을 반환한다.



```python
arr = np.array([0, 1, 2, 3, 4, 5, 6, 7])

arr.cumsum()
```

<pre>
array([ 0,  1,  3,  6, 10, 15, 21, 28])
</pre>
다차원 배열에서 `cumsum`같은 누산 함수는 같은 크기의 배열을 반환한다. 하지만 축을 지정하여 부분적으로 계산하면 낮은 차수의 슬라이스를 반환한다.



```python
arr = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])

arr
```

<pre>
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
</pre>

```python
arr.cumsum(axis=0)
```

<pre>
array([[ 0,  1,  2],
       [ 3,  5,  7],
       [ 9, 12, 15]])
</pre>

```python
arr.cumsum(axis=1)
```

<pre>
array([[ 0,  1,  3],
       [ 3,  7, 12],
       [ 6, 13, 21]])
</pre>
다음은 기본 배열 통계 메서드다.



|메서드|설명|

|:---|:---|

|sum|배열 전체 혹은 특정 축에 대한 모든 원소의 합을 계산한다. 크기가 0인 배열에 대한 sum 결과는 0이다.|

|mean|산술 평균을 구한다. 크기가 0인 배열에 대한 mean 결과는 NaN이다.|

|std, var|각각 표준편차(std)와 분산(var)을 구한다. 선택적으로 자유도를 줄 수 있으며 분모의 기본 값은 n이다.|

|min, max|최솟값과 최댓값|

|argmin, argmax|최소 원소의 인덱스값과 최대 원소의 인덱스값|

|cumsum|각 원소의 누적합|

|cumprod|각 원소의 누적곱|


## 불리언 배열을 위한 메서드

이전 메서드의 불리언값을 1(True) 또는 0(False)으로 강제할 수 있다. 따라서 sum메서드를 실행하면 불리언 배열에서 True인 원소의 개수를 셀 수 있다.



```python
arr = np.random.randn(100)

(arr > 0).sum() # 양수인 원소의 개수
```

<pre>
55
</pre>
`any`와 `all` 메서드는 불리언 배열에 특히 유용하다. `any` 메서드는 하나 이상의 값이 True인지 검사하고, `all` 메서드는 모든 원소가 True인지 검사한다.



```python
bools = np.array([False, False, True, False])
```


```python
bools.any() # True 값이 1개 있으므로 True 반환
```

<pre>
True
</pre>

```python
bools.all() # 모두 원소가 True가 아니므로 False 반환
```

<pre>
False
</pre>
이들 메서드는 불리언 배열이 아니어도 동작하는데, 0이 아닌 원소는 모두 True로 간주한다.



```python
arr
```

<pre>
array([-0.90724395, -0.62877129,  0.20718284, -0.30639522,  0.30563246,
        0.64600853,  0.36622221, -0.20823254,  0.56306029,  0.08465395,
        0.17931446, -1.31047274,  1.31780143,  1.19431253,  0.77679295,
        0.66257028,  0.81578488, -0.10122762, -1.56994089,  0.7210543 ,
        1.57814075, -0.77683207,  0.53661484,  1.55243271, -0.70011526,
       -0.92437677,  0.06512332, -1.28821736, -0.42673967,  2.11522999,
       -0.06873509,  0.10835011,  0.16375313,  1.13753012,  0.60778277,
       -0.61662619,  0.90796244,  0.10654738,  1.53838342, -0.68642838,
        1.10722921,  0.05376696, -0.22741643,  0.19152851,  0.61814316,
       -0.7838633 , -2.52647135, -0.55955101, -1.62492829,  1.57278237,
       -0.84292233,  0.62413717, -0.58376745, -1.10119351, -2.19279612,
        2.01211672,  0.17202275,  2.33114224, -1.38486633, -0.95180022,
        0.67905259,  0.27600726,  2.29801415, -0.82937238,  0.91102118,
       -2.0647726 , -1.36350404,  1.16755995,  0.72074234,  2.39359361,
        0.46767095,  1.00898659,  1.25154436, -0.30093986, -3.05331187,
       -0.34446774,  0.42159384, -1.93885532,  1.52567005, -0.83601494,
        0.12425241, -2.53676551, -1.13924765,  0.91451041, -0.98690224,
       -0.33942484, -2.00901952,  0.32953966, -1.33603297,  0.21150542,
       -1.94545459, -0.73211461, -1.23605764, -0.48188263,  0.60539548,
        0.50564888, -0.30340103,  0.8815487 ,  0.05362069,  0.57654203])
</pre>

```python
arr.any()
```

<pre>
True
</pre>

```python
arr.all() # 음수도 True로 간주하므로 True가 나왔다.
```

<pre>
True
</pre>
## 정렬

넘파이의 행렬 정렬은 `np.sort()`와 같이 넘파이에서 `sort()`를 호출하는 방식과 `ndarray.sort()`와 같이 행렬 자체에서 `sort()`를 호출하는 방식이 있다. 두 방식의 차이는 <ins>`np.sort()`의 경우 원 행렬은 그대로 유지한 채 정렬된 결과를 가지고 있는 복사본을 반환하며, `ndarray.sort()`는 원 행렬 자체를 정렬한 형태로 변환하며 반환 값은 None이다.</ins>



```python
org_array = np.array([3, 1, 9, 5, 7, 2])
print('원본 행렬:', org_array)
# np.sort()로 정렬
sort_array1 = np.sort(org_array)
print('np.sort() 호출 후 반환된 정렬 행렬:', sort_array1)
print('no.sort() 호출 후 원본 행렬:', org_array)
# ndarray.sort()로 정렬
sort_array2 = org_array.sort()
print('org_array.sort() 호출 후 반환된 행렬:', sort_array2)
print('org_array.sort() 호출 후 원본 행렬:', org_array)
```

<pre>
원본 행렬: [3 1 9 5 7 2]
np.sort() 호출 후 반환된 정렬 행렬: [1 2 3 5 7 9]
no.sort() 호출 후 원본 행렬: [3 1 9 5 7 2]
org_array.sort() 호출 후 반환된 행렬: None
org_array.sort() 호출 후 원본 행렬: [1 2 3 5 7 9]
</pre>

```python
arr.sort()
arr 
```

<pre>
array([-1.55777475, -0.92121968, -0.21422782,  0.08067499,  0.89476559,
        0.9563294 ])
</pre>
`np.sort()`나 `ndarray.sort()` 모두 기본적으로 오름차순으로 행렬 내 원소를 정렬한다. <ins>내림차순으로 정렬하기 위해서는 [::-1]을 적용하여 `np.sort()[::-1]`과 같이 사용하면 된다.<ins>



```python
np.sort(org_array)[::-1]
```

<pre>
array([9, 7, 5, 3, 2, 1])
</pre>
행렬이 2차원 이상일 경우에 axis 축 값 설정을 통해 로우 방향, 또는 칼럼 방향으로 정렬을 수행할 수 있다.



```python
array2d = np.array([[8, 12],
                   [7, 1]])
sort_array2d_axis0 = np.sort(array2d, axis=0)
print('로우 방향으로 정렬:\n', sort_array2d_axis0)

sort_array2d_axis1 = np.sort(array2d, axis=1)
print('칼럼 방향으로 정렬:\n', sort_array2d_axis1)
```

<pre>
로우 방향으로 정렬:
 [[ 7  1]
 [ 8 12]]
칼럼 방향으로 정렬:
 [[ 8 12]
 [ 1  7]]
</pre>
## 집합 관련 함수

NumPy는 1차원 ndarray를 위한 몇 가지 기본적인 집합 연산을 제공한다. `np.unique` 는 배열 내에서 중복된 원소를 제거하고 남은 원소를 정렬된 형태로 반환하는 함수다.



```python
names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])

np.unique(names)
```

<pre>
array(['Bob', 'Joe', 'Will'], dtype='<U4')
</pre>

```python
ints = np.array([3, 3, 3, 2, 2, 1, 1, 4, 4])

np.unique(ints)
```

<pre>
array([1, 2, 3, 4])
</pre>
`np.in1d` 함수는 두 개의 배열을 인자로 받아서 첫 번째 배열의 원소가 두 번째 배열의 원소를 포함하는지 타나내는 불리언 배열을 반환한다.



```python
values = np.array([6, 0, 0, 3, 2, 5, 6])

np.in1d(values, [2, 3, 6])
```

<pre>
array([ True, False, False,  True,  True, False,  True])
</pre>
다음은 NumPy에서 제공하는 배열 집합 함수이다.



|메서드|설명|

|:---|:---|

|unique(x)|배열 x에서 중복된 원소를 제거한 뒤 정렬하여 반환한다.|

|intersect1d(x, y)|배열 x와 y에 공통적으로 존재하는 원소를 정렬하여 반환한다.|

|union1d(x, y)|두 배열의 합집합을 반환한다.|

|in1d(x, y)|x의 원소가 y의 원소에 포함되는지 나타내는 불리언 배열을 반환한다.|

|setdiff1d(x, y)|x와 y의 차집합을 반환한다.|

|setxor1d(x, y)|한 배열에는 포함되지만 두 배열 모두에는 포함되지 않는 원소들의 집합인 대칭차집합을 반환한다.|



```python
x = np.array([1, 3, 5, 7, 9])
y = np.array([9, 8, 7, 6, 5, 4, 3])

np.intersect1d(x, y) # 공통적으로 존재하는 원소를 정렬하여 반환
```

<pre>
array([3, 5, 7, 9])
</pre>
# 배열 데이터의 파일 입출력

NumPy는 디스크에서 텍스트나 바이너리 형식의 데이터를 불러오거나 저장할 수 있다.


`np.save`와 `np.load`는 배열 데이터를 효과적으로 디스크에 저장하고 불러오기 위한 함수다. 배열은 기본적으로 압축되지 않은 원시(가공되지 않은) 바이너리 형식의 .npy 파일로 저장된다.



```python
arr = np.arange(10)

np.save('some_array', arr)
```

저장되는 파일 경로가 .npy로 끝나지 않으면 자동적으로 확장자가 추가된다. 이렇게 저장된 배열은 `np.load`를 이용해서 불러올 수 있다.

![image-3.png](attachment:image-3.png)



```python
np.load('some_array.npy')
```

<pre>
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
</pre>
`np.savez`함수를 이용하면 여러 개의 배열을 압축된 형식으로 저장할 수 있는데, 저장하려는 배열을 키워드 인자 형태로 전달한다.



```python
np.savez('array_archive.npz', a=arr, b=arr)
```

![image.png](attachment:image.png)


npz 파일을 불러올 때는 각각의 배열을 필요할 때 불러올 수 있도록 사전 형식의 객체에 저장한다.



```python
arch = np.load('array_archive.npz')

arch['b']
```

<pre>
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
</pre>
압축이 잘되는 형식의 데이터라면 대신 `numpy.savez_compressed`를 사용하자.



```python
np.savez_compressed('arrays_compressed.npz', a=arr, b=arr)
```

![image.png](attachment:image.png)


# 선형대수

행렬의 곱셈, 분할, 행렬식 그리고 정사각 행렬 수학 같은 선형대수는 배열을 다루는 라이브러리에서 중요한 부분이다. <ins>행렬 내적은 행렬 곱이며, 두 행렬 A와 B의 내적은 `np.dot()`을 이용해 계산이 가능하다.</ins> 행렬 내적의 특성으로 왼쪽 행렬의 열 개수와 오른쪽 행렬의 행 개수가 동일해야 내적 연산이 가능하다.



```python
A = np.array([[1, 2, 3], # A의 크기는 (2, 3)
              [4, 5, 6]])
B = np.array([[7, 8], # B의 크기는 (3, 2)
              [9, 10],
              [11, 12]])

dot_product = np.dot(A, B)
print('행렬 내적의 결과:\n', dot_product)
```

<pre>
행렬 내적의 결과:
 [[ 58  64]
 [139 154]]
</pre>
`np.dot(x, y)`는 `x.dot(y)`와 동일하다.



```python
A.dot(B)
```

<pre>
array([[ 58,  64],
       [139, 154]])
</pre>
2차원 배열과 곱셈이 가능한 크기의 1차원 배열 간의 행렬 곱셈의 결과는 1차원 배열이다.



```python
np.dot(A, np.ones(3)) # 6 = 1 + 2 + 3, 15 = 4 + 5 + 6
```

<pre>
array([ 6., 15.])
</pre>
파이썬 3.5부터 사용할 수 있는 `@`기호는 행렬 곱셈을 수행하는 연산자다.



```python
A @ np.ones(3)
```

<pre>
array([ 6., 15.])
</pre>
<ins>원 행렬에서 행과 열 위치를 교환한 원소로 구성한 행렬을 그 행렬의 전치 행렬이라고 한다.</ins> 이때 행렬 A의 전치 행렬은 A<sup>T</sup>와 같이 표기한다.



```python
A = np.array([[1, 2],
              [3, 4]])
transpose_mat = np.transpose(A)
print('A의 전치 행렬:\n', transpose_mat)
```

<pre>
A의 전치 행렬:
 [[1 3]
 [2 4]]
</pre>
numpy.linalg는 행렬의 분할과 역행렬, 행렬식과 같은 것들을 포함하고 있다. 이는 MATLAB, R 같은 언어에서 사용하는 표준 포트란 라이브러리인 BLAS, LAPACK 또는 Intel MKL<sup>Math Kernel Library</sup>(NumPy 빌드에 따라 다르다)을 사용해서 구현되었다. 다음은 자주 사용하는 선형대수 함수이다.



|함수|설명|

|:---|:---|

|diag|정사각 행렬의 대각/비대각 원소를 1차원 배열로 반환하거나, 1차원 배열을 대각선 원소로 하고 나머지는 0으로 채운 단위행렬을 반환한다.|

|dot|행렬 곱셈(내적)|

|trace|행렬의 대각선 원소의 합을 계산한다.|

|det|행렬식을 계산한다.|

|eig|정사각 행렬의 고윳값과 고유벡터를 계산한다.|

|inv|정사각 행렬의 역행렬을 계산한다.|

|pinv|정사각 행렬의 무어-펜로즈 유사역원 역행렬을 구한다.|

|qr|QR 분해를 계산한다.|

|svd|특잇값 분해(SVD)를 계산한다.|

|solve|A가 정사각 행렬일 때 Ax = b를 만족하는 x를 구한다.|

|lstsq|Ax = b를 만족하는 최소제곱해를 구한다.|


# 난수 생성

numpy.random 모듈은 파이썬 내장 `random`함수를 보강하여 다양한 종류의 확률분포로부터 효과적으로 표본값을 생성하는 데 주로 사용된다. 예를 들어 `normal`을 사용하여 표준정규분포로부터 4x4 크기의 표본을 생성할 수 있다.



```python
samples = np.random.normal(size=(4, 4))

samples
```

<pre>
array([[-0.35707674,  1.17394871, -0.4338118 , -0.57904352],
       [-0.09021765, -0.19559481, -0.88596855,  1.02610079],
       [ 1.05375425, -0.62062368,  1.73299383,  0.14176114],
       [-1.43600832,  0.67144311,  1.25738013,  1.24417756]])
</pre>
이에 비해 파이썬 내장 random 모듈은 한 번에 하나의 값만 생성할 수 있다. 다음 성능 비교에서 알 수 있듯이 numpy.random은 매우 큰 표본을 생성하는데 파이썬 내장 모듈보다 수십 배 이상 빠르다.



```python
from random import normalvariate

N = 1000000

%timeit samples = [normalvariate(0, 1) for _ in range(N)]

%timeit np.random.normal(size=N)
```

<pre>
906 ms ± 29.8 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
24 ms ± 1.45 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
</pre>
이를 엄밀하게는 <strong>유사 난수</strong>라고 부르는데, 난수 생성기의 <strong>시드값</strong>에 따라 정해진 난수를 알고리즘으로 생성하기 때문이다. NumPy 난수 생성기의 시드값은 `np.random.seed`를 이용해서 변경할 수 있다.



```python
np.random.seed(1234)
```

numpy.random에서 제공하는 데이터를 생성할 수 있는 함수들은 전역 난수 시드값을 이용한다.<br>

`numpy.random.RandomState`를 이용해서 다른 난수 생성기로부터 격리된 난수 생성기를 만들 수 있다.



```python
rng = np.random.RandomState(1234)

rng.randn(10)
```

<pre>
array([ 0.47143516, -1.19097569,  1.43270697, -0.3126519 , -0.72058873,
        0.88716294,  0.85958841, -0.6365235 ,  0.01569637, -2.24268495])
</pre>
다음은 numpy.random에 포함된 일부 함수다.



|함수|설명|

|:---|:---|

|seed|난수 생성기의 시드를 지정한다.|

|permutation|순서를 임의로 바꾸거나 임의의 순열을 반환한다.|

|shuffle|리스트나 배열의 순서를 뒤섞는다.|

|rand|균등분포에서 표본을 추출한다.|

|randint|주어진 최소/최대 범위 안에서 임의의 난수를 추출한다.|

|randn|표준편차가 1이고 평균값이 0인 정규분포(매트랩과 같은 방식)에서 표본을 추출한다.|

|binomial|이항분포에서 표본을 추출한다.|

|normal|정규분포(가우시안)에서 표본을 추출한다.|

|beta|베타분포에서 표본을 추출한다.|

|chisquare|카이제곱분포에서 표본을 추출한다.|

|gamma|감마분포에서 표본을 추출한다.|

|uniform|균등 [0, 1) 분포에서 표본을 추출한다.|







